/* automatically generated by rust-bindgen */

pub const CAIRO_VERSION_MAJOR: libc::c_uint = 1;
pub const CAIRO_VERSION_MINOR: libc::c_uint = 14;
pub const CAIRO_VERSION_MICRO: libc::c_uint = 10;
pub const CAIRO_HAS_EGL_FUNCTIONS: libc::c_uint = 1;
pub const CAIRO_HAS_FC_FONT: libc::c_uint = 1;
pub const CAIRO_HAS_FT_FONT: libc::c_uint = 1;
pub const CAIRO_HAS_GLX_FUNCTIONS: libc::c_uint = 1;
pub const CAIRO_HAS_GL_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_GOBJECT_FUNCTIONS: libc::c_uint = 1;
pub const CAIRO_HAS_IMAGE_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_MIME_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_OBSERVER_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_PDF_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_PNG_FUNCTIONS: libc::c_uint = 1;
pub const CAIRO_HAS_PS_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_RECORDING_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_SCRIPT_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_SVG_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_TEE_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_USER_FONT: libc::c_uint = 1;
pub const CAIRO_HAS_XCB_SHM_FUNCTIONS: libc::c_uint = 1;
pub const CAIRO_HAS_XCB_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_XLIB_SURFACE: libc::c_uint = 1;
pub const CAIRO_HAS_XLIB_XRENDER_SURFACE: libc::c_uint = 1;
pub const CAIRO_MIME_TYPE_JPEG: &'static [u8; 11usize] = b"image/jpeg\x00";
pub const CAIRO_MIME_TYPE_PNG: &'static [u8; 10usize] = b"image/png\x00";
pub const CAIRO_MIME_TYPE_JP2: &'static [u8; 10usize] = b"image/jp2\x00";
pub const CAIRO_MIME_TYPE_URI: &'static [u8; 11usize] = b"text/x-uri\x00";
pub const CAIRO_MIME_TYPE_UNIQUE_ID: &'static [u8; 25usize] =
    b"application/x-cairo.uuid\x00";
pub const CAIRO_MIME_TYPE_JBIG2: &'static [u8; 26usize] =
    b"application/x-cairo.jbig2\x00";
pub const CAIRO_MIME_TYPE_JBIG2_GLOBAL: &'static [u8; 33usize] =
    b"application/x-cairo.jbig2-global\x00";
pub const CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID: &'static [u8; 36usize] =
    b"application/x-cairo.jbig2-global-id\x00";
pub const _SYS_TYPES_H: libc::c_uint = 1;
pub const _FEATURES_H: libc::c_uint = 1;
pub const _DEFAULT_SOURCE: libc::c_uint = 1;
pub const __USE_ISOC11: libc::c_uint = 1;
pub const __USE_ISOC99: libc::c_uint = 1;
pub const __USE_ISOC95: libc::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: libc::c_uint = 1;
pub const _POSIX_SOURCE: libc::c_uint = 1;
pub const _POSIX_C_SOURCE: libc::c_uint = 200809;
pub const __USE_POSIX: libc::c_uint = 1;
pub const __USE_POSIX2: libc::c_uint = 1;
pub const __USE_POSIX199309: libc::c_uint = 1;
pub const __USE_POSIX199506: libc::c_uint = 1;
pub const __USE_XOPEN2K: libc::c_uint = 1;
pub const __USE_XOPEN2K8: libc::c_uint = 1;
pub const _ATFILE_SOURCE: libc::c_uint = 1;
pub const __USE_MISC: libc::c_uint = 1;
pub const __USE_ATFILE: libc::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: libc::c_uint = 0;
pub const _STDC_PREDEF_H: libc::c_uint = 1;
pub const __STDC_IEC_559__: libc::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: libc::c_uint = 1;
pub const __STDC_ISO_10646__: libc::c_uint = 201505;
pub const __STDC_NO_THREADS__: libc::c_uint = 1;
pub const __GNU_LIBRARY__: libc::c_uint = 6;
pub const __GLIBC__: libc::c_uint = 2;
pub const __GLIBC_MINOR__: libc::c_uint = 25;
pub const _SYS_CDEFS_H: libc::c_uint = 1;
pub const __glibc_c99_flexarr_available: libc::c_uint = 1;
pub const __WORDSIZE: libc::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: libc::c_uint = 1;
pub const __SYSCALL_WORDSIZE: libc::c_uint = 64;
pub const _BITS_TYPES_H: libc::c_uint = 1;
pub const _BITS_TYPESIZES_H: libc::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: libc::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: libc::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: libc::c_uint = 1;
pub const __FD_SETSIZE: libc::c_uint = 1024;
pub const __clock_t_defined: libc::c_uint = 1;
pub const __clockid_t_defined: libc::c_uint = 1;
pub const __time_t_defined: libc::c_uint = 1;
pub const __timer_t_defined: libc::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: libc::c_uint = 1;
pub const _ENDIAN_H: libc::c_uint = 1;
pub const __LITTLE_ENDIAN: libc::c_uint = 1234;
pub const __BIG_ENDIAN: libc::c_uint = 4321;
pub const __PDP_ENDIAN: libc::c_uint = 3412;
pub const __BYTE_ORDER: libc::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: libc::c_uint = 1234;
pub const LITTLE_ENDIAN: libc::c_uint = 1234;
pub const BIG_ENDIAN: libc::c_uint = 4321;
pub const PDP_ENDIAN: libc::c_uint = 3412;
pub const BYTE_ORDER: libc::c_uint = 1234;
pub const _BITS_BYTESWAP_H: libc::c_uint = 1;
pub const _BITS_UINTN_IDENTITY_H: libc::c_uint = 1;
pub const _SYS_SELECT_H: libc::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: libc::c_uint = 1;
pub const __timeval_defined: libc::c_uint = 1;
pub const __timespec_defined: libc::c_uint = 1;
pub const FD_SETSIZE: libc::c_uint = 1024;
pub const _SYS_SYSMACROS_H: libc::c_uint = 1;
pub const _BITS_SYSMACROS_H: libc::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: libc::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: libc::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: libc::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: libc::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: libc::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: libc::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: libc::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: libc::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: libc::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: libc::c_uint = 4;
pub const __have_pthread_attr_t: libc::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: libc::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: libc::c_uint = 1;
pub const _STDINT_H: libc::c_uint = 1;
pub const __GLIBC_USE_LIB_EXT2: libc::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: libc::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: libc::c_uint = 0;
pub const _BITS_WCHAR_H: libc::c_uint = 1;
pub const INT8_MIN: libc::c_int = -128;
pub const INT16_MIN: libc::c_int = -32768;
pub const INT32_MIN: libc::c_int = -2147483648;
pub const INT8_MAX: libc::c_uint = 127;
pub const INT16_MAX: libc::c_uint = 32767;
pub const INT32_MAX: libc::c_uint = 2147483647;
pub const UINT8_MAX: libc::c_uint = 255;
pub const UINT16_MAX: libc::c_uint = 65535;
pub const UINT32_MAX: libc::c_uint = 4294967295;
pub const INT_LEAST8_MIN: libc::c_int = -128;
pub const INT_LEAST16_MIN: libc::c_int = -32768;
pub const INT_LEAST32_MIN: libc::c_int = -2147483648;
pub const INT_LEAST8_MAX: libc::c_uint = 127;
pub const INT_LEAST16_MAX: libc::c_uint = 32767;
pub const INT_LEAST32_MAX: libc::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: libc::c_uint = 255;
pub const UINT_LEAST16_MAX: libc::c_uint = 65535;
pub const UINT_LEAST32_MAX: libc::c_uint = 4294967295;
pub const INT_FAST8_MIN: libc::c_int = -128;
pub const INT_FAST16_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: libc::c_uint = 127;
pub const INT_FAST16_MAX: libc::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: libc::c_uint = 255;
pub const UINT_FAST16_MAX: libc::c_int = -1;
pub const UINT_FAST32_MAX: libc::c_int = -1;
pub const INTPTR_MIN: libc::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: libc::c_int = -1;
pub const PTRDIFF_MIN: libc::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: libc::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: libc::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: libc::c_uint = 2147483647;
pub const SIZE_MAX: libc::c_int = -1;
pub const WINT_MIN: libc::c_uint = 0;
pub const WINT_MAX: libc::c_uint = 4294967295;
pub const _SYS_UIO_H: libc::c_uint = 1;
pub const _BITS_UIO_H: libc::c_uint = 1;
pub const UIO_MAXIOV: libc::c_uint = 1024;
pub const _PTHREAD_H: libc::c_uint = 1;
pub const _SCHED_H: libc::c_uint = 1;
pub const SCHED_OTHER: libc::c_uint = 0;
pub const SCHED_FIFO: libc::c_uint = 1;
pub const SCHED_RR: libc::c_uint = 2;
pub const __defined_schedparam: libc::c_uint = 1;
pub const __CPU_SETSIZE: libc::c_uint = 1024;
pub const _TIME_H: libc::c_uint = 1;
pub const _BITS_TIME_H: libc::c_uint = 1;
pub const CLOCK_REALTIME: libc::c_uint = 0;
pub const CLOCK_MONOTONIC: libc::c_uint = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: libc::c_uint = 2;
pub const CLOCK_THREAD_CPUTIME_ID: libc::c_uint = 3;
pub const CLOCK_MONOTONIC_RAW: libc::c_uint = 4;
pub const CLOCK_REALTIME_COARSE: libc::c_uint = 5;
pub const CLOCK_MONOTONIC_COARSE: libc::c_uint = 6;
pub const CLOCK_BOOTTIME: libc::c_uint = 7;
pub const CLOCK_REALTIME_ALARM: libc::c_uint = 8;
pub const CLOCK_BOOTTIME_ALARM: libc::c_uint = 9;
pub const CLOCK_TAI: libc::c_uint = 11;
pub const TIMER_ABSTIME: libc::c_uint = 1;
pub const __struct_tm_defined: libc::c_uint = 1;
pub const __itimerspec_defined: libc::c_uint = 1;
pub const _XLOCALE_H: libc::c_uint = 1;
pub const TIME_UTC: libc::c_uint = 1;
pub const _BITS_SETJMP_H: libc::c_uint = 1;
pub const PTHREAD_ONCE_INIT: libc::c_uint = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: libc::c_int = -1;
pub const X_PROTOCOL: libc::c_uint = 11;
pub const X_PROTOCOL_REVISION: libc::c_uint = 0;
pub const X_TCP_PORT: libc::c_uint = 6000;
pub const XCB_CONN_ERROR: libc::c_uint = 1;
pub const XCB_CONN_CLOSED_EXT_NOTSUPPORTED: libc::c_uint = 2;
pub const XCB_CONN_CLOSED_MEM_INSUFFICIENT: libc::c_uint = 3;
pub const XCB_CONN_CLOSED_REQ_LEN_EXCEED: libc::c_uint = 4;
pub const XCB_CONN_CLOSED_PARSE_ERR: libc::c_uint = 5;
pub const XCB_CONN_CLOSED_INVALID_SCREEN: libc::c_uint = 6;
pub const XCB_CONN_CLOSED_FDPASSING_FAILED: libc::c_uint = 7;
pub const XCB_KEY_PRESS: libc::c_uint = 2;
pub const XCB_KEY_RELEASE: libc::c_uint = 3;
pub const XCB_BUTTON_PRESS: libc::c_uint = 4;
pub const XCB_BUTTON_RELEASE: libc::c_uint = 5;
pub const XCB_MOTION_NOTIFY: libc::c_uint = 6;
pub const XCB_ENTER_NOTIFY: libc::c_uint = 7;
pub const XCB_LEAVE_NOTIFY: libc::c_uint = 8;
pub const XCB_FOCUS_IN: libc::c_uint = 9;
pub const XCB_FOCUS_OUT: libc::c_uint = 10;
pub const XCB_KEYMAP_NOTIFY: libc::c_uint = 11;
pub const XCB_EXPOSE: libc::c_uint = 12;
pub const XCB_GRAPHICS_EXPOSURE: libc::c_uint = 13;
pub const XCB_NO_EXPOSURE: libc::c_uint = 14;
pub const XCB_VISIBILITY_NOTIFY: libc::c_uint = 15;
pub const XCB_CREATE_NOTIFY: libc::c_uint = 16;
pub const XCB_DESTROY_NOTIFY: libc::c_uint = 17;
pub const XCB_UNMAP_NOTIFY: libc::c_uint = 18;
pub const XCB_MAP_NOTIFY: libc::c_uint = 19;
pub const XCB_MAP_REQUEST: libc::c_uint = 20;
pub const XCB_REPARENT_NOTIFY: libc::c_uint = 21;
pub const XCB_CONFIGURE_NOTIFY: libc::c_uint = 22;
pub const XCB_CONFIGURE_REQUEST: libc::c_uint = 23;
pub const XCB_GRAVITY_NOTIFY: libc::c_uint = 24;
pub const XCB_RESIZE_REQUEST: libc::c_uint = 25;
pub const XCB_CIRCULATE_NOTIFY: libc::c_uint = 26;
pub const XCB_CIRCULATE_REQUEST: libc::c_uint = 27;
pub const XCB_PROPERTY_NOTIFY: libc::c_uint = 28;
pub const XCB_SELECTION_CLEAR: libc::c_uint = 29;
pub const XCB_SELECTION_REQUEST: libc::c_uint = 30;
pub const XCB_SELECTION_NOTIFY: libc::c_uint = 31;
pub const XCB_COLORMAP_NOTIFY: libc::c_uint = 32;
pub const XCB_CLIENT_MESSAGE: libc::c_uint = 33;
pub const XCB_MAPPING_NOTIFY: libc::c_uint = 34;
pub const XCB_GE_GENERIC: libc::c_uint = 35;
pub const XCB_REQUEST: libc::c_uint = 1;
pub const XCB_VALUE: libc::c_uint = 2;
pub const XCB_WINDOW: libc::c_uint = 3;
pub const XCB_PIXMAP: libc::c_uint = 4;
pub const XCB_ATOM: libc::c_uint = 5;
pub const XCB_CURSOR: libc::c_uint = 6;
pub const XCB_FONT: libc::c_uint = 7;
pub const XCB_MATCH: libc::c_uint = 8;
pub const XCB_DRAWABLE: libc::c_uint = 9;
pub const XCB_ACCESS: libc::c_uint = 10;
pub const XCB_ALLOC: libc::c_uint = 11;
pub const XCB_COLORMAP: libc::c_uint = 12;
pub const XCB_G_CONTEXT: libc::c_uint = 13;
pub const XCB_ID_CHOICE: libc::c_uint = 14;
pub const XCB_NAME: libc::c_uint = 15;
pub const XCB_LENGTH: libc::c_uint = 16;
pub const XCB_IMPLEMENTATION: libc::c_uint = 17;
pub const XCB_CREATE_WINDOW: libc::c_uint = 1;
pub const XCB_CHANGE_WINDOW_ATTRIBUTES: libc::c_uint = 2;
pub const XCB_GET_WINDOW_ATTRIBUTES: libc::c_uint = 3;
pub const XCB_DESTROY_WINDOW: libc::c_uint = 4;
pub const XCB_DESTROY_SUBWINDOWS: libc::c_uint = 5;
pub const XCB_CHANGE_SAVE_SET: libc::c_uint = 6;
pub const XCB_REPARENT_WINDOW: libc::c_uint = 7;
pub const XCB_MAP_WINDOW: libc::c_uint = 8;
pub const XCB_MAP_SUBWINDOWS: libc::c_uint = 9;
pub const XCB_UNMAP_WINDOW: libc::c_uint = 10;
pub const XCB_UNMAP_SUBWINDOWS: libc::c_uint = 11;
pub const XCB_CONFIGURE_WINDOW: libc::c_uint = 12;
pub const XCB_CIRCULATE_WINDOW: libc::c_uint = 13;
pub const XCB_GET_GEOMETRY: libc::c_uint = 14;
pub const XCB_QUERY_TREE: libc::c_uint = 15;
pub const XCB_INTERN_ATOM: libc::c_uint = 16;
pub const XCB_GET_ATOM_NAME: libc::c_uint = 17;
pub const XCB_CHANGE_PROPERTY: libc::c_uint = 18;
pub const XCB_DELETE_PROPERTY: libc::c_uint = 19;
pub const XCB_GET_PROPERTY: libc::c_uint = 20;
pub const XCB_LIST_PROPERTIES: libc::c_uint = 21;
pub const XCB_SET_SELECTION_OWNER: libc::c_uint = 22;
pub const XCB_GET_SELECTION_OWNER: libc::c_uint = 23;
pub const XCB_CONVERT_SELECTION: libc::c_uint = 24;
pub const XCB_SEND_EVENT: libc::c_uint = 25;
pub const XCB_GRAB_POINTER: libc::c_uint = 26;
pub const XCB_UNGRAB_POINTER: libc::c_uint = 27;
pub const XCB_GRAB_BUTTON: libc::c_uint = 28;
pub const XCB_UNGRAB_BUTTON: libc::c_uint = 29;
pub const XCB_CHANGE_ACTIVE_POINTER_GRAB: libc::c_uint = 30;
pub const XCB_GRAB_KEYBOARD: libc::c_uint = 31;
pub const XCB_UNGRAB_KEYBOARD: libc::c_uint = 32;
pub const XCB_GRAB_KEY: libc::c_uint = 33;
pub const XCB_UNGRAB_KEY: libc::c_uint = 34;
pub const XCB_ALLOW_EVENTS: libc::c_uint = 35;
pub const XCB_GRAB_SERVER: libc::c_uint = 36;
pub const XCB_UNGRAB_SERVER: libc::c_uint = 37;
pub const XCB_QUERY_POINTER: libc::c_uint = 38;
pub const XCB_GET_MOTION_EVENTS: libc::c_uint = 39;
pub const XCB_TRANSLATE_COORDINATES: libc::c_uint = 40;
pub const XCB_WARP_POINTER: libc::c_uint = 41;
pub const XCB_SET_INPUT_FOCUS: libc::c_uint = 42;
pub const XCB_GET_INPUT_FOCUS: libc::c_uint = 43;
pub const XCB_QUERY_KEYMAP: libc::c_uint = 44;
pub const XCB_OPEN_FONT: libc::c_uint = 45;
pub const XCB_CLOSE_FONT: libc::c_uint = 46;
pub const XCB_QUERY_FONT: libc::c_uint = 47;
pub const XCB_QUERY_TEXT_EXTENTS: libc::c_uint = 48;
pub const XCB_LIST_FONTS: libc::c_uint = 49;
pub const XCB_LIST_FONTS_WITH_INFO: libc::c_uint = 50;
pub const XCB_SET_FONT_PATH: libc::c_uint = 51;
pub const XCB_GET_FONT_PATH: libc::c_uint = 52;
pub const XCB_CREATE_PIXMAP: libc::c_uint = 53;
pub const XCB_FREE_PIXMAP: libc::c_uint = 54;
pub const XCB_CREATE_GC: libc::c_uint = 55;
pub const XCB_CHANGE_GC: libc::c_uint = 56;
pub const XCB_COPY_GC: libc::c_uint = 57;
pub const XCB_SET_DASHES: libc::c_uint = 58;
pub const XCB_SET_CLIP_RECTANGLES: libc::c_uint = 59;
pub const XCB_FREE_GC: libc::c_uint = 60;
pub const XCB_CLEAR_AREA: libc::c_uint = 61;
pub const XCB_COPY_AREA: libc::c_uint = 62;
pub const XCB_COPY_PLANE: libc::c_uint = 63;
pub const XCB_POLY_POINT: libc::c_uint = 64;
pub const XCB_POLY_LINE: libc::c_uint = 65;
pub const XCB_POLY_SEGMENT: libc::c_uint = 66;
pub const XCB_POLY_RECTANGLE: libc::c_uint = 67;
pub const XCB_POLY_ARC: libc::c_uint = 68;
pub const XCB_FILL_POLY: libc::c_uint = 69;
pub const XCB_POLY_FILL_RECTANGLE: libc::c_uint = 70;
pub const XCB_POLY_FILL_ARC: libc::c_uint = 71;
pub const XCB_PUT_IMAGE: libc::c_uint = 72;
pub const XCB_GET_IMAGE: libc::c_uint = 73;
pub const XCB_POLY_TEXT_8: libc::c_uint = 74;
pub const XCB_POLY_TEXT_16: libc::c_uint = 75;
pub const XCB_IMAGE_TEXT_8: libc::c_uint = 76;
pub const XCB_IMAGE_TEXT_16: libc::c_uint = 77;
pub const XCB_CREATE_COLORMAP: libc::c_uint = 78;
pub const XCB_FREE_COLORMAP: libc::c_uint = 79;
pub const XCB_COPY_COLORMAP_AND_FREE: libc::c_uint = 80;
pub const XCB_INSTALL_COLORMAP: libc::c_uint = 81;
pub const XCB_UNINSTALL_COLORMAP: libc::c_uint = 82;
pub const XCB_LIST_INSTALLED_COLORMAPS: libc::c_uint = 83;
pub const XCB_ALLOC_COLOR: libc::c_uint = 84;
pub const XCB_ALLOC_NAMED_COLOR: libc::c_uint = 85;
pub const XCB_ALLOC_COLOR_CELLS: libc::c_uint = 86;
pub const XCB_ALLOC_COLOR_PLANES: libc::c_uint = 87;
pub const XCB_FREE_COLORS: libc::c_uint = 88;
pub const XCB_STORE_COLORS: libc::c_uint = 89;
pub const XCB_STORE_NAMED_COLOR: libc::c_uint = 90;
pub const XCB_QUERY_COLORS: libc::c_uint = 91;
pub const XCB_LOOKUP_COLOR: libc::c_uint = 92;
pub const XCB_CREATE_CURSOR: libc::c_uint = 93;
pub const XCB_CREATE_GLYPH_CURSOR: libc::c_uint = 94;
pub const XCB_FREE_CURSOR: libc::c_uint = 95;
pub const XCB_RECOLOR_CURSOR: libc::c_uint = 96;
pub const XCB_QUERY_BEST_SIZE: libc::c_uint = 97;
pub const XCB_QUERY_EXTENSION: libc::c_uint = 98;
pub const XCB_LIST_EXTENSIONS: libc::c_uint = 99;
pub const XCB_CHANGE_KEYBOARD_MAPPING: libc::c_uint = 100;
pub const XCB_GET_KEYBOARD_MAPPING: libc::c_uint = 101;
pub const XCB_CHANGE_KEYBOARD_CONTROL: libc::c_uint = 102;
pub const XCB_GET_KEYBOARD_CONTROL: libc::c_uint = 103;
pub const XCB_BELL: libc::c_uint = 104;
pub const XCB_CHANGE_POINTER_CONTROL: libc::c_uint = 105;
pub const XCB_GET_POINTER_CONTROL: libc::c_uint = 106;
pub const XCB_SET_SCREEN_SAVER: libc::c_uint = 107;
pub const XCB_GET_SCREEN_SAVER: libc::c_uint = 108;
pub const XCB_CHANGE_HOSTS: libc::c_uint = 109;
pub const XCB_LIST_HOSTS: libc::c_uint = 110;
pub const XCB_SET_ACCESS_CONTROL: libc::c_uint = 111;
pub const XCB_SET_CLOSE_DOWN_MODE: libc::c_uint = 112;
pub const XCB_KILL_CLIENT: libc::c_uint = 113;
pub const XCB_ROTATE_PROPERTIES: libc::c_uint = 114;
pub const XCB_FORCE_SCREEN_SAVER: libc::c_uint = 115;
pub const XCB_SET_POINTER_MAPPING: libc::c_uint = 116;
pub const XCB_GET_POINTER_MAPPING: libc::c_uint = 117;
pub const XCB_SET_MODIFIER_MAPPING: libc::c_uint = 118;
pub const XCB_GET_MODIFIER_MAPPING: libc::c_uint = 119;
pub const XCB_NO_OPERATION: libc::c_uint = 127;
pub const XCB_NONE: libc::c_uint = 0;
pub const XCB_COPY_FROM_PARENT: libc::c_uint = 0;
pub const XCB_CURRENT_TIME: libc::c_uint = 0;
pub const XCB_NO_SYMBOL: libc::c_uint = 0;
pub const XCB_RENDER_MAJOR_VERSION: libc::c_uint = 0;
pub const XCB_RENDER_MINOR_VERSION: libc::c_uint = 11;
pub const XCB_RENDER_PICT_FORMAT: libc::c_uint = 0;
pub const XCB_RENDER_PICTURE: libc::c_uint = 1;
pub const XCB_RENDER_PICT_OP: libc::c_uint = 2;
pub const XCB_RENDER_GLYPH_SET: libc::c_uint = 3;
pub const XCB_RENDER_GLYPH: libc::c_uint = 4;
pub const XCB_RENDER_QUERY_VERSION: libc::c_uint = 0;
pub const XCB_RENDER_QUERY_PICT_FORMATS: libc::c_uint = 1;
pub const XCB_RENDER_QUERY_PICT_INDEX_VALUES: libc::c_uint = 2;
pub const XCB_RENDER_CREATE_PICTURE: libc::c_uint = 4;
pub const XCB_RENDER_CHANGE_PICTURE: libc::c_uint = 5;
pub const XCB_RENDER_SET_PICTURE_CLIP_RECTANGLES: libc::c_uint = 6;
pub const XCB_RENDER_FREE_PICTURE: libc::c_uint = 7;
pub const XCB_RENDER_COMPOSITE: libc::c_uint = 8;
pub const XCB_RENDER_TRAPEZOIDS: libc::c_uint = 10;
pub const XCB_RENDER_TRIANGLES: libc::c_uint = 11;
pub const XCB_RENDER_TRI_STRIP: libc::c_uint = 12;
pub const XCB_RENDER_TRI_FAN: libc::c_uint = 13;
pub const XCB_RENDER_CREATE_GLYPH_SET: libc::c_uint = 17;
pub const XCB_RENDER_REFERENCE_GLYPH_SET: libc::c_uint = 18;
pub const XCB_RENDER_FREE_GLYPH_SET: libc::c_uint = 19;
pub const XCB_RENDER_ADD_GLYPHS: libc::c_uint = 20;
pub const XCB_RENDER_FREE_GLYPHS: libc::c_uint = 22;
pub const XCB_RENDER_COMPOSITE_GLYPHS_8: libc::c_uint = 23;
pub const XCB_RENDER_COMPOSITE_GLYPHS_16: libc::c_uint = 24;
pub const XCB_RENDER_COMPOSITE_GLYPHS_32: libc::c_uint = 25;
pub const XCB_RENDER_FILL_RECTANGLES: libc::c_uint = 26;
pub const XCB_RENDER_CREATE_CURSOR: libc::c_uint = 27;
pub const XCB_RENDER_SET_PICTURE_TRANSFORM: libc::c_uint = 28;
pub const XCB_RENDER_QUERY_FILTERS: libc::c_uint = 29;
pub const XCB_RENDER_SET_PICTURE_FILTER: libc::c_uint = 30;
pub const XCB_RENDER_CREATE_ANIM_CURSOR: libc::c_uint = 31;
pub const XCB_RENDER_ADD_TRAPS: libc::c_uint = 32;
pub const XCB_RENDER_CREATE_SOLID_FILL: libc::c_uint = 33;
pub const XCB_RENDER_CREATE_LINEAR_GRADIENT: libc::c_uint = 34;
pub const XCB_RENDER_CREATE_RADIAL_GRADIENT: libc::c_uint = 35;
pub const XCB_RENDER_CREATE_CONICAL_GRADIENT: libc::c_uint = 36;
extern "C" {
    pub fn cairo_version() -> libc::c_int;
}
extern "C" {
    pub fn cairo_version_string() -> *const libc::c_char;
}
/**
 * cairo_bool_t:
 *
 * #cairo_bool_t is used for boolean values. Returns of type
 * #cairo_bool_t will always be either 0 or 1, but testing against
 * these values explicitly is not encouraged; just use the
 * value as a boolean condition.
 *
 * <informalexample><programlisting>
 *  if (cairo_in_stroke (cr, x, y)) {
 *      /<!-- -->* do something *<!-- -->/
 *  }
 * </programlisting></informalexample>
 *
 * Since: 1.0
 **/
pub type cairo_bool_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo([u8; 0]);
/**
 * cairo_t:
 *
 * A #cairo_t contains the current state of the rendering device,
 * including coordinates of yet to be drawn shapes.
 *
 * Cairo contexts, as #cairo_t objects are named, are central to
 * cairo and all drawing with cairo is always done to a #cairo_t
 * object.
 *
 * Memory management of #cairo_t is done with
 * cairo_reference() and cairo_destroy().
 *
 * Since: 1.0
 **/
pub type cairo_t = _cairo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_surface([u8; 0]);
/**
 * cairo_surface_t:
 *
 * A #cairo_surface_t represents an image, either as the destination
 * of a drawing operation or as source when drawing onto another
 * surface.  To draw to a #cairo_surface_t, create a cairo context
 * with the surface as the target, using cairo_create().
 *
 * There are different subtypes of #cairo_surface_t for
 * different drawing backends; for example, cairo_image_surface_create()
 * creates a bitmap image in memory.
 * The type of a surface can be queried with cairo_surface_get_type().
 *
 * The initial contents of a surface after creation depend upon the manner
 * of its creation. If cairo creates the surface and backing storage for
 * the user, it will be initially cleared; for example,
 * cairo_image_surface_create() and cairo_surface_create_similar().
 * Alternatively, if the user passes in a reference to some backing storage
 * and asks cairo to wrap that in a #cairo_surface_t, then the contents are
 * not modified; for example, cairo_image_surface_create_for_data() and
 * cairo_xlib_surface_create().
 *
 * Memory management of #cairo_surface_t is done with
 * cairo_surface_reference() and cairo_surface_destroy().
 *
 * Since: 1.0
 **/
pub type cairo_surface_t = _cairo_surface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_device([u8; 0]);
/**
 * cairo_device_t:
 *
 * A #cairo_device_t represents the driver interface for drawing
 * operations to a #cairo_surface_t.  There are different subtypes of
 * #cairo_device_t for different drawing backends; for example,
 * cairo_egl_device_create() creates a device that wraps an EGL display and
 * context.
 *
 * The type of a device can be queried with cairo_device_get_type().
 *
 * Memory management of #cairo_device_t is done with
 * cairo_device_reference() and cairo_device_destroy().
 *
 * Since: 1.10
 **/
pub type cairo_device_t = _cairo_device;
/**
 * cairo_matrix_t:
 * @xx: xx component of the affine transformation
 * @yx: yx component of the affine transformation
 * @xy: xy component of the affine transformation
 * @yy: yy component of the affine transformation
 * @x0: X translation component of the affine transformation
 * @y0: Y translation component of the affine transformation
 *
 * A #cairo_matrix_t holds an affine transformation, such as a scale,
 * rotation, shear, or a combination of those. The transformation of
 * a point (x, y) is given by:
 * <programlisting>
 *     x_new = xx * x + xy * y + x0;
 *     y_new = yx * x + yy * y + y0;
 * </programlisting>
 *
 * Since: 1.0
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cairo_matrix {
    pub xx: f64,
    pub yx: f64,
    pub xy: f64,
    pub yy: f64,
    pub x0: f64,
    pub y0: f64,
}
#[test]
fn bindgen_test_layout__cairo_matrix() {
    assert_eq!(::std::mem::size_of::<_cairo_matrix>() , 48usize);
    assert_eq!(::std::mem::align_of::<_cairo_matrix>() , 8usize);
}
impl Clone for _cairo_matrix {
    fn clone(&self) -> Self { *self }
}
pub type cairo_matrix_t = _cairo_matrix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_pattern([u8; 0]);
/**
 * cairo_pattern_t:
 *
 * A #cairo_pattern_t represents a source when drawing onto a
 * surface. There are different subtypes of #cairo_pattern_t,
 * for different types of sources; for example,
 * cairo_pattern_create_rgb() creates a pattern for a solid
 * opaque color.
 *
 * Other than various
 * <function>cairo_pattern_create_<emphasis>type</emphasis>()</function>
 * functions, some of the pattern types can be implicitly created using various
 * <function>cairo_set_source_<emphasis>type</emphasis>()</function> functions;
 * for example cairo_set_source_rgb().
 *
 * The type of a pattern can be queried with cairo_pattern_get_type().
 *
 * Memory management of #cairo_pattern_t is done with
 * cairo_pattern_reference() and cairo_pattern_destroy().
 *
 * Since: 1.0
 **/
pub type cairo_pattern_t = _cairo_pattern;
/**
 * cairo_destroy_func_t:
 * @data: The data element being destroyed.
 *
 * #cairo_destroy_func_t the type of function which is called when a
 * data element is destroyed. It is passed the pointer to the data
 * element and should free any memory and resources allocated for it.
 *
 * Since: 1.0
 **/
pub type cairo_destroy_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut libc::c_void)>;
/**
 * cairo_user_data_key_t:
 * @unused: not used; ignore.
 *
 * #cairo_user_data_key_t is used for attaching user data to cairo
 * data structures.  The actual contents of the struct is never used,
 * and there is no need to initialize the object; only the unique
 * address of a #cairo_data_key_t object is used.  Typically, you
 * would just use the address of a static #cairo_data_key_t object.
 *
 * Since: 1.0
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cairo_user_data_key {
    pub unused: libc::c_int,
}
#[test]
fn bindgen_test_layout__cairo_user_data_key() {
    assert_eq!(::std::mem::size_of::<_cairo_user_data_key>() , 4usize);
    assert_eq!(::std::mem::align_of::<_cairo_user_data_key>() , 4usize);
}
impl Clone for _cairo_user_data_key {
    fn clone(&self) -> Self { *self }
}
pub type cairo_user_data_key_t = _cairo_user_data_key;
#[repr(u32)]
/**
 * cairo_status_t:
 * @CAIRO_STATUS_SUCCESS: no error has occurred (Since 1.0)
 * @CAIRO_STATUS_NO_MEMORY: out of memory (Since 1.0)
 * @CAIRO_STATUS_INVALID_RESTORE: cairo_restore() called without matching cairo_save() (Since 1.0)
 * @CAIRO_STATUS_INVALID_POP_GROUP: no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group() (Since 1.0)
 * @CAIRO_STATUS_NO_CURRENT_POINT: no current point defined (Since 1.0)
 * @CAIRO_STATUS_INVALID_MATRIX: invalid matrix (not invertible) (Since 1.0)
 * @CAIRO_STATUS_INVALID_STATUS: invalid value for an input #cairo_status_t (Since 1.0)
 * @CAIRO_STATUS_NULL_POINTER: %NULL pointer (Since 1.0)
 * @CAIRO_STATUS_INVALID_STRING: input string not valid UTF-8 (Since 1.0)
 * @CAIRO_STATUS_INVALID_PATH_DATA: input path data not valid (Since 1.0)
 * @CAIRO_STATUS_READ_ERROR: error while reading from input stream (Since 1.0)
 * @CAIRO_STATUS_WRITE_ERROR: error while writing to output stream (Since 1.0)
 * @CAIRO_STATUS_SURFACE_FINISHED: target surface has been finished (Since 1.0)
 * @CAIRO_STATUS_SURFACE_TYPE_MISMATCH: the surface type is not appropriate for the operation (Since 1.0)
 * @CAIRO_STATUS_PATTERN_TYPE_MISMATCH: the pattern type is not appropriate for the operation (Since 1.0)
 * @CAIRO_STATUS_INVALID_CONTENT: invalid value for an input #cairo_content_t (Since 1.0)
 * @CAIRO_STATUS_INVALID_FORMAT: invalid value for an input #cairo_format_t (Since 1.0)
 * @CAIRO_STATUS_INVALID_VISUAL: invalid value for an input Visual* (Since 1.0)
 * @CAIRO_STATUS_FILE_NOT_FOUND: file not found (Since 1.0)
 * @CAIRO_STATUS_INVALID_DASH: invalid value for a dash setting (Since 1.0)
 * @CAIRO_STATUS_INVALID_DSC_COMMENT: invalid value for a DSC comment (Since 1.2)
 * @CAIRO_STATUS_INVALID_INDEX: invalid index passed to getter (Since 1.4)
 * @CAIRO_STATUS_CLIP_NOT_REPRESENTABLE: clip region not representable in desired format (Since 1.4)
 * @CAIRO_STATUS_TEMP_FILE_ERROR: error creating or writing to a temporary file (Since 1.6)
 * @CAIRO_STATUS_INVALID_STRIDE: invalid value for stride (Since 1.6)
 * @CAIRO_STATUS_FONT_TYPE_MISMATCH: the font type is not appropriate for the operation (Since 1.8)
 * @CAIRO_STATUS_USER_FONT_IMMUTABLE: the user-font is immutable (Since 1.8)
 * @CAIRO_STATUS_USER_FONT_ERROR: error occurred in a user-font callback function (Since 1.8)
 * @CAIRO_STATUS_NEGATIVE_COUNT: negative number used where it is not allowed (Since 1.8)
 * @CAIRO_STATUS_INVALID_CLUSTERS: input clusters do not represent the accompanying text and glyph array (Since 1.8)
 * @CAIRO_STATUS_INVALID_SLANT: invalid value for an input #cairo_font_slant_t (Since 1.8)
 * @CAIRO_STATUS_INVALID_WEIGHT: invalid value for an input #cairo_font_weight_t (Since 1.8)
 * @CAIRO_STATUS_INVALID_SIZE: invalid value (typically too big) for the size of the input (surface, pattern, etc.) (Since 1.10)
 * @CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED: user-font method not implemented (Since 1.10)
 * @CAIRO_STATUS_DEVICE_TYPE_MISMATCH: the device type is not appropriate for the operation (Since 1.10)
 * @CAIRO_STATUS_DEVICE_ERROR: an operation to the device caused an unspecified error (Since 1.10)
 * @CAIRO_STATUS_INVALID_MESH_CONSTRUCTION: a mesh pattern
 *   construction operation was used outside of a
 *   cairo_mesh_pattern_begin_patch()/cairo_mesh_pattern_end_patch()
 *   pair (Since 1.12)
 * @CAIRO_STATUS_DEVICE_FINISHED: target device has been finished (Since 1.12)
 * @CAIRO_STATUS_JBIG2_GLOBAL_MISSING: %CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID has been used on at least one image
 *   but no image provided %CAIRO_MIME_TYPE_JBIG2_GLOBAL (Since 1.14)
 * @CAIRO_STATUS_LAST_STATUS: this is a special value indicating the number of
 *   status values defined in this enumeration.  When using this value, note
 *   that the version of cairo at run-time may have additional status values
 *   defined than the value of this symbol at compile-time. (Since 1.10)
 *
 * #cairo_status_t is used to indicate errors that can occur when
 * using Cairo. In some cases it is returned directly by functions.
 * but when using #cairo_t, the last error, if any, is stored in
 * the context and can be retrieved with cairo_status().
 *
 * New entries may be added in future versions.  Use cairo_status_to_string()
 * to get a human-readable representation of an error message.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_status {
    CAIRO_STATUS_SUCCESS = 0,
    CAIRO_STATUS_NO_MEMORY = 1,
    CAIRO_STATUS_INVALID_RESTORE = 2,
    CAIRO_STATUS_INVALID_POP_GROUP = 3,
    CAIRO_STATUS_NO_CURRENT_POINT = 4,
    CAIRO_STATUS_INVALID_MATRIX = 5,
    CAIRO_STATUS_INVALID_STATUS = 6,
    CAIRO_STATUS_NULL_POINTER = 7,
    CAIRO_STATUS_INVALID_STRING = 8,
    CAIRO_STATUS_INVALID_PATH_DATA = 9,
    CAIRO_STATUS_READ_ERROR = 10,
    CAIRO_STATUS_WRITE_ERROR = 11,
    CAIRO_STATUS_SURFACE_FINISHED = 12,
    CAIRO_STATUS_SURFACE_TYPE_MISMATCH = 13,
    CAIRO_STATUS_PATTERN_TYPE_MISMATCH = 14,
    CAIRO_STATUS_INVALID_CONTENT = 15,
    CAIRO_STATUS_INVALID_FORMAT = 16,
    CAIRO_STATUS_INVALID_VISUAL = 17,
    CAIRO_STATUS_FILE_NOT_FOUND = 18,
    CAIRO_STATUS_INVALID_DASH = 19,
    CAIRO_STATUS_INVALID_DSC_COMMENT = 20,
    CAIRO_STATUS_INVALID_INDEX = 21,
    CAIRO_STATUS_CLIP_NOT_REPRESENTABLE = 22,
    CAIRO_STATUS_TEMP_FILE_ERROR = 23,
    CAIRO_STATUS_INVALID_STRIDE = 24,
    CAIRO_STATUS_FONT_TYPE_MISMATCH = 25,
    CAIRO_STATUS_USER_FONT_IMMUTABLE = 26,
    CAIRO_STATUS_USER_FONT_ERROR = 27,
    CAIRO_STATUS_NEGATIVE_COUNT = 28,
    CAIRO_STATUS_INVALID_CLUSTERS = 29,
    CAIRO_STATUS_INVALID_SLANT = 30,
    CAIRO_STATUS_INVALID_WEIGHT = 31,
    CAIRO_STATUS_INVALID_SIZE = 32,
    CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED = 33,
    CAIRO_STATUS_DEVICE_TYPE_MISMATCH = 34,
    CAIRO_STATUS_DEVICE_ERROR = 35,
    CAIRO_STATUS_INVALID_MESH_CONSTRUCTION = 36,
    CAIRO_STATUS_DEVICE_FINISHED = 37,
    CAIRO_STATUS_JBIG2_GLOBAL_MISSING = 38,
    CAIRO_STATUS_LAST_STATUS = 39,
}
pub use self::_cairo_status as cairo_status_t;
#[repr(u32)]
/**
 * cairo_content_t:
 * @CAIRO_CONTENT_COLOR: The surface will hold color content only. (Since 1.0)
 * @CAIRO_CONTENT_ALPHA: The surface will hold alpha content only. (Since 1.0)
 * @CAIRO_CONTENT_COLOR_ALPHA: The surface will hold color and alpha content. (Since 1.0)
 *
 * #cairo_content_t is used to describe the content that a surface will
 * contain, whether color information, alpha information (translucence
 * vs. opacity), or both.
 *
 * Note: The large values here are designed to keep #cairo_content_t
 * values distinct from #cairo_format_t values so that the
 * implementation can detect the error if users confuse the two types.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_content {
    CAIRO_CONTENT_COLOR = 4096,
    CAIRO_CONTENT_ALPHA = 8192,
    CAIRO_CONTENT_COLOR_ALPHA = 12288,
}
pub use self::_cairo_content as cairo_content_t;
#[repr(i32)]
/**
 * cairo_format_t:
 * @CAIRO_FORMAT_INVALID: no such format exists or is supported.
 * @CAIRO_FORMAT_ARGB32: each pixel is a 32-bit quantity, with
 *   alpha in the upper 8 bits, then red, then green, then blue.
 *   The 32-bit quantities are stored native-endian. Pre-multiplied
 *   alpha is used. (That is, 50% transparent red is 0x80800000,
 *   not 0x80ff0000.) (Since 1.0)
 * @CAIRO_FORMAT_RGB24: each pixel is a 32-bit quantity, with
 *   the upper 8 bits unused. Red, Green, and Blue are stored
 *   in the remaining 24 bits in that order. (Since 1.0)
 * @CAIRO_FORMAT_A8: each pixel is a 8-bit quantity holding
 *   an alpha value. (Since 1.0)
 * @CAIRO_FORMAT_A1: each pixel is a 1-bit quantity holding
 *   an alpha value. Pixels are packed together into 32-bit
 *   quantities. The ordering of the bits matches the
 *   endianess of the platform. On a big-endian machine, the
 *   first pixel is in the uppermost bit, on a little-endian
 *   machine the first pixel is in the least-significant bit. (Since 1.0)
 * @CAIRO_FORMAT_RGB16_565: each pixel is a 16-bit quantity
 *   with red in the upper 5 bits, then green in the middle
 *   6 bits, and blue in the lower 5 bits. (Since 1.2)
 * @CAIRO_FORMAT_RGB30: like RGB24 but with 10bpc. (Since 1.12)
 *
 * #cairo_format_t is used to identify the memory format of
 * image data.
 *
 * New entries may be added in future versions.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_format {
    CAIRO_FORMAT_INVALID = -1,
    CAIRO_FORMAT_ARGB32 = 0,
    CAIRO_FORMAT_RGB24 = 1,
    CAIRO_FORMAT_A8 = 2,
    CAIRO_FORMAT_A1 = 3,
    CAIRO_FORMAT_RGB16_565 = 4,
    CAIRO_FORMAT_RGB30 = 5,
}
pub use self::_cairo_format as cairo_format_t;
/**
 * cairo_write_func_t:
 * @closure: the output closure
 * @data: the buffer containing the data to write
 * @length: the amount of data to write
 *
 * #cairo_write_func_t is the type of function which is called when a
 * backend needs to write data to an output stream.  It is passed the
 * closure which was specified by the user at the time the write
 * function was registered, the data to write and the length of the
 * data in bytes.  The write function should return
 * %CAIRO_STATUS_SUCCESS if all the data was successfully written,
 * %CAIRO_STATUS_WRITE_ERROR otherwise.
 *
 * Returns: the status code of the write operation
 *
 * Since: 1.0
 **/
pub type cairo_write_func_t =
    ::std::option::Option<unsafe extern "C" fn(closure: *mut libc::c_void,
                                               data: *const libc::c_uchar,
                                               length: libc::c_uint)
                              -> _cairo_status>;
/**
 * cairo_read_func_t:
 * @closure: the input closure
 * @data: the buffer into which to read the data
 * @length: the amount of data to read
 *
 * #cairo_read_func_t is the type of function which is called when a
 * backend needs to read data from an input stream.  It is passed the
 * closure which was specified by the user at the time the read
 * function was registered, the buffer to read the data into and the
 * length of the data in bytes.  The read function should return
 * %CAIRO_STATUS_SUCCESS if all the data was successfully read,
 * %CAIRO_STATUS_READ_ERROR otherwise.
 *
 * Returns: the status code of the read operation
 *
 * Since: 1.0
 **/
pub type cairo_read_func_t =
    ::std::option::Option<unsafe extern "C" fn(closure: *mut libc::c_void,
                                               data: *mut libc::c_uchar,
                                               length: libc::c_uint)
                              -> _cairo_status>;
/**
 * cairo_rectangle_int_t:
 * @x: X coordinate of the left side of the rectangle
 * @y: Y coordinate of the the top side of the rectangle
 * @width: width of the rectangle
 * @height: height of the rectangle
 *
 * A data structure for holding a rectangle with integer coordinates.
 *
 * Since: 1.10
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cairo_rectangle_int {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
}
#[test]
fn bindgen_test_layout__cairo_rectangle_int() {
    assert_eq!(::std::mem::size_of::<_cairo_rectangle_int>() , 16usize);
    assert_eq!(::std::mem::align_of::<_cairo_rectangle_int>() , 4usize);
}
impl Clone for _cairo_rectangle_int {
    fn clone(&self) -> Self { *self }
}
pub type cairo_rectangle_int_t = _cairo_rectangle_int;
extern "C" {
    pub fn cairo_create(target: *mut cairo_surface_t) -> *mut cairo_t;
}
extern "C" {
    pub fn cairo_reference(cr: *mut cairo_t) -> *mut cairo_t;
}
extern "C" {
    pub fn cairo_destroy(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_get_reference_count(cr: *mut cairo_t) -> libc::c_uint;
}
extern "C" {
    pub fn cairo_get_user_data(cr: *mut cairo_t,
                               key: *const cairo_user_data_key_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn cairo_set_user_data(cr: *mut cairo_t,
                               key: *const cairo_user_data_key_t,
                               user_data: *mut libc::c_void,
                               destroy: cairo_destroy_func_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_save(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_restore(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_push_group(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_push_group_with_content(cr: *mut cairo_t,
                                         content: cairo_content_t);
}
extern "C" {
    pub fn cairo_pop_group(cr: *mut cairo_t) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pop_group_to_source(cr: *mut cairo_t);
}
#[repr(u32)]
/**
 * cairo_operator_t:
 * @CAIRO_OPERATOR_CLEAR: clear destination layer (bounded) (Since 1.0)
 * @CAIRO_OPERATOR_SOURCE: replace destination layer (bounded) (Since 1.0)
 * @CAIRO_OPERATOR_OVER: draw source layer on top of destination layer
 * (bounded) (Since 1.0)
 * @CAIRO_OPERATOR_IN: draw source where there was destination content
 * (unbounded) (Since 1.0)
 * @CAIRO_OPERATOR_OUT: draw source where there was no destination
 * content (unbounded) (Since 1.0)
 * @CAIRO_OPERATOR_ATOP: draw source on top of destination content and
 * only there (Since 1.0)
 * @CAIRO_OPERATOR_DEST: ignore the source (Since 1.0)
 * @CAIRO_OPERATOR_DEST_OVER: draw destination on top of source (Since 1.0)
 * @CAIRO_OPERATOR_DEST_IN: leave destination only where there was
 * source content (unbounded) (Since 1.0)
 * @CAIRO_OPERATOR_DEST_OUT: leave destination only where there was no
 * source content (Since 1.0)
 * @CAIRO_OPERATOR_DEST_ATOP: leave destination on top of source content
 * and only there (unbounded) (Since 1.0)
 * @CAIRO_OPERATOR_XOR: source and destination are shown where there is only
 * one of them (Since 1.0)
 * @CAIRO_OPERATOR_ADD: source and destination layers are accumulated (Since 1.0)
 * @CAIRO_OPERATOR_SATURATE: like over, but assuming source and dest are
 * disjoint geometries (Since 1.0)
 * @CAIRO_OPERATOR_MULTIPLY: source and destination layers are multiplied.
 * This causes the result to be at least as dark as the darker inputs. (Since 1.10)
 * @CAIRO_OPERATOR_SCREEN: source and destination are complemented and
 * multiplied. This causes the result to be at least as light as the lighter
 * inputs. (Since 1.10)
 * @CAIRO_OPERATOR_OVERLAY: multiplies or screens, depending on the
 * lightness of the destination color. (Since 1.10)
 * @CAIRO_OPERATOR_DARKEN: replaces the destination with the source if it
 * is darker, otherwise keeps the source. (Since 1.10)
 * @CAIRO_OPERATOR_LIGHTEN: replaces the destination with the source if it
 * is lighter, otherwise keeps the source. (Since 1.10)
 * @CAIRO_OPERATOR_COLOR_DODGE: brightens the destination color to reflect
 * the source color. (Since 1.10)
 * @CAIRO_OPERATOR_COLOR_BURN: darkens the destination color to reflect
 * the source color. (Since 1.10)
 * @CAIRO_OPERATOR_HARD_LIGHT: Multiplies or screens, dependent on source
 * color. (Since 1.10)
 * @CAIRO_OPERATOR_SOFT_LIGHT: Darkens or lightens, dependent on source
 * color. (Since 1.10)
 * @CAIRO_OPERATOR_DIFFERENCE: Takes the difference of the source and
 * destination color. (Since 1.10)
 * @CAIRO_OPERATOR_EXCLUSION: Produces an effect similar to difference, but
 * with lower contrast. (Since 1.10)
 * @CAIRO_OPERATOR_HSL_HUE: Creates a color with the hue of the source
 * and the saturation and luminosity of the target. (Since 1.10)
 * @CAIRO_OPERATOR_HSL_SATURATION: Creates a color with the saturation
 * of the source and the hue and luminosity of the target. Painting with
 * this mode onto a gray area produces no change. (Since 1.10)
 * @CAIRO_OPERATOR_HSL_COLOR: Creates a color with the hue and saturation
 * of the source and the luminosity of the target. This preserves the gray
 * levels of the target and is useful for coloring monochrome images or
 * tinting color images. (Since 1.10)
 * @CAIRO_OPERATOR_HSL_LUMINOSITY: Creates a color with the luminosity of
 * the source and the hue and saturation of the target. This produces an
 * inverse effect to @CAIRO_OPERATOR_HSL_COLOR. (Since 1.10)
 *
 * #cairo_operator_t is used to set the compositing operator for all cairo
 * drawing operations.
 *
 * The default operator is %CAIRO_OPERATOR_OVER.
 *
 * The operators marked as <firstterm>unbounded</firstterm> modify their
 * destination even outside of the mask layer (that is, their effect is not
 * bound by the mask layer).  However, their effect can still be limited by
 * way of clipping.
 *
 * To keep things simple, the operator descriptions here
 * document the behavior for when both source and destination are either fully
 * transparent or fully opaque.  The actual implementation works for
 * translucent layers too.
 * For a more detailed explanation of the effects of each operator, including
 * the mathematical definitions, see
 * <ulink url="http://cairographics.org/operators/">http://cairographics.org/operators/</ulink>.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_operator {
    CAIRO_OPERATOR_CLEAR = 0,
    CAIRO_OPERATOR_SOURCE = 1,
    CAIRO_OPERATOR_OVER = 2,
    CAIRO_OPERATOR_IN = 3,
    CAIRO_OPERATOR_OUT = 4,
    CAIRO_OPERATOR_ATOP = 5,
    CAIRO_OPERATOR_DEST = 6,
    CAIRO_OPERATOR_DEST_OVER = 7,
    CAIRO_OPERATOR_DEST_IN = 8,
    CAIRO_OPERATOR_DEST_OUT = 9,
    CAIRO_OPERATOR_DEST_ATOP = 10,
    CAIRO_OPERATOR_XOR = 11,
    CAIRO_OPERATOR_ADD = 12,
    CAIRO_OPERATOR_SATURATE = 13,
    CAIRO_OPERATOR_MULTIPLY = 14,
    CAIRO_OPERATOR_SCREEN = 15,
    CAIRO_OPERATOR_OVERLAY = 16,
    CAIRO_OPERATOR_DARKEN = 17,
    CAIRO_OPERATOR_LIGHTEN = 18,
    CAIRO_OPERATOR_COLOR_DODGE = 19,
    CAIRO_OPERATOR_COLOR_BURN = 20,
    CAIRO_OPERATOR_HARD_LIGHT = 21,
    CAIRO_OPERATOR_SOFT_LIGHT = 22,
    CAIRO_OPERATOR_DIFFERENCE = 23,
    CAIRO_OPERATOR_EXCLUSION = 24,
    CAIRO_OPERATOR_HSL_HUE = 25,
    CAIRO_OPERATOR_HSL_SATURATION = 26,
    CAIRO_OPERATOR_HSL_COLOR = 27,
    CAIRO_OPERATOR_HSL_LUMINOSITY = 28,
}
pub use self::_cairo_operator as cairo_operator_t;
extern "C" {
    pub fn cairo_set_operator(cr: *mut cairo_t, op: cairo_operator_t);
}
extern "C" {
    pub fn cairo_set_source(cr: *mut cairo_t, source: *mut cairo_pattern_t);
}
extern "C" {
    pub fn cairo_set_source_rgb(cr: *mut cairo_t, red: f64, green: f64,
                                blue: f64);
}
extern "C" {
    pub fn cairo_set_source_rgba(cr: *mut cairo_t, red: f64, green: f64,
                                 blue: f64, alpha: f64);
}
extern "C" {
    pub fn cairo_set_source_surface(cr: *mut cairo_t,
                                    surface: *mut cairo_surface_t, x: f64,
                                    y: f64);
}
extern "C" {
    pub fn cairo_set_tolerance(cr: *mut cairo_t, tolerance: f64);
}
#[repr(u32)]
/**
 * cairo_antialias_t:
 * @CAIRO_ANTIALIAS_DEFAULT: Use the default antialiasing for
 *   the subsystem and target device, since 1.0
 * @CAIRO_ANTIALIAS_NONE: Use a bilevel alpha mask, since 1.0
 * @CAIRO_ANTIALIAS_GRAY: Perform single-color antialiasing (using
 *  shades of gray for black text on a white background, for example), since 1.0
 * @CAIRO_ANTIALIAS_SUBPIXEL: Perform antialiasing by taking
 *  advantage of the order of subpixel elements on devices
 *  such as LCD panels, since 1.0
 * @CAIRO_ANTIALIAS_FAST: Hint that the backend should perform some
 * antialiasing but prefer speed over quality, since 1.12
 * @CAIRO_ANTIALIAS_GOOD: The backend should balance quality against
 * performance, since 1.12
 * @CAIRO_ANTIALIAS_BEST: Hint that the backend should render at the highest
 * quality, sacrificing speed if necessary, since 1.12
 *
 * Specifies the type of antialiasing to do when rendering text or shapes.
 *
 * As it is not necessarily clear from the above what advantages a particular
 * antialias method provides, since 1.12, there is also a set of hints:
 * @CAIRO_ANTIALIAS_FAST: Allow the backend to degrade raster quality for speed
 * @CAIRO_ANTIALIAS_GOOD: A balance between speed and quality
 * @CAIRO_ANTIALIAS_BEST: A high-fidelity, but potentially slow, raster mode
 *
 * These make no guarantee on how the backend will perform its rasterisation
 * (if it even rasterises!), nor that they have any differing effect other
 * than to enable some form of antialiasing. In the case of glyph rendering,
 * @CAIRO_ANTIALIAS_FAST and @CAIRO_ANTIALIAS_GOOD will be mapped to
 * @CAIRO_ANTIALIAS_GRAY, with @CAIRO_ANTALIAS_BEST being equivalent to
 * @CAIRO_ANTIALIAS_SUBPIXEL.
 *
 * The interpretation of @CAIRO_ANTIALIAS_DEFAULT is left entirely up to
 * the backend, typically this will be similar to @CAIRO_ANTIALIAS_GOOD.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_antialias {
    CAIRO_ANTIALIAS_DEFAULT = 0,
    CAIRO_ANTIALIAS_NONE = 1,
    CAIRO_ANTIALIAS_GRAY = 2,
    CAIRO_ANTIALIAS_SUBPIXEL = 3,
    CAIRO_ANTIALIAS_FAST = 4,
    CAIRO_ANTIALIAS_GOOD = 5,
    CAIRO_ANTIALIAS_BEST = 6,
}
pub use self::_cairo_antialias as cairo_antialias_t;
extern "C" {
    pub fn cairo_set_antialias(cr: *mut cairo_t,
                               antialias: cairo_antialias_t);
}
#[repr(u32)]
/**
 * cairo_fill_rule_t:
 * @CAIRO_FILL_RULE_WINDING: If the path crosses the ray from
 * left-to-right, counts +1. If the path crosses the ray
 * from right to left, counts -1. (Left and right are determined
 * from the perspective of looking along the ray from the starting
 * point.) If the total count is non-zero, the point will be filled. (Since 1.0)
 * @CAIRO_FILL_RULE_EVEN_ODD: Counts the total number of
 * intersections, without regard to the orientation of the contour. If
 * the total number of intersections is odd, the point will be
 * filled. (Since 1.0)
 *
 * #cairo_fill_rule_t is used to select how paths are filled. For both
 * fill rules, whether or not a point is included in the fill is
 * determined by taking a ray from that point to infinity and looking
 * at intersections with the path. The ray can be in any direction,
 * as long as it doesn't pass through the end point of a segment
 * or have a tricky intersection such as intersecting tangent to the path.
 * (Note that filling is not actually implemented in this way. This
 * is just a description of the rule that is applied.)
 *
 * The default fill rule is %CAIRO_FILL_RULE_WINDING.
 *
 * New entries may be added in future versions.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_fill_rule {
    CAIRO_FILL_RULE_WINDING = 0,
    CAIRO_FILL_RULE_EVEN_ODD = 1,
}
pub use self::_cairo_fill_rule as cairo_fill_rule_t;
extern "C" {
    pub fn cairo_set_fill_rule(cr: *mut cairo_t,
                               fill_rule: cairo_fill_rule_t);
}
extern "C" {
    pub fn cairo_set_line_width(cr: *mut cairo_t, width: f64);
}
#[repr(u32)]
/**
 * cairo_line_cap_t:
 * @CAIRO_LINE_CAP_BUTT: start(stop) the line exactly at the start(end) point (Since 1.0)
 * @CAIRO_LINE_CAP_ROUND: use a round ending, the center of the circle is the end point (Since 1.0)
 * @CAIRO_LINE_CAP_SQUARE: use squared ending, the center of the square is the end point (Since 1.0)
 *
 * Specifies how to render the endpoints of the path when stroking.
 *
 * The default line cap style is %CAIRO_LINE_CAP_BUTT.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_line_cap {
    CAIRO_LINE_CAP_BUTT = 0,
    CAIRO_LINE_CAP_ROUND = 1,
    CAIRO_LINE_CAP_SQUARE = 2,
}
pub use self::_cairo_line_cap as cairo_line_cap_t;
extern "C" {
    pub fn cairo_set_line_cap(cr: *mut cairo_t, line_cap: cairo_line_cap_t);
}
#[repr(u32)]
/**
 * cairo_line_join_t:
 * @CAIRO_LINE_JOIN_MITER: use a sharp (angled) corner, see
 * cairo_set_miter_limit() (Since 1.0)
 * @CAIRO_LINE_JOIN_ROUND: use a rounded join, the center of the circle is the
 * joint point (Since 1.0)
 * @CAIRO_LINE_JOIN_BEVEL: use a cut-off join, the join is cut off at half
 * the line width from the joint point (Since 1.0)
 *
 * Specifies how to render the junction of two lines when stroking.
 *
 * The default line join style is %CAIRO_LINE_JOIN_MITER.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_line_join {
    CAIRO_LINE_JOIN_MITER = 0,
    CAIRO_LINE_JOIN_ROUND = 1,
    CAIRO_LINE_JOIN_BEVEL = 2,
}
pub use self::_cairo_line_join as cairo_line_join_t;
extern "C" {
    pub fn cairo_set_line_join(cr: *mut cairo_t,
                               line_join: cairo_line_join_t);
}
extern "C" {
    pub fn cairo_set_dash(cr: *mut cairo_t, dashes: *const f64,
                          num_dashes: libc::c_int, offset: f64);
}
extern "C" {
    pub fn cairo_set_miter_limit(cr: *mut cairo_t, limit: f64);
}
extern "C" {
    pub fn cairo_translate(cr: *mut cairo_t, tx: f64, ty: f64);
}
extern "C" {
    pub fn cairo_scale(cr: *mut cairo_t, sx: f64, sy: f64);
}
extern "C" {
    pub fn cairo_rotate(cr: *mut cairo_t, angle: f64);
}
extern "C" {
    pub fn cairo_transform(cr: *mut cairo_t, matrix: *const cairo_matrix_t);
}
extern "C" {
    pub fn cairo_set_matrix(cr: *mut cairo_t, matrix: *const cairo_matrix_t);
}
extern "C" {
    pub fn cairo_identity_matrix(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_user_to_device(cr: *mut cairo_t, x: *mut f64, y: *mut f64);
}
extern "C" {
    pub fn cairo_user_to_device_distance(cr: *mut cairo_t, dx: *mut f64,
                                         dy: *mut f64);
}
extern "C" {
    pub fn cairo_device_to_user(cr: *mut cairo_t, x: *mut f64, y: *mut f64);
}
extern "C" {
    pub fn cairo_device_to_user_distance(cr: *mut cairo_t, dx: *mut f64,
                                         dy: *mut f64);
}
extern "C" {
    pub fn cairo_new_path(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_move_to(cr: *mut cairo_t, x: f64, y: f64);
}
extern "C" {
    pub fn cairo_new_sub_path(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_line_to(cr: *mut cairo_t, x: f64, y: f64);
}
extern "C" {
    pub fn cairo_curve_to(cr: *mut cairo_t, x1: f64, y1: f64, x2: f64,
                          y2: f64, x3: f64, y3: f64);
}
extern "C" {
    pub fn cairo_arc(cr: *mut cairo_t, xc: f64, yc: f64, radius: f64,
                     angle1: f64, angle2: f64);
}
extern "C" {
    pub fn cairo_arc_negative(cr: *mut cairo_t, xc: f64, yc: f64, radius: f64,
                              angle1: f64, angle2: f64);
}
extern "C" {
    pub fn cairo_rel_move_to(cr: *mut cairo_t, dx: f64, dy: f64);
}
extern "C" {
    pub fn cairo_rel_line_to(cr: *mut cairo_t, dx: f64, dy: f64);
}
extern "C" {
    pub fn cairo_rel_curve_to(cr: *mut cairo_t, dx1: f64, dy1: f64, dx2: f64,
                              dy2: f64, dx3: f64, dy3: f64);
}
extern "C" {
    pub fn cairo_rectangle(cr: *mut cairo_t, x: f64, y: f64, width: f64,
                           height: f64);
}
extern "C" {
    pub fn cairo_close_path(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_path_extents(cr: *mut cairo_t, x1: *mut f64, y1: *mut f64,
                              x2: *mut f64, y2: *mut f64);
}
extern "C" {
    pub fn cairo_paint(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_paint_with_alpha(cr: *mut cairo_t, alpha: f64);
}
extern "C" {
    pub fn cairo_mask(cr: *mut cairo_t, pattern: *mut cairo_pattern_t);
}
extern "C" {
    pub fn cairo_mask_surface(cr: *mut cairo_t, surface: *mut cairo_surface_t,
                              surface_x: f64, surface_y: f64);
}
extern "C" {
    pub fn cairo_stroke(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_stroke_preserve(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_fill(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_fill_preserve(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_copy_page(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_show_page(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_in_stroke(cr: *mut cairo_t, x: f64, y: f64) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_in_fill(cr: *mut cairo_t, x: f64, y: f64) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_in_clip(cr: *mut cairo_t, x: f64, y: f64) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_stroke_extents(cr: *mut cairo_t, x1: *mut f64, y1: *mut f64,
                                x2: *mut f64, y2: *mut f64);
}
extern "C" {
    pub fn cairo_fill_extents(cr: *mut cairo_t, x1: *mut f64, y1: *mut f64,
                              x2: *mut f64, y2: *mut f64);
}
extern "C" {
    pub fn cairo_reset_clip(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_clip(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_clip_preserve(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_clip_extents(cr: *mut cairo_t, x1: *mut f64, y1: *mut f64,
                              x2: *mut f64, y2: *mut f64);
}
/**
 * cairo_rectangle_t:
 * @x: X coordinate of the left side of the rectangle
 * @y: Y coordinate of the the top side of the rectangle
 * @width: width of the rectangle
 * @height: height of the rectangle
 *
 * A data structure for holding a rectangle.
 *
 * Since: 1.4
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cairo_rectangle {
    pub x: f64,
    pub y: f64,
    pub width: f64,
    pub height: f64,
}
#[test]
fn bindgen_test_layout__cairo_rectangle() {
    assert_eq!(::std::mem::size_of::<_cairo_rectangle>() , 32usize);
    assert_eq!(::std::mem::align_of::<_cairo_rectangle>() , 8usize);
}
impl Clone for _cairo_rectangle {
    fn clone(&self) -> Self { *self }
}
pub type cairo_rectangle_t = _cairo_rectangle;
/**
 * cairo_rectangle_list_t:
 * @status: Error status of the rectangle list
 * @rectangles: Array containing the rectangles
 * @num_rectangles: Number of rectangles in this list
 * 
 * A data structure for holding a dynamically allocated
 * array of rectangles.
 *
 * Since: 1.4
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cairo_rectangle_list {
    pub status: cairo_status_t,
    pub rectangles: *mut cairo_rectangle_t,
    pub num_rectangles: libc::c_int,
}
#[test]
fn bindgen_test_layout__cairo_rectangle_list() {
    assert_eq!(::std::mem::size_of::<_cairo_rectangle_list>() , 24usize);
    assert_eq!(::std::mem::align_of::<_cairo_rectangle_list>() , 8usize);
}
impl Clone for _cairo_rectangle_list {
    fn clone(&self) -> Self { *self }
}
pub type cairo_rectangle_list_t = _cairo_rectangle_list;
extern "C" {
    pub fn cairo_copy_clip_rectangle_list(cr: *mut cairo_t)
     -> *mut cairo_rectangle_list_t;
}
extern "C" {
    pub fn cairo_rectangle_list_destroy(rectangle_list:
                                            *mut cairo_rectangle_list_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_scaled_font([u8; 0]);
/**
 * cairo_scaled_font_t:
 *
 * A #cairo_scaled_font_t is a font scaled to a particular size and device
 * resolution. A #cairo_scaled_font_t is most useful for low-level font
 * usage where a library or application wants to cache a reference
 * to a scaled font to speed up the computation of metrics.
 *
 * There are various types of scaled fonts, depending on the
 * <firstterm>font backend</firstterm> they use. The type of a
 * scaled font can be queried using cairo_scaled_font_get_type().
 *
 * Memory management of #cairo_scaled_font_t is done with
 * cairo_scaled_font_reference() and cairo_scaled_font_destroy().
 *
 * Since: 1.0
 **/
pub type cairo_scaled_font_t = _cairo_scaled_font;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_font_face([u8; 0]);
/**
 * cairo_font_face_t:
 *
 * A #cairo_font_face_t specifies all aspects of a font other
 * than the size or font matrix (a font matrix is used to distort
 * a font by sheering it or scaling it unequally in the two
 * directions) . A font face can be set on a #cairo_t by using
 * cairo_set_font_face(); the size and font matrix are set with
 * cairo_set_font_size() and cairo_set_font_matrix().
 *
 * There are various types of font faces, depending on the
 * <firstterm>font backend</firstterm> they use. The type of a
 * font face can be queried using cairo_font_face_get_type().
 *
 * Memory management of #cairo_font_face_t is done with
 * cairo_font_face_reference() and cairo_font_face_destroy().
 *
 * Since: 1.0
 **/
pub type cairo_font_face_t = _cairo_font_face;
/**
 * cairo_glyph_t:
 * @index: glyph index in the font. The exact interpretation of the
 *      glyph index depends on the font technology being used.
 * @x: the offset in the X direction between the origin used for
 *     drawing or measuring the string and the origin of this glyph.
 * @y: the offset in the Y direction between the origin used for
 *     drawing or measuring the string and the origin of this glyph.
 *
 * The #cairo_glyph_t structure holds information about a single glyph
 * when drawing or measuring text. A font is (in simple terms) a
 * collection of shapes used to draw text. A glyph is one of these
 * shapes. There can be multiple glyphs for a single character
 * (alternates to be used in different contexts, for example), or a
 * glyph can be a <firstterm>ligature</firstterm> of multiple
 * characters. Cairo doesn't expose any way of converting input text
 * into glyphs, so in order to use the Cairo interfaces that take
 * arrays of glyphs, you must directly access the appropriate
 * underlying font system.
 *
 * Note that the offsets given by @x and @y are not cumulative. When
 * drawing or measuring text, each glyph is individually positioned
 * with respect to the overall origin
 *
 * Since: 1.0
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub index: libc::c_ulong,
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_1>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_1>() , 8usize);
}
impl Clone for _bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
pub type cairo_glyph_t = _bindgen_ty_1;
extern "C" {
    pub fn cairo_glyph_allocate(num_glyphs: libc::c_int)
     -> *mut cairo_glyph_t;
}
extern "C" {
    pub fn cairo_glyph_free(glyphs: *mut cairo_glyph_t);
}
/**
 * cairo_text_cluster_t:
 * @num_bytes: the number of bytes of UTF-8 text covered by cluster
 * @num_glyphs: the number of glyphs covered by cluster
 *
 * The #cairo_text_cluster_t structure holds information about a single
 * <firstterm>text cluster</firstterm>.  A text cluster is a minimal
 * mapping of some glyphs corresponding to some UTF-8 text.
 *
 * For a cluster to be valid, both @num_bytes and @num_glyphs should
 * be non-negative, and at least one should be non-zero.
 * Note that clusters with zero glyphs are not as well supported as
 * normal clusters.  For example, PDF rendering applications typically
 * ignore those clusters when PDF text is being selected.
 *
 * See cairo_show_text_glyphs() for how clusters are used in advanced
 * text operations.
 *
 * Since: 1.8
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2 {
    pub num_bytes: libc::c_int,
    pub num_glyphs: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_2>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_2>() , 4usize);
}
impl Clone for _bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
pub type cairo_text_cluster_t = _bindgen_ty_2;
extern "C" {
    pub fn cairo_text_cluster_allocate(num_clusters: libc::c_int)
     -> *mut cairo_text_cluster_t;
}
extern "C" {
    pub fn cairo_text_cluster_free(clusters: *mut cairo_text_cluster_t);
}
#[repr(u32)]
/**
 * cairo_text_cluster_flags_t:
 * @CAIRO_TEXT_CLUSTER_FLAG_BACKWARD: The clusters in the cluster array
 * map to glyphs in the glyph array from end to start. (Since 1.8)
 *
 * Specifies properties of a text cluster mapping.
 *
 * Since: 1.8
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_text_cluster_flags { CAIRO_TEXT_CLUSTER_FLAG_BACKWARD = 1, }
pub use self::_cairo_text_cluster_flags as cairo_text_cluster_flags_t;
/**
 * cairo_text_extents_t:
 * @x_bearing: the horizontal distance from the origin to the
 *   leftmost part of the glyphs as drawn. Positive if the
 *   glyphs lie entirely to the right of the origin.
 * @y_bearing: the vertical distance from the origin to the
 *   topmost part of the glyphs as drawn. Positive only if the
 *   glyphs lie completely below the origin; will usually be
 *   negative.
 * @width: width of the glyphs as drawn
 * @height: height of the glyphs as drawn
 * @x_advance:distance to advance in the X direction
 *    after drawing these glyphs
 * @y_advance: distance to advance in the Y direction
 *   after drawing these glyphs. Will typically be zero except
 *   for vertical text layout as found in East-Asian languages.
 *
 * The #cairo_text_extents_t structure stores the extents of a single
 * glyph or a string of glyphs in user-space coordinates. Because text
 * extents are in user-space coordinates, they are mostly, but not
 * entirely, independent of the current transformation matrix. If you call
 * <literal>cairo_scale(cr, 2.0, 2.0)</literal>, text will
 * be drawn twice as big, but the reported text extents will not be
 * doubled. They will change slightly due to hinting (so you can't
 * assume that metrics are independent of the transformation matrix),
 * but otherwise will remain unchanged.
 *
 * Since: 1.0
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_3 {
    pub x_bearing: f64,
    pub y_bearing: f64,
    pub width: f64,
    pub height: f64,
    pub x_advance: f64,
    pub y_advance: f64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_3>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_3>() , 8usize);
}
impl Clone for _bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
pub type cairo_text_extents_t = _bindgen_ty_3;
/**
 * cairo_font_extents_t:
 * @ascent: the distance that the font extends above the baseline.
 *          Note that this is not always exactly equal to the maximum
 *          of the extents of all the glyphs in the font, but rather
 *          is picked to express the font designer's intent as to
 *          how the font should align with elements above it.
 * @descent: the distance that the font extends below the baseline.
 *           This value is positive for typical fonts that include
 *           portions below the baseline. Note that this is not always
 *           exactly equal to the maximum of the extents of all the
 *           glyphs in the font, but rather is picked to express the
 *           font designer's intent as to how the font should
 *           align with elements below it.
 * @height: the recommended vertical distance between baselines when
 *          setting consecutive lines of text with the font. This
 *          is greater than @ascent+@descent by a
 *          quantity known as the <firstterm>line spacing</firstterm>
 *          or <firstterm>external leading</firstterm>. When space
 *          is at a premium, most fonts can be set with only
 *          a distance of @ascent+@descent between lines.
 * @max_x_advance: the maximum distance in the X direction that
 *         the origin is advanced for any glyph in the font.
 * @max_y_advance: the maximum distance in the Y direction that
 *         the origin is advanced for any glyph in the font.
 *         This will be zero for normal fonts used for horizontal
 *         writing. (The scripts of East Asia are sometimes written
 *         vertically.)
 *
 * The #cairo_font_extents_t structure stores metric information for
 * a font. Values are given in the current user-space coordinate
 * system.
 *
 * Because font metrics are in user-space coordinates, they are
 * mostly, but not entirely, independent of the current transformation
 * matrix. If you call <literal>cairo_scale(cr, 2.0, 2.0)</literal>,
 * text will be drawn twice as big, but the reported text extents will
 * not be doubled. They will change slightly due to hinting (so you
 * can't assume that metrics are independent of the transformation
 * matrix), but otherwise will remain unchanged.
 *
 * Since: 1.0
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_4 {
    pub ascent: f64,
    pub descent: f64,
    pub height: f64,
    pub max_x_advance: f64,
    pub max_y_advance: f64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_4>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_4>() , 8usize);
}
impl Clone for _bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
pub type cairo_font_extents_t = _bindgen_ty_4;
#[repr(u32)]
/**
 * cairo_font_slant_t:
 * @CAIRO_FONT_SLANT_NORMAL: Upright font style, since 1.0
 * @CAIRO_FONT_SLANT_ITALIC: Italic font style, since 1.0
 * @CAIRO_FONT_SLANT_OBLIQUE: Oblique font style, since 1.0
 *
 * Specifies variants of a font face based on their slant.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_font_slant {
    CAIRO_FONT_SLANT_NORMAL = 0,
    CAIRO_FONT_SLANT_ITALIC = 1,
    CAIRO_FONT_SLANT_OBLIQUE = 2,
}
pub use self::_cairo_font_slant as cairo_font_slant_t;
#[repr(u32)]
/**
 * cairo_font_weight_t:
 * @CAIRO_FONT_WEIGHT_NORMAL: Normal font weight, since 1.0
 * @CAIRO_FONT_WEIGHT_BOLD: Bold font weight, since 1.0
 *
 * Specifies variants of a font face based on their weight.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_font_weight {
    CAIRO_FONT_WEIGHT_NORMAL = 0,
    CAIRO_FONT_WEIGHT_BOLD = 1,
}
pub use self::_cairo_font_weight as cairo_font_weight_t;
#[repr(u32)]
/**
 * cairo_subpixel_order_t:
 * @CAIRO_SUBPIXEL_ORDER_DEFAULT: Use the default subpixel order for
 *   for the target device, since 1.0
 * @CAIRO_SUBPIXEL_ORDER_RGB: Subpixel elements are arranged horizontally
 *   with red at the left, since 1.0
 * @CAIRO_SUBPIXEL_ORDER_BGR:  Subpixel elements are arranged horizontally
 *   with blue at the left, since 1.0
 * @CAIRO_SUBPIXEL_ORDER_VRGB: Subpixel elements are arranged vertically
 *   with red at the top, since 1.0
 * @CAIRO_SUBPIXEL_ORDER_VBGR: Subpixel elements are arranged vertically
 *   with blue at the top, since 1.0
 *
 * The subpixel order specifies the order of color elements within
 * each pixel on the display device when rendering with an
 * antialiasing mode of %CAIRO_ANTIALIAS_SUBPIXEL.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_subpixel_order {
    CAIRO_SUBPIXEL_ORDER_DEFAULT = 0,
    CAIRO_SUBPIXEL_ORDER_RGB = 1,
    CAIRO_SUBPIXEL_ORDER_BGR = 2,
    CAIRO_SUBPIXEL_ORDER_VRGB = 3,
    CAIRO_SUBPIXEL_ORDER_VBGR = 4,
}
pub use self::_cairo_subpixel_order as cairo_subpixel_order_t;
#[repr(u32)]
/**
 * cairo_hint_style_t:
 * @CAIRO_HINT_STYLE_DEFAULT: Use the default hint style for
 *   font backend and target device, since 1.0
 * @CAIRO_HINT_STYLE_NONE: Do not hint outlines, since 1.0
 * @CAIRO_HINT_STYLE_SLIGHT: Hint outlines slightly to improve
 *   contrast while retaining good fidelity to the original
 *   shapes, since 1.0
 * @CAIRO_HINT_STYLE_MEDIUM: Hint outlines with medium strength
 *   giving a compromise between fidelity to the original shapes
 *   and contrast, since 1.0
 * @CAIRO_HINT_STYLE_FULL: Hint outlines to maximize contrast, since 1.0
 *
 * Specifies the type of hinting to do on font outlines. Hinting
 * is the process of fitting outlines to the pixel grid in order
 * to improve the appearance of the result. Since hinting outlines
 * involves distorting them, it also reduces the faithfulness
 * to the original outline shapes. Not all of the outline hinting
 * styles are supported by all font backends.
 *
 * New entries may be added in future versions.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_hint_style {
    CAIRO_HINT_STYLE_DEFAULT = 0,
    CAIRO_HINT_STYLE_NONE = 1,
    CAIRO_HINT_STYLE_SLIGHT = 2,
    CAIRO_HINT_STYLE_MEDIUM = 3,
    CAIRO_HINT_STYLE_FULL = 4,
}
pub use self::_cairo_hint_style as cairo_hint_style_t;
#[repr(u32)]
/**
 * cairo_hint_metrics_t:
 * @CAIRO_HINT_METRICS_DEFAULT: Hint metrics in the default
 *  manner for the font backend and target device, since 1.0
 * @CAIRO_HINT_METRICS_OFF: Do not hint font metrics, since 1.0
 * @CAIRO_HINT_METRICS_ON: Hint font metrics, since 1.0
 *
 * Specifies whether to hint font metrics; hinting font metrics
 * means quantizing them so that they are integer values in
 * device space. Doing this improves the consistency of
 * letter and line spacing, however it also means that text
 * will be laid out differently at different zoom factors.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_hint_metrics {
    CAIRO_HINT_METRICS_DEFAULT = 0,
    CAIRO_HINT_METRICS_OFF = 1,
    CAIRO_HINT_METRICS_ON = 2,
}
pub use self::_cairo_hint_metrics as cairo_hint_metrics_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_font_options([u8; 0]);
/**
 * cairo_font_options_t:
 *
 * An opaque structure holding all options that are used when
 * rendering fonts.
 *
 * Individual features of a #cairo_font_options_t can be set or
 * accessed using functions named
 * <function>cairo_font_options_set_<emphasis>feature_name</emphasis>()</function> and
 * <function>cairo_font_options_get_<emphasis>feature_name</emphasis>()</function>, like
 * cairo_font_options_set_antialias() and
 * cairo_font_options_get_antialias().
 *
 * New features may be added to a #cairo_font_options_t in the
 * future.  For this reason, cairo_font_options_copy(),
 * cairo_font_options_equal(), cairo_font_options_merge(), and
 * cairo_font_options_hash() should be used to copy, check
 * for equality, merge, or compute a hash value of
 * #cairo_font_options_t objects.
 *
 * Since: 1.0
 **/
pub type cairo_font_options_t = _cairo_font_options;
extern "C" {
    pub fn cairo_font_options_create() -> *mut cairo_font_options_t;
}
extern "C" {
    pub fn cairo_font_options_copy(original: *const cairo_font_options_t)
     -> *mut cairo_font_options_t;
}
extern "C" {
    pub fn cairo_font_options_destroy(options: *mut cairo_font_options_t);
}
extern "C" {
    pub fn cairo_font_options_status(options: *mut cairo_font_options_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_font_options_merge(options: *mut cairo_font_options_t,
                                    other: *const cairo_font_options_t);
}
extern "C" {
    pub fn cairo_font_options_equal(options: *const cairo_font_options_t,
                                    other: *const cairo_font_options_t)
     -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_font_options_hash(options: *const cairo_font_options_t)
     -> libc::c_ulong;
}
extern "C" {
    pub fn cairo_font_options_set_antialias(options:
                                                *mut cairo_font_options_t,
                                            antialias: cairo_antialias_t);
}
extern "C" {
    pub fn cairo_font_options_get_antialias(options:
                                                *const cairo_font_options_t)
     -> cairo_antialias_t;
}
extern "C" {
    pub fn cairo_font_options_set_subpixel_order(options:
                                                     *mut cairo_font_options_t,
                                                 subpixel_order:
                                                     cairo_subpixel_order_t);
}
extern "C" {
    pub fn cairo_font_options_get_subpixel_order(options:
                                                     *const cairo_font_options_t)
     -> cairo_subpixel_order_t;
}
extern "C" {
    pub fn cairo_font_options_set_hint_style(options:
                                                 *mut cairo_font_options_t,
                                             hint_style: cairo_hint_style_t);
}
extern "C" {
    pub fn cairo_font_options_get_hint_style(options:
                                                 *const cairo_font_options_t)
     -> cairo_hint_style_t;
}
extern "C" {
    pub fn cairo_font_options_set_hint_metrics(options:
                                                   *mut cairo_font_options_t,
                                               hint_metrics:
                                                   cairo_hint_metrics_t);
}
extern "C" {
    pub fn cairo_font_options_get_hint_metrics(options:
                                                   *const cairo_font_options_t)
     -> cairo_hint_metrics_t;
}
extern "C" {
    pub fn cairo_select_font_face(cr: *mut cairo_t,
                                  family: *const libc::c_char,
                                  slant: cairo_font_slant_t,
                                  weight: cairo_font_weight_t);
}
extern "C" {
    pub fn cairo_set_font_size(cr: *mut cairo_t, size: f64);
}
extern "C" {
    pub fn cairo_set_font_matrix(cr: *mut cairo_t,
                                 matrix: *const cairo_matrix_t);
}
extern "C" {
    pub fn cairo_get_font_matrix(cr: *mut cairo_t,
                                 matrix: *mut cairo_matrix_t);
}
extern "C" {
    pub fn cairo_set_font_options(cr: *mut cairo_t,
                                  options: *const cairo_font_options_t);
}
extern "C" {
    pub fn cairo_get_font_options(cr: *mut cairo_t,
                                  options: *mut cairo_font_options_t);
}
extern "C" {
    pub fn cairo_set_font_face(cr: *mut cairo_t,
                               font_face: *mut cairo_font_face_t);
}
extern "C" {
    pub fn cairo_get_font_face(cr: *mut cairo_t) -> *mut cairo_font_face_t;
}
extern "C" {
    pub fn cairo_set_scaled_font(cr: *mut cairo_t,
                                 scaled_font: *const cairo_scaled_font_t);
}
extern "C" {
    pub fn cairo_get_scaled_font(cr: *mut cairo_t)
     -> *mut cairo_scaled_font_t;
}
extern "C" {
    pub fn cairo_show_text(cr: *mut cairo_t, utf8: *const libc::c_char);
}
extern "C" {
    pub fn cairo_show_glyphs(cr: *mut cairo_t, glyphs: *const cairo_glyph_t,
                             num_glyphs: libc::c_int);
}
extern "C" {
    pub fn cairo_show_text_glyphs(cr: *mut cairo_t, utf8: *const libc::c_char,
                                  utf8_len: libc::c_int,
                                  glyphs: *const cairo_glyph_t,
                                  num_glyphs: libc::c_int,
                                  clusters: *const cairo_text_cluster_t,
                                  num_clusters: libc::c_int,
                                  cluster_flags: cairo_text_cluster_flags_t);
}
extern "C" {
    pub fn cairo_text_path(cr: *mut cairo_t, utf8: *const libc::c_char);
}
extern "C" {
    pub fn cairo_glyph_path(cr: *mut cairo_t, glyphs: *const cairo_glyph_t,
                            num_glyphs: libc::c_int);
}
extern "C" {
    pub fn cairo_text_extents(cr: *mut cairo_t, utf8: *const libc::c_char,
                              extents: *mut cairo_text_extents_t);
}
extern "C" {
    pub fn cairo_glyph_extents(cr: *mut cairo_t, glyphs: *const cairo_glyph_t,
                               num_glyphs: libc::c_int,
                               extents: *mut cairo_text_extents_t);
}
extern "C" {
    pub fn cairo_font_extents(cr: *mut cairo_t,
                              extents: *mut cairo_font_extents_t);
}
extern "C" {
    pub fn cairo_font_face_reference(font_face: *mut cairo_font_face_t)
     -> *mut cairo_font_face_t;
}
extern "C" {
    pub fn cairo_font_face_destroy(font_face: *mut cairo_font_face_t);
}
extern "C" {
    pub fn cairo_font_face_get_reference_count(font_face:
                                                   *mut cairo_font_face_t)
     -> libc::c_uint;
}
extern "C" {
    pub fn cairo_font_face_status(font_face: *mut cairo_font_face_t)
     -> cairo_status_t;
}
#[repr(u32)]
/**
 * cairo_font_type_t:
 * @CAIRO_FONT_TYPE_TOY: The font was created using cairo's toy font api (Since: 1.2)
 * @CAIRO_FONT_TYPE_FT: The font is of type FreeType (Since: 1.2)
 * @CAIRO_FONT_TYPE_WIN32: The font is of type Win32 (Since: 1.2)
 * @CAIRO_FONT_TYPE_QUARTZ: The font is of type Quartz (Since: 1.6, in 1.2 and
 * 1.4 it was named CAIRO_FONT_TYPE_ATSUI)
 * @CAIRO_FONT_TYPE_USER: The font was create using cairo's user font api (Since: 1.8)
 *
 * #cairo_font_type_t is used to describe the type of a given font
 * face or scaled font. The font types are also known as "font
 * backends" within cairo.
 *
 * The type of a font face is determined by the function used to
 * create it, which will generally be of the form
 * <function>cairo_<emphasis>type</emphasis>_font_face_create(<!-- -->)</function>.
 * The font face type can be queried with cairo_font_face_get_type()
 *
 * The various #cairo_font_face_t functions can be used with a font face
 * of any type.
 *
 * The type of a scaled font is determined by the type of the font
 * face passed to cairo_scaled_font_create(). The scaled font type can
 * be queried with cairo_scaled_font_get_type()
 *
 * The various #cairo_scaled_font_t functions can be used with scaled
 * fonts of any type, but some font backends also provide
 * type-specific functions that must only be called with a scaled font
 * of the appropriate type. These functions have names that begin with
 * <function>cairo_<emphasis>type</emphasis>_scaled_font(<!-- -->)</function>
 * such as cairo_ft_scaled_font_lock_face().
 *
 * The behavior of calling a type-specific function with a scaled font
 * of the wrong type is undefined.
 *
 * New entries may be added in future versions.
 *
 * Since: 1.2
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_font_type {
    CAIRO_FONT_TYPE_TOY = 0,
    CAIRO_FONT_TYPE_FT = 1,
    CAIRO_FONT_TYPE_WIN32 = 2,
    CAIRO_FONT_TYPE_QUARTZ = 3,
    CAIRO_FONT_TYPE_USER = 4,
}
pub use self::_cairo_font_type as cairo_font_type_t;
extern "C" {
    pub fn cairo_font_face_get_type(font_face: *mut cairo_font_face_t)
     -> cairo_font_type_t;
}
extern "C" {
    pub fn cairo_font_face_get_user_data(font_face: *mut cairo_font_face_t,
                                         key: *const cairo_user_data_key_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn cairo_font_face_set_user_data(font_face: *mut cairo_font_face_t,
                                         key: *const cairo_user_data_key_t,
                                         user_data: *mut libc::c_void,
                                         destroy: cairo_destroy_func_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_scaled_font_create(font_face: *mut cairo_font_face_t,
                                    font_matrix: *const cairo_matrix_t,
                                    ctm: *const cairo_matrix_t,
                                    options: *const cairo_font_options_t)
     -> *mut cairo_scaled_font_t;
}
extern "C" {
    pub fn cairo_scaled_font_reference(scaled_font: *mut cairo_scaled_font_t)
     -> *mut cairo_scaled_font_t;
}
extern "C" {
    pub fn cairo_scaled_font_destroy(scaled_font: *mut cairo_scaled_font_t);
}
extern "C" {
    pub fn cairo_scaled_font_get_reference_count(scaled_font:
                                                     *mut cairo_scaled_font_t)
     -> libc::c_uint;
}
extern "C" {
    pub fn cairo_scaled_font_status(scaled_font: *mut cairo_scaled_font_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_scaled_font_get_type(scaled_font: *mut cairo_scaled_font_t)
     -> cairo_font_type_t;
}
extern "C" {
    pub fn cairo_scaled_font_get_user_data(scaled_font:
                                               *mut cairo_scaled_font_t,
                                           key: *const cairo_user_data_key_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn cairo_scaled_font_set_user_data(scaled_font:
                                               *mut cairo_scaled_font_t,
                                           key: *const cairo_user_data_key_t,
                                           user_data: *mut libc::c_void,
                                           destroy: cairo_destroy_func_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_scaled_font_extents(scaled_font: *mut cairo_scaled_font_t,
                                     extents: *mut cairo_font_extents_t);
}
extern "C" {
    pub fn cairo_scaled_font_text_extents(scaled_font:
                                              *mut cairo_scaled_font_t,
                                          utf8: *const libc::c_char,
                                          extents: *mut cairo_text_extents_t);
}
extern "C" {
    pub fn cairo_scaled_font_glyph_extents(scaled_font:
                                               *mut cairo_scaled_font_t,
                                           glyphs: *const cairo_glyph_t,
                                           num_glyphs: libc::c_int,
                                           extents:
                                               *mut cairo_text_extents_t);
}
extern "C" {
    pub fn cairo_scaled_font_text_to_glyphs(scaled_font:
                                                *mut cairo_scaled_font_t,
                                            x: f64, y: f64,
                                            utf8: *const libc::c_char,
                                            utf8_len: libc::c_int,
                                            glyphs: *mut *mut cairo_glyph_t,
                                            num_glyphs: *mut libc::c_int,
                                            clusters:
                                                *mut *mut cairo_text_cluster_t,
                                            num_clusters: *mut libc::c_int,
                                            cluster_flags:
                                                *mut cairo_text_cluster_flags_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_scaled_font_get_font_face(scaled_font:
                                               *mut cairo_scaled_font_t)
     -> *mut cairo_font_face_t;
}
extern "C" {
    pub fn cairo_scaled_font_get_font_matrix(scaled_font:
                                                 *mut cairo_scaled_font_t,
                                             font_matrix:
                                                 *mut cairo_matrix_t);
}
extern "C" {
    pub fn cairo_scaled_font_get_ctm(scaled_font: *mut cairo_scaled_font_t,
                                     ctm: *mut cairo_matrix_t);
}
extern "C" {
    pub fn cairo_scaled_font_get_scale_matrix(scaled_font:
                                                  *mut cairo_scaled_font_t,
                                              scale_matrix:
                                                  *mut cairo_matrix_t);
}
extern "C" {
    pub fn cairo_scaled_font_get_font_options(scaled_font:
                                                  *mut cairo_scaled_font_t,
                                              options:
                                                  *mut cairo_font_options_t);
}
extern "C" {
    pub fn cairo_toy_font_face_create(family: *const libc::c_char,
                                      slant: cairo_font_slant_t,
                                      weight: cairo_font_weight_t)
     -> *mut cairo_font_face_t;
}
extern "C" {
    pub fn cairo_toy_font_face_get_family(font_face: *mut cairo_font_face_t)
     -> *const libc::c_char;
}
extern "C" {
    pub fn cairo_toy_font_face_get_slant(font_face: *mut cairo_font_face_t)
     -> cairo_font_slant_t;
}
extern "C" {
    pub fn cairo_toy_font_face_get_weight(font_face: *mut cairo_font_face_t)
     -> cairo_font_weight_t;
}
extern "C" {
    pub fn cairo_user_font_face_create() -> *mut cairo_font_face_t;
}
/**
 * cairo_user_scaled_font_init_func_t:
 * @scaled_font: the scaled-font being created
 * @cr: a cairo context, in font space
 * @extents: font extents to fill in, in font space
 *
 * #cairo_user_scaled_font_init_func_t is the type of function which is
 * called when a scaled-font needs to be created for a user font-face.
 *
 * The cairo context @cr is not used by the caller, but is prepared in font
 * space, similar to what the cairo contexts passed to the render_glyph
 * method will look like.  The callback can use this context for extents
 * computation for example.  After the callback is called, @cr is checked
 * for any error status.
 *
 * The @extents argument is where the user font sets the font extents for
 * @scaled_font.  It is in font space, which means that for most cases its
 * ascent and descent members should add to 1.0.  @extents is preset to
 * hold a value of 1.0 for ascent, height, and max_x_advance, and 0.0 for
 * descent and max_y_advance members.
 *
 * The callback is optional.  If not set, default font extents as described
 * in the previous paragraph will be used.
 *
 * Note that @scaled_font is not fully initialized at this
 * point and trying to use it for text operations in the callback will result
 * in deadlock.
 *
 * Returns: %CAIRO_STATUS_SUCCESS upon success, or an error status on error.
 *
 * Since: 1.8
 **/
pub type cairo_user_scaled_font_init_func_t =
    ::std::option::Option<unsafe extern "C" fn(scaled_font:
                                                   *mut cairo_scaled_font_t,
                                               cr: *mut cairo_t,
                                               extents:
                                                   *mut cairo_font_extents_t)
                              -> _cairo_status>;
/**
 * cairo_user_scaled_font_render_glyph_func_t:
 * @scaled_font: user scaled-font
 * @glyph: glyph code to render
 * @cr: cairo context to draw to, in font space
 * @extents: glyph extents to fill in, in font space
 *
 * #cairo_user_scaled_font_render_glyph_func_t is the type of function which
 * is called when a user scaled-font needs to render a glyph.
 *
 * The callback is mandatory, and expected to draw the glyph with code @glyph to
 * the cairo context @cr.  @cr is prepared such that the glyph drawing is done in
 * font space.  That is, the matrix set on @cr is the scale matrix of @scaled_font,
 * The @extents argument is where the user font sets the font extents for
 * @scaled_font.  However, if user prefers to draw in user space, they can
 * achieve that by changing the matrix on @cr.  All cairo rendering operations
 * to @cr are permitted, however, the result is undefined if any source other
 * than the default source on @cr is used.  That means, glyph bitmaps should
 * be rendered using cairo_mask() instead of cairo_paint().
 *
 * Other non-default settings on @cr include a font size of 1.0 (given that
 * it is set up to be in font space), and font options corresponding to
 * @scaled_font.
 *
 * The @extents argument is preset to have <literal>x_bearing</literal>,
 * <literal>width</literal>, and <literal>y_advance</literal> of zero,
 * <literal>y_bearing</literal> set to <literal>-font_extents.ascent</literal>,
 * <literal>height</literal> to <literal>font_extents.ascent+font_extents.descent</literal>,
 * and <literal>x_advance</literal> to <literal>font_extents.max_x_advance</literal>.
 * The only field user needs to set in majority of cases is
 * <literal>x_advance</literal>.
 * If the <literal>width</literal> field is zero upon the callback returning
 * (which is its preset value), the glyph extents are automatically computed
 * based on the drawings done to @cr.  This is in most cases exactly what the
 * desired behavior is.  However, if for any reason the callback sets the
 * extents, it must be ink extents, and include the extents of all drawing
 * done to @cr in the callback.
 *
 * Returns: %CAIRO_STATUS_SUCCESS upon success, or
 * %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
 *
 * Since: 1.8
 **/
pub type cairo_user_scaled_font_render_glyph_func_t =
    ::std::option::Option<unsafe extern "C" fn(scaled_font:
                                                   *mut cairo_scaled_font_t,
                                               glyph: libc::c_ulong,
                                               cr: *mut cairo_t,
                                               extents:
                                                   *mut cairo_text_extents_t)
                              -> _cairo_status>;
/**
 * cairo_user_scaled_font_text_to_glyphs_func_t:
 * @scaled_font: the scaled-font being created
 * @utf8: a string of text encoded in UTF-8
 * @utf8_len: length of @utf8 in bytes
 * @glyphs: pointer to array of glyphs to fill, in font space
 * @num_glyphs: pointer to number of glyphs
 * @clusters: pointer to array of cluster mapping information to fill, or %NULL
 * @num_clusters: pointer to number of clusters
 * @cluster_flags: pointer to location to store cluster flags corresponding to the
 *                 output @clusters
 *
 * #cairo_user_scaled_font_text_to_glyphs_func_t is the type of function which
 * is called to convert input text to an array of glyphs.  This is used by the
 * cairo_show_text() operation.
 *
 * Using this callback the user-font has full control on glyphs and their
 * positions.  That means, it allows for features like ligatures and kerning,
 * as well as complex <firstterm>shaping</firstterm> required for scripts like
 * Arabic and Indic.
 *
 * The @num_glyphs argument is preset to the number of glyph entries available
 * in the @glyphs buffer. If the @glyphs buffer is %NULL, the value of
 * @num_glyphs will be zero.  If the provided glyph array is too short for
 * the conversion (or for convenience), a new glyph array may be allocated
 * using cairo_glyph_allocate() and placed in @glyphs.  Upon return,
 * @num_glyphs should contain the number of generated glyphs.  If the value
 * @glyphs points at has changed after the call, the caller will free the
 * allocated glyph array using cairo_glyph_free().  The caller will also free
 * the original value of @glyphs, so the callback shouldn't do so.
 * The callback should populate the glyph indices and positions (in font space)
 * assuming that the text is to be shown at the origin.
 *
 * If @clusters is not %NULL, @num_clusters and @cluster_flags are also
 * non-%NULL, and cluster mapping should be computed. The semantics of how
 * cluster array allocation works is similar to the glyph array.  That is,
 * if @clusters initially points to a non-%NULL value, that array may be used
 * as a cluster buffer, and @num_clusters points to the number of cluster
 * entries available there.  If the provided cluster array is too short for
 * the conversion (or for convenience), a new cluster array may be allocated
 * using cairo_text_cluster_allocate() and placed in @clusters.  In this case,
 * the original value of @clusters will still be freed by the caller.  Upon
 * return, @num_clusters should contain the number of generated clusters.
 * If the value @clusters points at has changed after the call, the caller
 * will free the allocated cluster array using cairo_text_cluster_free().
 *
 * The callback is optional.  If @num_glyphs is negative upon
 * the callback returning or if the return value
 * is %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, the unicode_to_glyph callback
 * is tried.  See #cairo_user_scaled_font_unicode_to_glyph_func_t.
 *
 * Note: While cairo does not impose any limitation on glyph indices,
 * some applications may assume that a glyph index fits in a 16-bit
 * unsigned integer.  As such, it is advised that user-fonts keep their
 * glyphs in the 0 to 65535 range.  Furthermore, some applications may
 * assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
 * are advised to use glyph 0 for such purposes and do not use that
 * glyph value for other purposes.
 *
 * Returns: %CAIRO_STATUS_SUCCESS upon success,
 * %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,
 * or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
 *
 * Since: 1.8
 **/
pub type cairo_user_scaled_font_text_to_glyphs_func_t =
    ::std::option::Option<unsafe extern "C" fn(scaled_font:
                                                   *mut cairo_scaled_font_t,
                                               utf8: *const libc::c_char,
                                               utf8_len: libc::c_int,
                                               glyphs:
                                                   *mut *mut cairo_glyph_t,
                                               num_glyphs: *mut libc::c_int,
                                               clusters:
                                                   *mut *mut cairo_text_cluster_t,
                                               num_clusters: *mut libc::c_int,
                                               cluster_flags:
                                                   *mut cairo_text_cluster_flags_t)
                              -> _cairo_status>;
/**
 * cairo_user_scaled_font_unicode_to_glyph_func_t:
 * @scaled_font: the scaled-font being created
 * @unicode: input unicode character code-point
 * @glyph_index: output glyph index
 *
 * #cairo_user_scaled_font_unicode_to_glyph_func_t is the type of function which
 * is called to convert an input Unicode character to a single glyph.
 * This is used by the cairo_show_text() operation.
 *
 * This callback is used to provide the same functionality as the
 * text_to_glyphs callback does (see #cairo_user_scaled_font_text_to_glyphs_func_t)
 * but has much less control on the output,
 * in exchange for increased ease of use.  The inherent assumption to using
 * this callback is that each character maps to one glyph, and that the
 * mapping is context independent.  It also assumes that glyphs are positioned
 * according to their advance width.  These mean no ligatures, kerning, or
 * complex scripts can be implemented using this callback.
 *
 * The callback is optional, and only used if text_to_glyphs callback is not
 * set or fails to return glyphs.  If this callback is not set or if it returns
 * %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, an identity mapping from Unicode
 * code-points to glyph indices is assumed.
 *
 * Note: While cairo does not impose any limitation on glyph indices,
 * some applications may assume that a glyph index fits in a 16-bit
 * unsigned integer.  As such, it is advised that user-fonts keep their
 * glyphs in the 0 to 65535 range.  Furthermore, some applications may
 * assume that glyph 0 is a special glyph-not-found glyph.  User-fonts
 * are advised to use glyph 0 for such purposes and do not use that
 * glyph value for other purposes.
 *
 * Returns: %CAIRO_STATUS_SUCCESS upon success,
 * %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,
 * or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error.
 *
 * Since: 1.8
 **/
pub type cairo_user_scaled_font_unicode_to_glyph_func_t =
    ::std::option::Option<unsafe extern "C" fn(scaled_font:
                                                   *mut cairo_scaled_font_t,
                                               unicode: libc::c_ulong,
                                               glyph_index:
                                                   *mut libc::c_ulong)
                              -> _cairo_status>;
extern "C" {
    pub fn cairo_user_font_face_set_init_func(font_face:
                                                  *mut cairo_font_face_t,
                                              init_func:
                                                  cairo_user_scaled_font_init_func_t);
}
extern "C" {
    pub fn cairo_user_font_face_set_render_glyph_func(font_face:
                                                          *mut cairo_font_face_t,
                                                      render_glyph_func:
                                                          cairo_user_scaled_font_render_glyph_func_t);
}
extern "C" {
    pub fn cairo_user_font_face_set_text_to_glyphs_func(font_face:
                                                            *mut cairo_font_face_t,
                                                        text_to_glyphs_func:
                                                            cairo_user_scaled_font_text_to_glyphs_func_t);
}
extern "C" {
    pub fn cairo_user_font_face_set_unicode_to_glyph_func(font_face:
                                                              *mut cairo_font_face_t,
                                                          unicode_to_glyph_func:
                                                              cairo_user_scaled_font_unicode_to_glyph_func_t);
}
extern "C" {
    pub fn cairo_user_font_face_get_init_func(font_face:
                                                  *mut cairo_font_face_t)
     -> cairo_user_scaled_font_init_func_t;
}
extern "C" {
    pub fn cairo_user_font_face_get_render_glyph_func(font_face:
                                                          *mut cairo_font_face_t)
     -> cairo_user_scaled_font_render_glyph_func_t;
}
extern "C" {
    pub fn cairo_user_font_face_get_text_to_glyphs_func(font_face:
                                                            *mut cairo_font_face_t)
     -> cairo_user_scaled_font_text_to_glyphs_func_t;
}
extern "C" {
    pub fn cairo_user_font_face_get_unicode_to_glyph_func(font_face:
                                                              *mut cairo_font_face_t)
     -> cairo_user_scaled_font_unicode_to_glyph_func_t;
}
extern "C" {
    pub fn cairo_get_operator(cr: *mut cairo_t) -> cairo_operator_t;
}
extern "C" {
    pub fn cairo_get_source(cr: *mut cairo_t) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_get_tolerance(cr: *mut cairo_t) -> f64;
}
extern "C" {
    pub fn cairo_get_antialias(cr: *mut cairo_t) -> cairo_antialias_t;
}
extern "C" {
    pub fn cairo_has_current_point(cr: *mut cairo_t) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_get_current_point(cr: *mut cairo_t, x: *mut f64,
                                   y: *mut f64);
}
extern "C" {
    pub fn cairo_get_fill_rule(cr: *mut cairo_t) -> cairo_fill_rule_t;
}
extern "C" {
    pub fn cairo_get_line_width(cr: *mut cairo_t) -> f64;
}
extern "C" {
    pub fn cairo_get_line_cap(cr: *mut cairo_t) -> cairo_line_cap_t;
}
extern "C" {
    pub fn cairo_get_line_join(cr: *mut cairo_t) -> cairo_line_join_t;
}
extern "C" {
    pub fn cairo_get_miter_limit(cr: *mut cairo_t) -> f64;
}
extern "C" {
    pub fn cairo_get_dash_count(cr: *mut cairo_t) -> libc::c_int;
}
extern "C" {
    pub fn cairo_get_dash(cr: *mut cairo_t, dashes: *mut f64,
                          offset: *mut f64);
}
extern "C" {
    pub fn cairo_get_matrix(cr: *mut cairo_t, matrix: *mut cairo_matrix_t);
}
extern "C" {
    pub fn cairo_get_target(cr: *mut cairo_t) -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_get_group_target(cr: *mut cairo_t) -> *mut cairo_surface_t;
}
#[repr(u32)]
/**
 * cairo_path_data_type_t:
 * @CAIRO_PATH_MOVE_TO: A move-to operation, since 1.0
 * @CAIRO_PATH_LINE_TO: A line-to operation, since 1.0
 * @CAIRO_PATH_CURVE_TO: A curve-to operation, since 1.0
 * @CAIRO_PATH_CLOSE_PATH: A close-path operation, since 1.0
 *
 * #cairo_path_data_t is used to describe the type of one portion
 * of a path when represented as a #cairo_path_t.
 * See #cairo_path_data_t for details.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_path_data_type {
    CAIRO_PATH_MOVE_TO = 0,
    CAIRO_PATH_LINE_TO = 1,
    CAIRO_PATH_CURVE_TO = 2,
    CAIRO_PATH_CLOSE_PATH = 3,
}
pub use self::_cairo_path_data_type as cairo_path_data_type_t;
#[repr(C)]
#[derive(Copy)]
pub union _cairo_path_data_t {
    pub header: _cairo_path_data_t__bindgen_ty_1,
    pub point: _cairo_path_data_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cairo_path_data_t__bindgen_ty_1 {
    pub type_: cairo_path_data_type_t,
    pub length: libc::c_int,
}
#[test]
fn bindgen_test_layout__cairo_path_data_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_cairo_path_data_t__bindgen_ty_1>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<_cairo_path_data_t__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _cairo_path_data_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cairo_path_data_t__bindgen_ty_2 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout__cairo_path_data_t__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_cairo_path_data_t__bindgen_ty_2>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<_cairo_path_data_t__bindgen_ty_2>() ,
               8usize);
}
impl Clone for _cairo_path_data_t__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__cairo_path_data_t() {
    assert_eq!(::std::mem::size_of::<_cairo_path_data_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<_cairo_path_data_t>() , 8usize);
}
impl Clone for _cairo_path_data_t {
    fn clone(&self) -> Self { *self }
}
/**
 * cairo_path_data_t:
 *
 * #cairo_path_data_t is used to represent the path data inside a
 * #cairo_path_t.
 *
 * The data structure is designed to try to balance the demands of
 * efficiency and ease-of-use. A path is represented as an array of
 * #cairo_path_data_t, which is a union of headers and points.
 *
 * Each portion of the path is represented by one or more elements in
 * the array, (one header followed by 0 or more points). The length
 * value of the header is the number of array elements for the current
 * portion including the header, (ie. length == 1 + # of points), and
 * where the number of points for each element type is as follows:
 *
 * <programlisting>
 *     %CAIRO_PATH_MOVE_TO:     1 point
 *     %CAIRO_PATH_LINE_TO:     1 point
 *     %CAIRO_PATH_CURVE_TO:    3 points
 *     %CAIRO_PATH_CLOSE_PATH:  0 points
 * </programlisting>
 *
 * The semantics and ordering of the coordinate values are consistent
 * with cairo_move_to(), cairo_line_to(), cairo_curve_to(), and
 * cairo_close_path().
 *
 * Here is sample code for iterating through a #cairo_path_t:
 *
 * <informalexample><programlisting>
 *      int i;
 *      cairo_path_t *path;
 *      cairo_path_data_t *data;
 * &nbsp;
 *      path = cairo_copy_path (cr);
 * &nbsp;
 *      for (i=0; i < path->num_data; i += path->data[i].header.length) {
 *          data = &amp;path->data[i];
 *          switch (data->header.type) {
 *          case CAIRO_PATH_MOVE_TO:
 *              do_move_to_things (data[1].point.x, data[1].point.y);
 *              break;
 *          case CAIRO_PATH_LINE_TO:
 *              do_line_to_things (data[1].point.x, data[1].point.y);
 *              break;
 *          case CAIRO_PATH_CURVE_TO:
 *              do_curve_to_things (data[1].point.x, data[1].point.y,
 *                                  data[2].point.x, data[2].point.y,
 *                                  data[3].point.x, data[3].point.y);
 *              break;
 *          case CAIRO_PATH_CLOSE_PATH:
 *              do_close_path_things ();
 *              break;
 *          }
 *      }
 *      cairo_path_destroy (path);
 * </programlisting></informalexample>
 *
 * As of cairo 1.4, cairo does not mind if there are more elements in
 * a portion of the path than needed.  Such elements can be used by
 * users of the cairo API to hold extra values in the path data
 * structure.  For this reason, it is recommended that applications
 * always use <literal>data->header.length</literal> to
 * iterate over the path data, instead of hardcoding the number of
 * elements for each element type.
 *
 * Since: 1.0
 **/
pub type cairo_path_data_t = _cairo_path_data_t;
/**
 * cairo_path_t:
 * @status: the current error status
 * @data: the elements in the path
 * @num_data: the number of elements in the data array
 *
 * A data structure for holding a path. This data structure serves as
 * the return value for cairo_copy_path() and
 * cairo_copy_path_flat() as well the input value for
 * cairo_append_path().
 *
 * See #cairo_path_data_t for hints on how to iterate over the
 * actual data within the path.
 *
 * The num_data member gives the number of elements in the data
 * array. This number is larger than the number of independent path
 * portions (defined in #cairo_path_data_type_t), since the data
 * includes both headers and coordinates for each portion.
 *
 * Since: 1.0
 **/
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cairo_path {
    pub status: cairo_status_t,
    pub data: *mut cairo_path_data_t,
    pub num_data: libc::c_int,
}
#[test]
fn bindgen_test_layout_cairo_path() {
    assert_eq!(::std::mem::size_of::<cairo_path>() , 24usize);
    assert_eq!(::std::mem::align_of::<cairo_path>() , 8usize);
}
impl Clone for cairo_path {
    fn clone(&self) -> Self { *self }
}
pub type cairo_path_t = cairo_path;
extern "C" {
    pub fn cairo_copy_path(cr: *mut cairo_t) -> *mut cairo_path_t;
}
extern "C" {
    pub fn cairo_copy_path_flat(cr: *mut cairo_t) -> *mut cairo_path_t;
}
extern "C" {
    pub fn cairo_append_path(cr: *mut cairo_t, path: *const cairo_path_t);
}
extern "C" {
    pub fn cairo_path_destroy(path: *mut cairo_path_t);
}
extern "C" {
    pub fn cairo_status(cr: *mut cairo_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_status_to_string(status: cairo_status_t)
     -> *const libc::c_char;
}
extern "C" {
    pub fn cairo_device_reference(device: *mut cairo_device_t)
     -> *mut cairo_device_t;
}
#[repr(i32)]
/**
 * cairo_device_type_t:
 * @CAIRO_DEVICE_TYPE_DRM: The device is of type Direct Render Manager, since 1.10
 * @CAIRO_DEVICE_TYPE_GL: The device is of type OpenGL, since 1.10
 * @CAIRO_DEVICE_TYPE_SCRIPT: The device is of type script, since 1.10
 * @CAIRO_DEVICE_TYPE_XCB: The device is of type xcb, since 1.10
 * @CAIRO_DEVICE_TYPE_XLIB: The device is of type xlib, since 1.10
 * @CAIRO_DEVICE_TYPE_XML: The device is of type XML, since 1.10
 * @CAIRO_DEVICE_TYPE_COGL: The device is of type cogl, since 1.12
 * @CAIRO_DEVICE_TYPE_WIN32: The device is of type win32, since 1.12
 * @CAIRO_DEVICE_TYPE_INVALID: The device is invalid, since 1.10
 *
 * #cairo_device_type_t is used to describe the type of a given
 * device. The devices types are also known as "backends" within cairo.
 *
 * The device type can be queried with cairo_device_get_type()
 *
 * The various #cairo_device_t functions can be used with devices of
 * any type, but some backends also provide type-specific functions
 * that must only be called with a device of the appropriate
 * type. These functions have names that begin with
 * <literal>cairo_<emphasis>type</emphasis>_device</literal> such as
 * cairo_xcb_device_debug_cap_xrender_version().
 *
 * The behavior of calling a type-specific function with a device of
 * the wrong type is undefined.
 *
 * New entries may be added in future versions.
 *
 * Since: 1.10
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_device_type {
    CAIRO_DEVICE_TYPE_DRM = 0,
    CAIRO_DEVICE_TYPE_GL = 1,
    CAIRO_DEVICE_TYPE_SCRIPT = 2,
    CAIRO_DEVICE_TYPE_XCB = 3,
    CAIRO_DEVICE_TYPE_XLIB = 4,
    CAIRO_DEVICE_TYPE_XML = 5,
    CAIRO_DEVICE_TYPE_COGL = 6,
    CAIRO_DEVICE_TYPE_WIN32 = 7,
    CAIRO_DEVICE_TYPE_INVALID = -1,
}
pub use self::_cairo_device_type as cairo_device_type_t;
extern "C" {
    pub fn cairo_device_get_type(device: *mut cairo_device_t)
     -> cairo_device_type_t;
}
extern "C" {
    pub fn cairo_device_status(device: *mut cairo_device_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_device_acquire(device: *mut cairo_device_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_device_release(device: *mut cairo_device_t);
}
extern "C" {
    pub fn cairo_device_flush(device: *mut cairo_device_t);
}
extern "C" {
    pub fn cairo_device_finish(device: *mut cairo_device_t);
}
extern "C" {
    pub fn cairo_device_destroy(device: *mut cairo_device_t);
}
extern "C" {
    pub fn cairo_device_get_reference_count(device: *mut cairo_device_t)
     -> libc::c_uint;
}
extern "C" {
    pub fn cairo_device_get_user_data(device: *mut cairo_device_t,
                                      key: *const cairo_user_data_key_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn cairo_device_set_user_data(device: *mut cairo_device_t,
                                      key: *const cairo_user_data_key_t,
                                      user_data: *mut libc::c_void,
                                      destroy: cairo_destroy_func_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_create_similar(other: *mut cairo_surface_t,
                                        content: cairo_content_t,
                                        width: libc::c_int,
                                        height: libc::c_int)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_surface_create_similar_image(other: *mut cairo_surface_t,
                                              format: cairo_format_t,
                                              width: libc::c_int,
                                              height: libc::c_int)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_surface_map_to_image(surface: *mut cairo_surface_t,
                                      extents: *const cairo_rectangle_int_t)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_surface_unmap_image(surface: *mut cairo_surface_t,
                                     image: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_create_for_rectangle(target: *mut cairo_surface_t,
                                              x: f64, y: f64, width: f64,
                                              height: f64)
     -> *mut cairo_surface_t;
}
pub const CAIRO_SURFACE_OBSERVER_NORMAL: _bindgen_ty_5 =
    _bindgen_ty_5::CAIRO_SURFACE_OBSERVER_NORMAL;
pub const CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS: _bindgen_ty_5 =
    _bindgen_ty_5::CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS;
#[repr(u32)]
/**
 * cairo_surface_observer_mode_t:
 * @CAIRO_SURFACE_OBSERVER_NORMAL: no recording is done
 * @CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS: operations are recorded
 *
 * Whether operations should be recorded.
 *
 * Since: 1.12
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    CAIRO_SURFACE_OBSERVER_NORMAL = 0,
    CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS = 1,
}
pub use self::_bindgen_ty_5 as cairo_surface_observer_mode_t;
extern "C" {
    pub fn cairo_surface_create_observer(target: *mut cairo_surface_t,
                                         mode: cairo_surface_observer_mode_t)
     -> *mut cairo_surface_t;
}
pub type cairo_surface_observer_callback_t =
    ::std::option::Option<unsafe extern "C" fn(observer: *mut cairo_surface_t,
                                               target: *mut cairo_surface_t,
                                               data: *mut libc::c_void)>;
extern "C" {
    pub fn cairo_surface_observer_add_paint_callback(abstract_surface:
                                                         *mut cairo_surface_t,
                                                     func:
                                                         cairo_surface_observer_callback_t,
                                                     data: *mut libc::c_void)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_mask_callback(abstract_surface:
                                                        *mut cairo_surface_t,
                                                    func:
                                                        cairo_surface_observer_callback_t,
                                                    data: *mut libc::c_void)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_fill_callback(abstract_surface:
                                                        *mut cairo_surface_t,
                                                    func:
                                                        cairo_surface_observer_callback_t,
                                                    data: *mut libc::c_void)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_stroke_callback(abstract_surface:
                                                          *mut cairo_surface_t,
                                                      func:
                                                          cairo_surface_observer_callback_t,
                                                      data: *mut libc::c_void)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_glyphs_callback(abstract_surface:
                                                          *mut cairo_surface_t,
                                                      func:
                                                          cairo_surface_observer_callback_t,
                                                      data: *mut libc::c_void)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_flush_callback(abstract_surface:
                                                         *mut cairo_surface_t,
                                                     func:
                                                         cairo_surface_observer_callback_t,
                                                     data: *mut libc::c_void)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_finish_callback(abstract_surface:
                                                          *mut cairo_surface_t,
                                                      func:
                                                          cairo_surface_observer_callback_t,
                                                      data: *mut libc::c_void)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_print(surface: *mut cairo_surface_t,
                                        write_func: cairo_write_func_t,
                                        closure: *mut libc::c_void)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_elapsed(surface: *mut cairo_surface_t)
     -> f64;
}
extern "C" {
    pub fn cairo_device_observer_print(device: *mut cairo_device_t,
                                       write_func: cairo_write_func_t,
                                       closure: *mut libc::c_void)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_device_observer_elapsed(device: *mut cairo_device_t) -> f64;
}
extern "C" {
    pub fn cairo_device_observer_paint_elapsed(device: *mut cairo_device_t)
     -> f64;
}
extern "C" {
    pub fn cairo_device_observer_mask_elapsed(device: *mut cairo_device_t)
     -> f64;
}
extern "C" {
    pub fn cairo_device_observer_fill_elapsed(device: *mut cairo_device_t)
     -> f64;
}
extern "C" {
    pub fn cairo_device_observer_stroke_elapsed(device: *mut cairo_device_t)
     -> f64;
}
extern "C" {
    pub fn cairo_device_observer_glyphs_elapsed(device: *mut cairo_device_t)
     -> f64;
}
extern "C" {
    pub fn cairo_surface_reference(surface: *mut cairo_surface_t)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_surface_finish(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_destroy(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_get_device(surface: *mut cairo_surface_t)
     -> *mut cairo_device_t;
}
extern "C" {
    pub fn cairo_surface_get_reference_count(surface: *mut cairo_surface_t)
     -> libc::c_uint;
}
extern "C" {
    pub fn cairo_surface_status(surface: *mut cairo_surface_t)
     -> cairo_status_t;
}
#[repr(u32)]
/**
 * cairo_surface_type_t:
 * @CAIRO_SURFACE_TYPE_IMAGE: The surface is of type image, since 1.2
 * @CAIRO_SURFACE_TYPE_PDF: The surface is of type pdf, since 1.2
 * @CAIRO_SURFACE_TYPE_PS: The surface is of type ps, since 1.2
 * @CAIRO_SURFACE_TYPE_XLIB: The surface is of type xlib, since 1.2
 * @CAIRO_SURFACE_TYPE_XCB: The surface is of type xcb, since 1.2
 * @CAIRO_SURFACE_TYPE_GLITZ: The surface is of type glitz, since 1.2
 * @CAIRO_SURFACE_TYPE_QUARTZ: The surface is of type quartz, since 1.2
 * @CAIRO_SURFACE_TYPE_WIN32: The surface is of type win32, since 1.2
 * @CAIRO_SURFACE_TYPE_BEOS: The surface is of type beos, since 1.2
 * @CAIRO_SURFACE_TYPE_DIRECTFB: The surface is of type directfb, since 1.2
 * @CAIRO_SURFACE_TYPE_SVG: The surface is of type svg, since 1.2
 * @CAIRO_SURFACE_TYPE_OS2: The surface is of type os2, since 1.4
 * @CAIRO_SURFACE_TYPE_WIN32_PRINTING: The surface is a win32 printing surface, since 1.6
 * @CAIRO_SURFACE_TYPE_QUARTZ_IMAGE: The surface is of type quartz_image, since 1.6
 * @CAIRO_SURFACE_TYPE_SCRIPT: The surface is of type script, since 1.10
 * @CAIRO_SURFACE_TYPE_QT: The surface is of type Qt, since 1.10
 * @CAIRO_SURFACE_TYPE_RECORDING: The surface is of type recording, since 1.10
 * @CAIRO_SURFACE_TYPE_VG: The surface is a OpenVG surface, since 1.10
 * @CAIRO_SURFACE_TYPE_GL: The surface is of type OpenGL, since 1.10
 * @CAIRO_SURFACE_TYPE_DRM: The surface is of type Direct Render Manager, since 1.10
 * @CAIRO_SURFACE_TYPE_TEE: The surface is of type 'tee' (a multiplexing surface), since 1.10
 * @CAIRO_SURFACE_TYPE_XML: The surface is of type XML (for debugging), since 1.10
 * @CAIRO_SURFACE_TYPE_SKIA: The surface is of type Skia, since 1.10
 * @CAIRO_SURFACE_TYPE_SUBSURFACE: The surface is a subsurface created with
 *   cairo_surface_create_for_rectangle(), since 1.10
 * @CAIRO_SURFACE_TYPE_COGL: This surface is of type Cogl, since 1.12
 *
 * #cairo_surface_type_t is used to describe the type of a given
 * surface. The surface types are also known as "backends" or "surface
 * backends" within cairo.
 *
 * The type of a surface is determined by the function used to create
 * it, which will generally be of the form
 * <function>cairo_<emphasis>type</emphasis>_surface_create(<!-- -->)</function>,
 * (though see cairo_surface_create_similar() as well).
 *
 * The surface type can be queried with cairo_surface_get_type()
 *
 * The various #cairo_surface_t functions can be used with surfaces of
 * any type, but some backends also provide type-specific functions
 * that must only be called with a surface of the appropriate
 * type. These functions have names that begin with
 * <literal>cairo_<emphasis>type</emphasis>_surface</literal> such as cairo_image_surface_get_width().
 *
 * The behavior of calling a type-specific function with a surface of
 * the wrong type is undefined.
 *
 * New entries may be added in future versions.
 *
 * Since: 1.2
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_surface_type {
    CAIRO_SURFACE_TYPE_IMAGE = 0,
    CAIRO_SURFACE_TYPE_PDF = 1,
    CAIRO_SURFACE_TYPE_PS = 2,
    CAIRO_SURFACE_TYPE_XLIB = 3,
    CAIRO_SURFACE_TYPE_XCB = 4,
    CAIRO_SURFACE_TYPE_GLITZ = 5,
    CAIRO_SURFACE_TYPE_QUARTZ = 6,
    CAIRO_SURFACE_TYPE_WIN32 = 7,
    CAIRO_SURFACE_TYPE_BEOS = 8,
    CAIRO_SURFACE_TYPE_DIRECTFB = 9,
    CAIRO_SURFACE_TYPE_SVG = 10,
    CAIRO_SURFACE_TYPE_OS2 = 11,
    CAIRO_SURFACE_TYPE_WIN32_PRINTING = 12,
    CAIRO_SURFACE_TYPE_QUARTZ_IMAGE = 13,
    CAIRO_SURFACE_TYPE_SCRIPT = 14,
    CAIRO_SURFACE_TYPE_QT = 15,
    CAIRO_SURFACE_TYPE_RECORDING = 16,
    CAIRO_SURFACE_TYPE_VG = 17,
    CAIRO_SURFACE_TYPE_GL = 18,
    CAIRO_SURFACE_TYPE_DRM = 19,
    CAIRO_SURFACE_TYPE_TEE = 20,
    CAIRO_SURFACE_TYPE_XML = 21,
    CAIRO_SURFACE_TYPE_SKIA = 22,
    CAIRO_SURFACE_TYPE_SUBSURFACE = 23,
    CAIRO_SURFACE_TYPE_COGL = 24,
}
pub use self::_cairo_surface_type as cairo_surface_type_t;
extern "C" {
    pub fn cairo_surface_get_type(surface: *mut cairo_surface_t)
     -> cairo_surface_type_t;
}
extern "C" {
    pub fn cairo_surface_get_content(surface: *mut cairo_surface_t)
     -> cairo_content_t;
}
extern "C" {
    pub fn cairo_surface_write_to_png(surface: *mut cairo_surface_t,
                                      filename: *const libc::c_char)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_write_to_png_stream(surface: *mut cairo_surface_t,
                                             write_func: cairo_write_func_t,
                                             closure: *mut libc::c_void)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_get_user_data(surface: *mut cairo_surface_t,
                                       key: *const cairo_user_data_key_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn cairo_surface_set_user_data(surface: *mut cairo_surface_t,
                                       key: *const cairo_user_data_key_t,
                                       user_data: *mut libc::c_void,
                                       destroy: cairo_destroy_func_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_get_mime_data(surface: *mut cairo_surface_t,
                                       mime_type: *const libc::c_char,
                                       data: *mut *const libc::c_uchar,
                                       length: *mut libc::c_ulong);
}
extern "C" {
    pub fn cairo_surface_set_mime_data(surface: *mut cairo_surface_t,
                                       mime_type: *const libc::c_char,
                                       data: *const libc::c_uchar,
                                       length: libc::c_ulong,
                                       destroy: cairo_destroy_func_t,
                                       closure: *mut libc::c_void)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_supports_mime_type(surface: *mut cairo_surface_t,
                                            mime_type: *const libc::c_char)
     -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_surface_get_font_options(surface: *mut cairo_surface_t,
                                          options: *mut cairo_font_options_t);
}
extern "C" {
    pub fn cairo_surface_flush(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_mark_dirty(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_mark_dirty_rectangle(surface: *mut cairo_surface_t,
                                              x: libc::c_int, y: libc::c_int,
                                              width: libc::c_int,
                                              height: libc::c_int);
}
extern "C" {
    pub fn cairo_surface_set_device_scale(surface: *mut cairo_surface_t,
                                          x_scale: f64, y_scale: f64);
}
extern "C" {
    pub fn cairo_surface_get_device_scale(surface: *mut cairo_surface_t,
                                          x_scale: *mut f64,
                                          y_scale: *mut f64);
}
extern "C" {
    pub fn cairo_surface_set_device_offset(surface: *mut cairo_surface_t,
                                           x_offset: f64, y_offset: f64);
}
extern "C" {
    pub fn cairo_surface_get_device_offset(surface: *mut cairo_surface_t,
                                           x_offset: *mut f64,
                                           y_offset: *mut f64);
}
extern "C" {
    pub fn cairo_surface_set_fallback_resolution(surface:
                                                     *mut cairo_surface_t,
                                                 x_pixels_per_inch: f64,
                                                 y_pixels_per_inch: f64);
}
extern "C" {
    pub fn cairo_surface_get_fallback_resolution(surface:
                                                     *mut cairo_surface_t,
                                                 x_pixels_per_inch: *mut f64,
                                                 y_pixels_per_inch: *mut f64);
}
extern "C" {
    pub fn cairo_surface_copy_page(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_show_page(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_has_show_text_glyphs(surface: *mut cairo_surface_t)
     -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_image_surface_create(format: cairo_format_t,
                                      width: libc::c_int, height: libc::c_int)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_format_stride_for_width(format: cairo_format_t,
                                         width: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn cairo_image_surface_create_for_data(data: *mut libc::c_uchar,
                                               format: cairo_format_t,
                                               width: libc::c_int,
                                               height: libc::c_int,
                                               stride: libc::c_int)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_image_surface_get_data(surface: *mut cairo_surface_t)
     -> *mut libc::c_uchar;
}
extern "C" {
    pub fn cairo_image_surface_get_format(surface: *mut cairo_surface_t)
     -> cairo_format_t;
}
extern "C" {
    pub fn cairo_image_surface_get_width(surface: *mut cairo_surface_t)
     -> libc::c_int;
}
extern "C" {
    pub fn cairo_image_surface_get_height(surface: *mut cairo_surface_t)
     -> libc::c_int;
}
extern "C" {
    pub fn cairo_image_surface_get_stride(surface: *mut cairo_surface_t)
     -> libc::c_int;
}
extern "C" {
    pub fn cairo_image_surface_create_from_png(filename: *const libc::c_char)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_image_surface_create_from_png_stream(read_func:
                                                          cairo_read_func_t,
                                                      closure:
                                                          *mut libc::c_void)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_recording_surface_create(content: cairo_content_t,
                                          extents: *const cairo_rectangle_t)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_recording_surface_ink_extents(surface: *mut cairo_surface_t,
                                               x0: *mut f64, y0: *mut f64,
                                               width: *mut f64,
                                               height: *mut f64);
}
extern "C" {
    pub fn cairo_recording_surface_get_extents(surface: *mut cairo_surface_t,
                                               extents:
                                                   *mut cairo_rectangle_t)
     -> cairo_bool_t;
}
/**
 * cairo_raster_source_acquire_func_t:
 * @pattern: the pattern being rendered from
 * @callback_data: the user data supplied during creation
 * @target: the rendering target surface
 * @extents: rectangular region of interest in pixels in sample space
 *
 * #cairo_raster_source_acquire_func_t is the type of function which is
 * called when a pattern is being rendered from. It should create a surface
 * that provides the pixel data for the region of interest as defined by
 * extents, though the surface itself does not have to be limited to that
 * area. For convenience the surface should probably be of image type,
 * created with cairo_surface_create_similar_image() for the target (which
 * enables the number of copies to be reduced during transfer to the
 * device). Another option, might be to return a similar surface to the
 * target for explicit handling by the application of a set of cached sources
 * on the device. The region of sample data provided should be defined using
 * cairo_surface_set_device_offset() to specify the top-left corner of the
 * sample data (along with width and height of the surface).
 *
 * Returns: a #cairo_surface_t
 *
 * Since: 1.12
 **/
pub type cairo_raster_source_acquire_func_t =
    ::std::option::Option<unsafe extern "C" fn(pattern: *mut cairo_pattern_t,
                                               callback_data:
                                                   *mut libc::c_void,
                                               target: *mut cairo_surface_t,
                                               extents:
                                                   *const cairo_rectangle_int_t)
                              -> *mut _cairo_surface>;
/**
 * cairo_raster_source_release_func_t:
 * @pattern: the pattern being rendered from
 * @callback_data: the user data supplied during creation
 * @surface: the surface created during acquire
 *
 * #cairo_raster_source_release_func_t is the type of function which is
 * called when the pixel data is no longer being access by the pattern
 * for the rendering operation. Typically this function will simply
 * destroy the surface created during acquire.
 *
 * Since: 1.12
 **/
pub type cairo_raster_source_release_func_t =
    ::std::option::Option<unsafe extern "C" fn(pattern: *mut cairo_pattern_t,
                                               callback_data:
                                                   *mut libc::c_void,
                                               surface:
                                                   *mut cairo_surface_t)>;
/**
 * cairo_raster_source_snapshot_func_t:
 * @pattern: the pattern being rendered from
 * @callback_data: the user data supplied during creation
 *
 * #cairo_raster_source_snapshot_func_t is the type of function which is
 * called when the pixel data needs to be preserved for later use
 * during printing. This pattern will be accessed again later, and it
 * is expected to provide the pixel data that was current at the time
 * of snapshotting.
 *
 * Return value: CAIRO_STATUS_SUCCESS on success, or one of the
 * #cairo_status_t error codes for failure.
 *
 * Since: 1.12
 **/
pub type cairo_raster_source_snapshot_func_t =
    ::std::option::Option<unsafe extern "C" fn(pattern: *mut cairo_pattern_t,
                                               callback_data:
                                                   *mut libc::c_void)
                              -> _cairo_status>;
/**
 * cairo_raster_source_copy_func_t:
 * @pattern: the #cairo_pattern_t that was copied to
 * @callback_data: the user data supplied during creation
 * @other: the #cairo_pattern_t being used as the source for the copy
 *
 * #cairo_raster_source_copy_func_t is the type of function which is
 * called when the pattern gets copied as a normal part of rendering.
 *
 * Return value: CAIRO_STATUS_SUCCESS on success, or one of the
 * #cairo_status_t error codes for failure.
 *
 * Since: 1.12
 **/
pub type cairo_raster_source_copy_func_t =
    ::std::option::Option<unsafe extern "C" fn(pattern: *mut cairo_pattern_t,
                                               callback_data:
                                                   *mut libc::c_void,
                                               other: *const cairo_pattern_t)
                              -> _cairo_status>;
/**
 * cairo_raster_source_finish_func_t:
 * @pattern: the pattern being rendered from
 * @callback_data: the user data supplied during creation
 *
 * #cairo_raster_source_finish_func_t is the type of function which is
 * called when the pattern (or a copy thereof) is no longer required.
 *
 * Since: 1.12
 **/
pub type cairo_raster_source_finish_func_t =
    ::std::option::Option<unsafe extern "C" fn(pattern: *mut cairo_pattern_t,
                                               callback_data:
                                                   *mut libc::c_void)>;
extern "C" {
    pub fn cairo_pattern_create_raster_source(user_data: *mut libc::c_void,
                                              content: cairo_content_t,
                                              width: libc::c_int,
                                              height: libc::c_int)
     -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_raster_source_pattern_set_callback_data(pattern:
                                                             *mut cairo_pattern_t,
                                                         data:
                                                             *mut libc::c_void);
}
extern "C" {
    pub fn cairo_raster_source_pattern_get_callback_data(pattern:
                                                             *mut cairo_pattern_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn cairo_raster_source_pattern_set_acquire(pattern:
                                                       *mut cairo_pattern_t,
                                                   acquire:
                                                       cairo_raster_source_acquire_func_t,
                                                   release:
                                                       cairo_raster_source_release_func_t);
}
extern "C" {
    pub fn cairo_raster_source_pattern_get_acquire(pattern:
                                                       *mut cairo_pattern_t,
                                                   acquire:
                                                       *mut cairo_raster_source_acquire_func_t,
                                                   release:
                                                       *mut cairo_raster_source_release_func_t);
}
extern "C" {
    pub fn cairo_raster_source_pattern_set_snapshot(pattern:
                                                        *mut cairo_pattern_t,
                                                    snapshot:
                                                        cairo_raster_source_snapshot_func_t);
}
extern "C" {
    pub fn cairo_raster_source_pattern_get_snapshot(pattern:
                                                        *mut cairo_pattern_t)
     -> cairo_raster_source_snapshot_func_t;
}
extern "C" {
    pub fn cairo_raster_source_pattern_set_copy(pattern: *mut cairo_pattern_t,
                                                copy:
                                                    cairo_raster_source_copy_func_t);
}
extern "C" {
    pub fn cairo_raster_source_pattern_get_copy(pattern: *mut cairo_pattern_t)
     -> cairo_raster_source_copy_func_t;
}
extern "C" {
    pub fn cairo_raster_source_pattern_set_finish(pattern:
                                                      *mut cairo_pattern_t,
                                                  finish:
                                                      cairo_raster_source_finish_func_t);
}
extern "C" {
    pub fn cairo_raster_source_pattern_get_finish(pattern:
                                                      *mut cairo_pattern_t)
     -> cairo_raster_source_finish_func_t;
}
extern "C" {
    pub fn cairo_pattern_create_rgb(red: f64, green: f64, blue: f64)
     -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_create_rgba(red: f64, green: f64, blue: f64,
                                     alpha: f64) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_create_for_surface(surface: *mut cairo_surface_t)
     -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_create_linear(x0: f64, y0: f64, x1: f64, y1: f64)
     -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_create_radial(cx0: f64, cy0: f64, radius0: f64,
                                       cx1: f64, cy1: f64, radius1: f64)
     -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_create_mesh() -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_reference(pattern: *mut cairo_pattern_t)
     -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_destroy(pattern: *mut cairo_pattern_t);
}
extern "C" {
    pub fn cairo_pattern_get_reference_count(pattern: *mut cairo_pattern_t)
     -> libc::c_uint;
}
extern "C" {
    pub fn cairo_pattern_status(pattern: *mut cairo_pattern_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_user_data(pattern: *mut cairo_pattern_t,
                                       key: *const cairo_user_data_key_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn cairo_pattern_set_user_data(pattern: *mut cairo_pattern_t,
                                       key: *const cairo_user_data_key_t,
                                       user_data: *mut libc::c_void,
                                       destroy: cairo_destroy_func_t)
     -> cairo_status_t;
}
#[repr(u32)]
/**
 * cairo_pattern_type_t:
 * @CAIRO_PATTERN_TYPE_SOLID: The pattern is a solid (uniform)
 * color. It may be opaque or translucent, since 1.2.
 * @CAIRO_PATTERN_TYPE_SURFACE: The pattern is a based on a surface (an image), since 1.2.
 * @CAIRO_PATTERN_TYPE_LINEAR: The pattern is a linear gradient, since 1.2.
 * @CAIRO_PATTERN_TYPE_RADIAL: The pattern is a radial gradient, since 1.2.
 * @CAIRO_PATTERN_TYPE_MESH: The pattern is a mesh, since 1.12.
 * @CAIRO_PATTERN_TYPE_RASTER_SOURCE: The pattern is a user pattern providing raster data, since 1.12.
 *
 * #cairo_pattern_type_t is used to describe the type of a given pattern.
 *
 * The type of a pattern is determined by the function used to create
 * it. The cairo_pattern_create_rgb() and cairo_pattern_create_rgba()
 * functions create SOLID patterns. The remaining
 * cairo_pattern_create<!-- --> functions map to pattern types in obvious
 * ways.
 *
 * The pattern type can be queried with cairo_pattern_get_type()
 *
 * Most #cairo_pattern_t functions can be called with a pattern of any
 * type, (though trying to change the extend or filter for a solid
 * pattern will have no effect). A notable exception is
 * cairo_pattern_add_color_stop_rgb() and
 * cairo_pattern_add_color_stop_rgba() which must only be called with
 * gradient patterns (either LINEAR or RADIAL). Otherwise the pattern
 * will be shutdown and put into an error state.
 *
 * New entries may be added in future versions.
 *
 * Since: 1.2
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_pattern_type {
    CAIRO_PATTERN_TYPE_SOLID = 0,
    CAIRO_PATTERN_TYPE_SURFACE = 1,
    CAIRO_PATTERN_TYPE_LINEAR = 2,
    CAIRO_PATTERN_TYPE_RADIAL = 3,
    CAIRO_PATTERN_TYPE_MESH = 4,
    CAIRO_PATTERN_TYPE_RASTER_SOURCE = 5,
}
pub use self::_cairo_pattern_type as cairo_pattern_type_t;
extern "C" {
    pub fn cairo_pattern_get_type(pattern: *mut cairo_pattern_t)
     -> cairo_pattern_type_t;
}
extern "C" {
    pub fn cairo_pattern_add_color_stop_rgb(pattern: *mut cairo_pattern_t,
                                            offset: f64, red: f64, green: f64,
                                            blue: f64);
}
extern "C" {
    pub fn cairo_pattern_add_color_stop_rgba(pattern: *mut cairo_pattern_t,
                                             offset: f64, red: f64,
                                             green: f64, blue: f64,
                                             alpha: f64);
}
extern "C" {
    pub fn cairo_mesh_pattern_begin_patch(pattern: *mut cairo_pattern_t);
}
extern "C" {
    pub fn cairo_mesh_pattern_end_patch(pattern: *mut cairo_pattern_t);
}
extern "C" {
    pub fn cairo_mesh_pattern_curve_to(pattern: *mut cairo_pattern_t, x1: f64,
                                       y1: f64, x2: f64, y2: f64, x3: f64,
                                       y3: f64);
}
extern "C" {
    pub fn cairo_mesh_pattern_line_to(pattern: *mut cairo_pattern_t, x: f64,
                                      y: f64);
}
extern "C" {
    pub fn cairo_mesh_pattern_move_to(pattern: *mut cairo_pattern_t, x: f64,
                                      y: f64);
}
extern "C" {
    pub fn cairo_mesh_pattern_set_control_point(pattern: *mut cairo_pattern_t,
                                                point_num: libc::c_uint,
                                                x: f64, y: f64);
}
extern "C" {
    pub fn cairo_mesh_pattern_set_corner_color_rgb(pattern:
                                                       *mut cairo_pattern_t,
                                                   corner_num: libc::c_uint,
                                                   red: f64, green: f64,
                                                   blue: f64);
}
extern "C" {
    pub fn cairo_mesh_pattern_set_corner_color_rgba(pattern:
                                                        *mut cairo_pattern_t,
                                                    corner_num: libc::c_uint,
                                                    red: f64, green: f64,
                                                    blue: f64, alpha: f64);
}
extern "C" {
    pub fn cairo_pattern_set_matrix(pattern: *mut cairo_pattern_t,
                                    matrix: *const cairo_matrix_t);
}
extern "C" {
    pub fn cairo_pattern_get_matrix(pattern: *mut cairo_pattern_t,
                                    matrix: *mut cairo_matrix_t);
}
#[repr(u32)]
/**
 * cairo_extend_t:
 * @CAIRO_EXTEND_NONE: pixels outside of the source pattern
 *   are fully transparent (Since 1.0)
 * @CAIRO_EXTEND_REPEAT: the pattern is tiled by repeating (Since 1.0)
 * @CAIRO_EXTEND_REFLECT: the pattern is tiled by reflecting
 *   at the edges (Since 1.0; but only implemented for surface patterns since 1.6)
 * @CAIRO_EXTEND_PAD: pixels outside of the pattern copy
 *   the closest pixel from the source (Since 1.2; but only
 *   implemented for surface patterns since 1.6)
 *
 * #cairo_extend_t is used to describe how pattern color/alpha will be
 * determined for areas "outside" the pattern's natural area, (for
 * example, outside the surface bounds or outside the gradient
 * geometry).
 *
 * Mesh patterns are not affected by the extend mode.
 *
 * The default extend mode is %CAIRO_EXTEND_NONE for surface patterns
 * and %CAIRO_EXTEND_PAD for gradient patterns.
 *
 * New entries may be added in future versions.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_extend {
    CAIRO_EXTEND_NONE = 0,
    CAIRO_EXTEND_REPEAT = 1,
    CAIRO_EXTEND_REFLECT = 2,
    CAIRO_EXTEND_PAD = 3,
}
pub use self::_cairo_extend as cairo_extend_t;
extern "C" {
    pub fn cairo_pattern_set_extend(pattern: *mut cairo_pattern_t,
                                    extend: cairo_extend_t);
}
extern "C" {
    pub fn cairo_pattern_get_extend(pattern: *mut cairo_pattern_t)
     -> cairo_extend_t;
}
#[repr(u32)]
/**
 * cairo_filter_t:
 * @CAIRO_FILTER_FAST: A high-performance filter, with quality similar
 *     to %CAIRO_FILTER_NEAREST (Since 1.0)
 * @CAIRO_FILTER_GOOD: A reasonable-performance filter, with quality
 *     similar to %CAIRO_FILTER_BILINEAR (Since 1.0)
 * @CAIRO_FILTER_BEST: The highest-quality available, performance may
 *     not be suitable for interactive use. (Since 1.0)
 * @CAIRO_FILTER_NEAREST: Nearest-neighbor filtering (Since 1.0)
 * @CAIRO_FILTER_BILINEAR: Linear interpolation in two dimensions (Since 1.0)
 * @CAIRO_FILTER_GAUSSIAN: This filter value is currently
 *     unimplemented, and should not be used in current code. (Since 1.0)
 *
 * #cairo_filter_t is used to indicate what filtering should be
 * applied when reading pixel values from patterns. See
 * cairo_pattern_set_filter() for indicating the desired filter to be
 * used with a particular pattern.
 *
 * Since: 1.0
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_filter {
    CAIRO_FILTER_FAST = 0,
    CAIRO_FILTER_GOOD = 1,
    CAIRO_FILTER_BEST = 2,
    CAIRO_FILTER_NEAREST = 3,
    CAIRO_FILTER_BILINEAR = 4,
    CAIRO_FILTER_GAUSSIAN = 5,
}
pub use self::_cairo_filter as cairo_filter_t;
extern "C" {
    pub fn cairo_pattern_set_filter(pattern: *mut cairo_pattern_t,
                                    filter: cairo_filter_t);
}
extern "C" {
    pub fn cairo_pattern_get_filter(pattern: *mut cairo_pattern_t)
     -> cairo_filter_t;
}
extern "C" {
    pub fn cairo_pattern_get_rgba(pattern: *mut cairo_pattern_t,
                                  red: *mut f64, green: *mut f64,
                                  blue: *mut f64, alpha: *mut f64)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_surface(pattern: *mut cairo_pattern_t,
                                     surface: *mut *mut cairo_surface_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_color_stop_rgba(pattern: *mut cairo_pattern_t,
                                             index: libc::c_int,
                                             offset: *mut f64, red: *mut f64,
                                             green: *mut f64, blue: *mut f64,
                                             alpha: *mut f64)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_color_stop_count(pattern: *mut cairo_pattern_t,
                                              count: *mut libc::c_int)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_linear_points(pattern: *mut cairo_pattern_t,
                                           x0: *mut f64, y0: *mut f64,
                                           x1: *mut f64, y1: *mut f64)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_radial_circles(pattern: *mut cairo_pattern_t,
                                            x0: *mut f64, y0: *mut f64,
                                            r0: *mut f64, x1: *mut f64,
                                            y1: *mut f64, r1: *mut f64)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_mesh_pattern_get_patch_count(pattern: *mut cairo_pattern_t,
                                              count: *mut libc::c_uint)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_mesh_pattern_get_path(pattern: *mut cairo_pattern_t,
                                       patch_num: libc::c_uint)
     -> *mut cairo_path_t;
}
extern "C" {
    pub fn cairo_mesh_pattern_get_corner_color_rgba(pattern:
                                                        *mut cairo_pattern_t,
                                                    patch_num: libc::c_uint,
                                                    corner_num: libc::c_uint,
                                                    red: *mut f64,
                                                    green: *mut f64,
                                                    blue: *mut f64,
                                                    alpha: *mut f64)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_mesh_pattern_get_control_point(pattern: *mut cairo_pattern_t,
                                                patch_num: libc::c_uint,
                                                point_num: libc::c_uint,
                                                x: *mut f64, y: *mut f64)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_matrix_init(matrix: *mut cairo_matrix_t, xx: f64, yx: f64,
                             xy: f64, yy: f64, x0: f64, y0: f64);
}
extern "C" {
    pub fn cairo_matrix_init_identity(matrix: *mut cairo_matrix_t);
}
extern "C" {
    pub fn cairo_matrix_init_translate(matrix: *mut cairo_matrix_t, tx: f64,
                                       ty: f64);
}
extern "C" {
    pub fn cairo_matrix_init_scale(matrix: *mut cairo_matrix_t, sx: f64,
                                   sy: f64);
}
extern "C" {
    pub fn cairo_matrix_init_rotate(matrix: *mut cairo_matrix_t,
                                    radians: f64);
}
extern "C" {
    pub fn cairo_matrix_translate(matrix: *mut cairo_matrix_t, tx: f64,
                                  ty: f64);
}
extern "C" {
    pub fn cairo_matrix_scale(matrix: *mut cairo_matrix_t, sx: f64, sy: f64);
}
extern "C" {
    pub fn cairo_matrix_rotate(matrix: *mut cairo_matrix_t, radians: f64);
}
extern "C" {
    pub fn cairo_matrix_invert(matrix: *mut cairo_matrix_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_matrix_multiply(result: *mut cairo_matrix_t,
                                 a: *const cairo_matrix_t,
                                 b: *const cairo_matrix_t);
}
extern "C" {
    pub fn cairo_matrix_transform_distance(matrix: *const cairo_matrix_t,
                                           dx: *mut f64, dy: *mut f64);
}
extern "C" {
    pub fn cairo_matrix_transform_point(matrix: *const cairo_matrix_t,
                                        x: *mut f64, y: *mut f64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_region([u8; 0]);
/**
 * cairo_region_t:
 *
 * A #cairo_region_t represents a set of integer-aligned rectangles.
 *
 * It allows set-theoretical operations like cairo_region_union() and
 * cairo_region_intersect() to be performed on them.
 *
 * Memory management of #cairo_region_t is done with
 * cairo_region_reference() and cairo_region_destroy().
 *
 * Since: 1.10
 **/
pub type cairo_region_t = _cairo_region;
#[repr(u32)]
/**
 * cairo_region_overlap_t:
 * @CAIRO_REGION_OVERLAP_IN: The contents are entirely inside the region. (Since 1.10)
 * @CAIRO_REGION_OVERLAP_OUT: The contents are entirely outside the region. (Since 1.10)
 * @CAIRO_REGION_OVERLAP_PART: The contents are partially inside and
 *     partially outside the region. (Since 1.10)
 *
 * Used as the return value for cairo_region_contains_rectangle().
 *
 * Since: 1.10
 **/
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _cairo_region_overlap {
    CAIRO_REGION_OVERLAP_IN = 0,
    CAIRO_REGION_OVERLAP_OUT = 1,
    CAIRO_REGION_OVERLAP_PART = 2,
}
pub use self::_cairo_region_overlap as cairo_region_overlap_t;
extern "C" {
    pub fn cairo_region_create() -> *mut cairo_region_t;
}
extern "C" {
    pub fn cairo_region_create_rectangle(rectangle:
                                             *const cairo_rectangle_int_t)
     -> *mut cairo_region_t;
}
extern "C" {
    pub fn cairo_region_create_rectangles(rects: *const cairo_rectangle_int_t,
                                          count: libc::c_int)
     -> *mut cairo_region_t;
}
extern "C" {
    pub fn cairo_region_copy(original: *const cairo_region_t)
     -> *mut cairo_region_t;
}
extern "C" {
    pub fn cairo_region_reference(region: *mut cairo_region_t)
     -> *mut cairo_region_t;
}
extern "C" {
    pub fn cairo_region_destroy(region: *mut cairo_region_t);
}
extern "C" {
    pub fn cairo_region_equal(a: *const cairo_region_t,
                              b: *const cairo_region_t) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_region_status(region: *const cairo_region_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_get_extents(region: *const cairo_region_t,
                                    extents: *mut cairo_rectangle_int_t);
}
extern "C" {
    pub fn cairo_region_num_rectangles(region: *const cairo_region_t)
     -> libc::c_int;
}
extern "C" {
    pub fn cairo_region_get_rectangle(region: *const cairo_region_t,
                                      nth: libc::c_int,
                                      rectangle: *mut cairo_rectangle_int_t);
}
extern "C" {
    pub fn cairo_region_is_empty(region: *const cairo_region_t)
     -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_region_contains_rectangle(region: *const cairo_region_t,
                                           rectangle:
                                               *const cairo_rectangle_int_t)
     -> cairo_region_overlap_t;
}
extern "C" {
    pub fn cairo_region_contains_point(region: *const cairo_region_t,
                                       x: libc::c_int, y: libc::c_int)
     -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_region_translate(region: *mut cairo_region_t,
                                  dx: libc::c_int, dy: libc::c_int);
}
extern "C" {
    pub fn cairo_region_subtract(dst: *mut cairo_region_t,
                                 other: *const cairo_region_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_subtract_rectangle(dst: *mut cairo_region_t,
                                           rectangle:
                                               *const cairo_rectangle_int_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_intersect(dst: *mut cairo_region_t,
                                  other: *const cairo_region_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_intersect_rectangle(dst: *mut cairo_region_t,
                                            rectangle:
                                                *const cairo_rectangle_int_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_union(dst: *mut cairo_region_t,
                              other: *const cairo_region_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_union_rectangle(dst: *mut cairo_region_t,
                                        rectangle:
                                            *const cairo_rectangle_int_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_xor(dst: *mut cairo_region_t,
                            other: *const cairo_region_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_xor_rectangle(dst: *mut cairo_region_t,
                                      rectangle: *const cairo_rectangle_int_t)
     -> cairo_status_t;
}
extern "C" {
    pub fn cairo_debug_reset_static_data();
}
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_char;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_6 {
    pub __val: [libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_6>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_6>() , 4usize);
}
impl Clone for _bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
pub type __fsid_t = _bindgen_ty_6;
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type u_int8_t = libc::c_uchar;
pub type u_int16_t = libc::c_ushort;
pub type u_int32_t = libc::c_uint;
pub type u_int64_t = libc::c_ulong;
pub type register_t = libc::c_long;
pub type __sig_atomic_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_7 {
    pub __val: [libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_7>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_7>() , 8usize);
}
impl Clone for _bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = _bindgen_ty_7;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize);
    assert_eq!(::std::mem::align_of::<timeval>() , 8usize);
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize);
    assert_eq!(::std::mem::align_of::<timespec>() , 8usize);
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_8 {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_8>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_8>() , 8usize);
}
impl Clone for _bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
pub type fd_set = _bindgen_ty_8;
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: libc::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> libc::c_int;
}
extern "C" {
    pub fn pselect(__nfds: libc::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> libc::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> libc::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> libc::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: libc::c_uint, __minor: libc::c_uint)
     -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = libc::c_ulong;
#[repr(C)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize);
    assert_eq!(::std::mem::align_of::<pthread_attr_t>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize);
    assert_eq!(::std::mem::align_of::<__pthread_internal_list>() , 8usize);
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
pub union _bindgen_ty_9 {
    pub __data: _bindgen_ty_9___pthread_mutex_s,
    pub __size: [libc::c_char; 40usize],
    pub __align: libc::c_long,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_9___pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_9___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_9___pthread_mutex_s>() ,
               40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_9___pthread_mutex_s>() ,
               8usize);
}
impl Clone for _bindgen_ty_9___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_9>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_9>() , 8usize);
}
pub type pthread_mutex_t = _bindgen_ty_9;
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_10 {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_10>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_10>() , 4usize);
}
impl Clone for _bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_mutexattr_t = _bindgen_ty_10;
#[repr(C)]
pub union _bindgen_ty_11 {
    pub __data: _bindgen_ty_11__bindgen_ty_1,
    pub __size: [libc::c_char; 48usize],
    pub __align: libc::c_longlong,
}
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_11__bindgen_ty_1 {
    pub __bindgen_anon_1: _bindgen_ty_11__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _bindgen_ty_11__bindgen_ty_1__bindgen_ty_2,
    pub __g_refs: [libc::c_uint; 2usize],
    pub __g_size: [libc::c_uint; 2usize],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_11__bindgen_ty_1__bindgen_ty_1 {
    pub __wseq: libc::c_ulonglong,
    pub __wseq32: _bindgen_ty_11__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_11__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_11__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_11__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_11__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _bindgen_ty_11__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_11__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_11__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_11__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _bindgen_ty_11__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_11__bindgen_ty_1__bindgen_ty_2 {
    pub __g1_start: libc::c_ulonglong,
    pub __g1_start32: _bindgen_ty_11__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_11__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_11__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_11__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_11__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _bindgen_ty_11__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_11__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_11__bindgen_ty_1__bindgen_ty_2>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_11__bindgen_ty_1__bindgen_ty_2>()
               , 8usize);
}
impl Clone for _bindgen_ty_11__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_11__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_11__bindgen_ty_1>() ,
               48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_11__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_11__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_11() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_11>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_11>() , 8usize);
}
pub type pthread_cond_t = _bindgen_ty_11;
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_12 {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_12>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_12>() , 4usize);
}
impl Clone for _bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_condattr_t = _bindgen_ty_12;
pub type pthread_key_t = libc::c_uint;
pub type pthread_once_t = libc::c_int;
#[repr(C)]
pub union _bindgen_ty_13 {
    pub __data: _bindgen_ty_13__bindgen_ty_1,
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_13__bindgen_ty_1 {
    pub __readers: libc::c_uint,
    pub __writers: libc::c_uint,
    pub __wrphase_futex: libc::c_uint,
    pub __writers_futex: libc::c_uint,
    pub __pad3: libc::c_uint,
    pub __pad4: libc::c_uint,
    pub __cur_writer: libc::c_int,
    pub __shared: libc::c_int,
    pub __rwelision: libc::c_char,
    pub __pad1: [libc::c_uchar; 7usize],
    pub __pad2: libc::c_ulong,
    pub __flags: libc::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_13__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_13__bindgen_ty_1>() ,
               56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_13__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_13__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_13() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_13>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_13>() , 8usize);
}
pub type pthread_rwlock_t = _bindgen_ty_13;
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_14 {
    pub __size: [libc::c_char; 8usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_14>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_14>() , 8usize);
}
impl Clone for _bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_rwlockattr_t = _bindgen_ty_14;
pub type pthread_spinlock_t = libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_15 {
    pub __size: [libc::c_char; 32usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_15>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_15>() , 8usize);
}
impl Clone for _bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_barrier_t = _bindgen_ty_15;
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_16 {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_16>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_16>() , 4usize);
}
impl Clone for _bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_barrierattr_t = _bindgen_ty_16;
pub type int_least8_t = libc::c_char;
pub type int_least16_t = libc::c_short;
pub type int_least32_t = libc::c_int;
pub type int_least64_t = libc::c_long;
pub type uint_least8_t = libc::c_uchar;
pub type uint_least16_t = libc::c_ushort;
pub type uint_least32_t = libc::c_uint;
pub type uint_least64_t = libc::c_ulong;
pub type int_fast8_t = libc::c_char;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut libc::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::std::mem::size_of::<iovec>() , 16usize);
    assert_eq!(::std::mem::align_of::<iovec>() , 8usize);
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn readv(__fd: libc::c_int, __iovec: *const iovec,
                 __count: libc::c_int) -> isize;
}
extern "C" {
    pub fn writev(__fd: libc::c_int, __iovec: *const iovec,
                  __count: libc::c_int) -> isize;
}
extern "C" {
    pub fn preadv(__fd: libc::c_int, __iovec: *const iovec,
                  __count: libc::c_int, __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pwritev(__fd: libc::c_int, __iovec: *const iovec,
                   __count: libc::c_int, __offset: __off_t) -> isize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sched_param {
    pub __sched_priority: libc::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(::std::mem::size_of::<sched_param>() , 4usize);
    assert_eq!(::std::mem::align_of::<sched_param>() , 4usize);
}
impl Clone for sched_param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sched_param {
    pub __sched_priority: libc::c_int,
}
#[test]
fn bindgen_test_layout___sched_param() {
    assert_eq!(::std::mem::size_of::<__sched_param>() , 4usize);
    assert_eq!(::std::mem::align_of::<__sched_param>() , 4usize);
}
impl Clone for __sched_param {
    fn clone(&self) -> Self { *self }
}
pub type __cpu_mask = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_17 {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_17>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_17>() , 8usize);
}
impl Clone for _bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
pub type cpu_set_t = _bindgen_ty_17;
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t)
     -> libc::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param)
     -> libc::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param)
     -> libc::c_int;
}
extern "C" {
    pub fn sched_setscheduler(__pid: __pid_t, __policy: libc::c_int,
                              __param: *const sched_param) -> libc::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> libc::c_int;
}
extern "C" {
    pub fn sched_yield() -> libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec)
     -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize);
    assert_eq!(::std::mem::align_of::<tm>() , 8usize);
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize);
    assert_eq!(::std::mem::align_of::<itimerspec>() , 8usize);
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_struct___locale_data; 13usize],
    pub __ctype_b: *const libc::c_ushort,
    pub __ctype_tolower: *const libc::c_int,
    pub __ctype_toupper: *const libc::c_int,
    pub __names: [*const libc::c_char; 13usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct___locale_data([u8; 0]);
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize);
    assert_eq!(::std::mem::align_of::<__locale_struct>() , 8usize);
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(__s: *mut libc::c_char, __maxsize: usize,
                    __format: *const libc::c_char, __tp: *const tm) -> usize;
}
extern "C" {
    pub fn strftime_l(__s: *mut libc::c_char, __maxsize: usize,
                      __format: *const libc::c_char, __tp: *const tm,
                      __loc: __locale_t) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    #[link_name = "__tzname"]
    pub static mut __tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    #[link_name = "__daylight"]
    pub static mut __daylight: libc::c_int;
}
extern "C" {
    #[link_name = "__timezone"]
    pub static mut __timezone: libc::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: libc::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: libc::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> libc::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec,
                     __remaining: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_nanosleep(__clock_id: clockid_t, __flags: libc::c_int,
                           __req: *const timespec, __rem: *mut timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> libc::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent,
                        __timerid: *mut timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timer_settime(__timerid: timer_t, __flags: libc::c_int,
                         __value: *const itimerspec,
                         __ovalue: *mut itimerspec) -> libc::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec)
     -> libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> libc::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: libc::c_int)
     -> libc::c_int;
}
pub type __jmp_buf = [libc::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_18 =
    _bindgen_ty_18::PTHREAD_CREATE_JOINABLE;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_18 =
    _bindgen_ty_18::PTHREAD_CREATE_DETACHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_18 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1,
}
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_19 =
    _bindgen_ty_19::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_19 =
    _bindgen_ty_19::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_19 =
    _bindgen_ty_19::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_19 =
    _bindgen_ty_19::PTHREAD_MUTEX_ADAPTIVE_NP;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_19 =
    _bindgen_ty_19::PTHREAD_MUTEX_TIMED_NP;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_19 =
    _bindgen_ty_19::PTHREAD_MUTEX_RECURSIVE_NP;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_19 =
    _bindgen_ty_19::PTHREAD_MUTEX_ERRORCHECK_NP;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_19 =
    _bindgen_ty_19::PTHREAD_MUTEX_TIMED_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_19 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
}
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_20 =
    _bindgen_ty_20::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_20 =
    _bindgen_ty_20::PTHREAD_MUTEX_STALLED;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_20 =
    _bindgen_ty_20::PTHREAD_MUTEX_ROBUST;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_20 =
    _bindgen_ty_20::PTHREAD_MUTEX_ROBUST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_20 {
    PTHREAD_MUTEX_STALLED = 0,
    PTHREAD_MUTEX_ROBUST = 1,
}
pub const PTHREAD_PRIO_NONE: _bindgen_ty_21 =
    _bindgen_ty_21::PTHREAD_PRIO_NONE;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_21 =
    _bindgen_ty_21::PTHREAD_PRIO_INHERIT;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_21 =
    _bindgen_ty_21::PTHREAD_PRIO_PROTECT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_21 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2,
}
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_22 =
    _bindgen_ty_22::PTHREAD_RWLOCK_PREFER_READER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_22 =
    _bindgen_ty_22::PTHREAD_RWLOCK_PREFER_WRITER_NP;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_22 =
    _bindgen_ty_22::PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_22 =
    _bindgen_ty_22::PTHREAD_RWLOCK_PREFER_READER_NP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_22 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
}
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_23 =
    _bindgen_ty_23::PTHREAD_INHERIT_SCHED;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_23 =
    _bindgen_ty_23::PTHREAD_EXPLICIT_SCHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_23 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1,
}
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_24 =
    _bindgen_ty_24::PTHREAD_SCOPE_SYSTEM;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_24 =
    _bindgen_ty_24::PTHREAD_SCOPE_PROCESS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_24 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1,
}
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_25 =
    _bindgen_ty_25::PTHREAD_PROCESS_PRIVATE;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_25 =
    _bindgen_ty_25::PTHREAD_PROCESS_SHARED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_25 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut libc::c_void)>,
    pub __arg: *mut libc::c_void,
    pub __canceltype: libc::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(::std::mem::size_of::<_pthread_cleanup_buffer>() , 32usize);
    assert_eq!(::std::mem::align_of::<_pthread_cleanup_buffer>() , 8usize);
}
impl Clone for _pthread_cleanup_buffer {
    fn clone(&self) -> Self { *self }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_26 =
    _bindgen_ty_26::PTHREAD_CANCEL_ENABLE;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_26 =
    _bindgen_ty_26::PTHREAD_CANCEL_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_26 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1,
}
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_27 =
    _bindgen_ty_27::PTHREAD_CANCEL_DEFERRED;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_27 =
    _bindgen_ty_27::PTHREAD_CANCEL_ASYNCHRONOUS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_27 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1,
}
extern "C" {
    pub fn pthread_create(__newthread: *mut pthread_t,
                          __attr: *const pthread_attr_t,
                          __start_routine:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut libc::c_void)
                                                        -> *mut libc::c_void>,
                          __arg: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut libc::c_void);
}
extern "C" {
    pub fn pthread_join(__th: pthread_t,
                        __thread_return: *mut *mut libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(__attr: *const pthread_attr_t,
                                       __detachstate: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(__attr: *mut pthread_attr_t,
                                       __detachstate: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(__attr: *const pthread_attr_t,
                                     __guardsize: *mut usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(__attr: *mut pthread_attr_t,
                                     __guardsize: usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(__attr: *const pthread_attr_t,
                                      __param: *mut sched_param)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(__attr: *mut pthread_attr_t,
                                      __param: *const sched_param)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(__attr: *const pthread_attr_t,
                                       __policy: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(__attr: *mut pthread_attr_t,
                                       __policy: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(__attr: *const pthread_attr_t,
                                        __inherit: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(__attr: *mut pthread_attr_t,
                                        __inherit: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(__attr: *const pthread_attr_t,
                                 __scope: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t,
                                 __scope: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(__attr: *const pthread_attr_t,
                                     __stackaddr: *mut *mut libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(__attr: *mut pthread_attr_t,
                                     __stackaddr: *mut libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(__attr: *const pthread_attr_t,
                                     __stacksize: *mut usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(__attr: *mut pthread_attr_t,
                                     __stacksize: usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(__attr: *const pthread_attr_t,
                                 __stackaddr: *mut *mut libc::c_void,
                                 __stacksize: *mut usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(__attr: *mut pthread_attr_t,
                                 __stackaddr: *mut libc::c_void,
                                 __stacksize: usize) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(__target_thread: pthread_t,
                                 __policy: libc::c_int,
                                 __param: *const sched_param) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(__target_thread: pthread_t,
                                 __policy: *mut libc::c_int,
                                 __param: *mut sched_param) -> libc::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t,
                                __prio: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_once(__once_control: *mut pthread_once_t,
                        __init_routine:
                            ::std::option::Option<unsafe extern "C" fn()>)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(__state: libc::c_int,
                                  __oldstate: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(__type: libc::c_int,
                                 __oldtype: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_28 {
    pub __cancel_jmp_buf: [_bindgen_ty_28__bindgen_ty_1; 1usize],
    pub __pad: [*mut libc::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_28__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_28__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_28__bindgen_ty_1>() ,
               72usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_28__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_28__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_28() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_28>() , 104usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_28>() , 8usize);
}
impl Clone for _bindgen_ty_28 {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_unwind_buf_t = _bindgen_ty_28;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut libc::c_void)>,
    pub __cancel_arg: *mut libc::c_void,
    pub __do_it: libc::c_int,
    pub __cancel_type: libc::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(::std::mem::size_of::<__pthread_cleanup_frame>() , 24usize);
    assert_eq!(::std::mem::align_of::<__pthread_cleanup_frame>() , 8usize);
}
impl Clone for __pthread_cleanup_frame {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag([u8; 0]);
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(__mutex: *mut pthread_mutex_t,
                              __mutexattr: *const pthread_mutexattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(__mutex: *mut pthread_mutex_t,
                                   __abstime: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(__mutex: *const pthread_mutex_t,
                                        __prioceiling: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(__mutex: *mut pthread_mutex_t,
                                        __prioceiling: libc::c_int,
                                        __old_ceiling: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(__attr: *const pthread_mutexattr_t,
                                        __pshared: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(__attr: *mut pthread_mutexattr_t,
                                        __pshared: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(__attr: *const pthread_mutexattr_t,
                                     __kind: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(__attr: *mut pthread_mutexattr_t,
                                     __kind: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(__attr: *const pthread_mutexattr_t,
                                         __protocol: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(__attr: *mut pthread_mutexattr_t,
                                         __protocol: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(__attr:
                                                *const pthread_mutexattr_t,
                                            __prioceiling: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(__attr: *mut pthread_mutexattr_t,
                                            __prioceiling: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(__attr: *const pthread_mutexattr_t,
                                       __robustness: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(__attr: *mut pthread_mutexattr_t,
                                       __robustness: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(__rwlock: *mut pthread_rwlock_t,
                               __attr: *const pthread_rwlockattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(__rwlock: *mut pthread_rwlock_t,
                                      __abstime: *const timespec)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(__attr: *const pthread_rwlockattr_t,
                                         __pshared: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(__attr: *mut pthread_rwlockattr_t,
                                         __pshared: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(__attr: *const pthread_rwlockattr_t,
                                         __pref: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(__attr: *mut pthread_rwlockattr_t,
                                         __pref: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_init(__cond: *mut pthread_cond_t,
                             __cond_attr: *const pthread_condattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(__cond: *mut pthread_cond_t,
                             __mutex: *mut pthread_mutex_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(__cond: *mut pthread_cond_t,
                                  __mutex: *mut pthread_mutex_t,
                                  __abstime: *const timespec) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(__attr: *const pthread_condattr_t,
                                       __pshared: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(__attr: *mut pthread_condattr_t,
                                       __pshared: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(__attr: *const pthread_condattr_t,
                                     __clock_id: *mut __clockid_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(__attr: *mut pthread_condattr_t,
                                     __clock_id: __clockid_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_init(__lock: *mut pthread_spinlock_t,
                             __pshared: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(__barrier: *mut pthread_barrier_t,
                                __attr: *const pthread_barrierattr_t,
                                __count: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(__attr:
                                              *const pthread_barrierattr_t,
                                          __pshared: *mut libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(__attr: *mut pthread_barrierattr_t,
                                          __pshared: libc::c_int)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_key_create(__key: *mut pthread_key_t,
                              __destr_function:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut libc::c_void)>)
     -> libc::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn pthread_setspecific(__key: pthread_key_t,
                               __pointer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(__thread_id: pthread_t,
                                 __clock_id: *mut __clockid_t) -> libc::c_int;
}
extern "C" {
    pub fn pthread_atfork(__prepare:
                              ::std::option::Option<unsafe extern "C" fn()>,
                          __parent:
                              ::std::option::Option<unsafe extern "C" fn()>,
                          __child:
                              ::std::option::Option<unsafe extern "C" fn()>)
     -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_connection_t([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_29 {
    pub data: *mut libc::c_void,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_29() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_29>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_29>() , 8usize);
}
impl Clone for _bindgen_ty_29 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_generic_iterator_t = _bindgen_ty_29;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_30 {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_30() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_30>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_30>() , 4usize);
}
impl Clone for _bindgen_ty_30 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_generic_reply_t = _bindgen_ty_30;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_31 {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub pad: [u32; 7usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_31() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_31>() , 36usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_31>() , 4usize);
}
impl Clone for _bindgen_ty_31 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_generic_event_t = _bindgen_ty_31;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_32 {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad1: u16,
    pub pad: [u32; 5usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_32() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_32>() , 36usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_32>() , 4usize);
}
impl Clone for _bindgen_ty_32 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_ge_event_t = _bindgen_ty_32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_33 {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub resource_id: u32,
    pub minor_code: u16,
    pub major_code: u8,
    pub pad0: u8,
    pub pad: [u32; 5usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_33() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_33>() , 36usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_33>() , 4usize);
}
impl Clone for _bindgen_ty_33 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_generic_error_t = _bindgen_ty_33;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_34 {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_34() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_34>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_34>() , 4usize);
}
impl Clone for _bindgen_ty_34 {
    fn clone(&self) -> Self { *self }
}
pub type xcb_void_cookie_t = _bindgen_ty_34;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_char2b_t {
    pub byte1: u8,
    pub byte2: u8,
}
#[test]
fn bindgen_test_layout_xcb_char2b_t() {
    assert_eq!(::std::mem::size_of::<xcb_char2b_t>() , 2usize);
    assert_eq!(::std::mem::align_of::<xcb_char2b_t>() , 1usize);
}
impl Clone for xcb_char2b_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_char2b_iterator_t {
    pub data: *mut xcb_char2b_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_char2b_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_char2b_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_char2b_iterator_t>() , 8usize);
}
impl Clone for xcb_char2b_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_window_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_window_iterator_t {
    pub data: *mut xcb_window_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_window_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_window_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_window_iterator_t>() , 8usize);
}
impl Clone for xcb_window_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_pixmap_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_pixmap_iterator_t {
    pub data: *mut xcb_pixmap_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_pixmap_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_pixmap_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_pixmap_iterator_t>() , 8usize);
}
impl Clone for xcb_pixmap_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_cursor_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_cursor_iterator_t {
    pub data: *mut xcb_cursor_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_cursor_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_cursor_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_cursor_iterator_t>() , 8usize);
}
impl Clone for xcb_cursor_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_font_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_font_iterator_t {
    pub data: *mut xcb_font_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_font_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_font_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_font_iterator_t>() , 8usize);
}
impl Clone for xcb_font_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_gcontext_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_gcontext_iterator_t {
    pub data: *mut xcb_gcontext_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_gcontext_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_gcontext_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_gcontext_iterator_t>() , 8usize);
}
impl Clone for xcb_gcontext_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_colormap_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_colormap_iterator_t {
    pub data: *mut xcb_colormap_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_colormap_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_colormap_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_colormap_iterator_t>() , 8usize);
}
impl Clone for xcb_colormap_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_atom_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_atom_iterator_t {
    pub data: *mut xcb_atom_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_atom_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_atom_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_atom_iterator_t>() , 8usize);
}
impl Clone for xcb_atom_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_drawable_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_drawable_iterator_t {
    pub data: *mut xcb_drawable_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_drawable_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_drawable_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_drawable_iterator_t>() , 8usize);
}
impl Clone for xcb_drawable_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_fontable_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fontable_iterator_t {
    pub data: *mut xcb_fontable_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontable_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_fontable_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_fontable_iterator_t>() , 8usize);
}
impl Clone for xcb_fontable_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_bool32_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_bool32_iterator_t {
    pub data: *mut xcb_bool32_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_bool32_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_bool32_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_bool32_iterator_t>() , 8usize);
}
impl Clone for xcb_bool32_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_visualid_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visualid_iterator_t {
    pub data: *mut xcb_visualid_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualid_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_visualid_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_visualid_iterator_t>() , 8usize);
}
impl Clone for xcb_visualid_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_timestamp_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_timestamp_iterator_t {
    pub data: *mut xcb_timestamp_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timestamp_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_timestamp_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_timestamp_iterator_t>() , 8usize);
}
impl Clone for xcb_timestamp_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_keysym_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_keysym_iterator_t {
    pub data: *mut xcb_keysym_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keysym_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_keysym_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_keysym_iterator_t>() , 8usize);
}
impl Clone for xcb_keysym_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_keycode_t = u8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_keycode_iterator_t {
    pub data: *mut xcb_keycode_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_keycode_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_keycode_iterator_t>() , 8usize);
}
impl Clone for xcb_keycode_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_keycode32_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_keycode32_iterator_t {
    pub data: *mut xcb_keycode32_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode32_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_keycode32_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_keycode32_iterator_t>() , 8usize);
}
impl Clone for xcb_keycode32_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_button_t = u8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_button_iterator_t {
    pub data: *mut xcb_button_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_button_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_button_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_button_iterator_t>() , 8usize);
}
impl Clone for xcb_button_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_point_t {
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_point_t() {
    assert_eq!(::std::mem::size_of::<xcb_point_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_point_t>() , 2usize);
}
impl Clone for xcb_point_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_point_iterator_t {
    pub data: *mut xcb_point_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_point_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_point_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_point_iterator_t>() , 8usize);
}
impl Clone for xcb_point_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rectangle_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_t() {
    assert_eq!(::std::mem::size_of::<xcb_rectangle_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_rectangle_t>() , 2usize);
}
impl Clone for xcb_rectangle_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rectangle_iterator_t {
    pub data: *mut xcb_rectangle_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_rectangle_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_rectangle_iterator_t>() , 8usize);
}
impl Clone for xcb_rectangle_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_arc_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub angle1: i16,
    pub angle2: i16,
}
#[test]
fn bindgen_test_layout_xcb_arc_t() {
    assert_eq!(::std::mem::size_of::<xcb_arc_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_arc_t>() , 2usize);
}
impl Clone for xcb_arc_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_arc_iterator_t {
    pub data: *mut xcb_arc_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_arc_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_arc_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_arc_iterator_t>() , 8usize);
}
impl Clone for xcb_arc_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_format_t {
    pub depth: u8,
    pub bits_per_pixel: u8,
    pub scanline_pad: u8,
    pub pad0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_format_t() {
    assert_eq!(::std::mem::size_of::<xcb_format_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_format_t>() , 1usize);
}
impl Clone for xcb_format_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_format_iterator_t {
    pub data: *mut xcb_format_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_format_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_format_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_format_iterator_t>() , 8usize);
}
impl Clone for xcb_format_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_visual_class_t {
    XCB_VISUAL_CLASS_STATIC_GRAY = 0,
    XCB_VISUAL_CLASS_GRAY_SCALE = 1,
    XCB_VISUAL_CLASS_STATIC_COLOR = 2,
    XCB_VISUAL_CLASS_PSEUDO_COLOR = 3,
    XCB_VISUAL_CLASS_TRUE_COLOR = 4,
    XCB_VISUAL_CLASS_DIRECT_COLOR = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visualtype_t {
    pub visual_id: xcb_visualid_t,
    pub _class: u8,
    pub bits_per_rgb_value: u8,
    pub colormap_entries: u16,
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad0: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_visualtype_t() {
    assert_eq!(::std::mem::size_of::<xcb_visualtype_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_visualtype_t>() , 4usize);
}
impl Clone for xcb_visualtype_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visualtype_iterator_t {
    pub data: *mut xcb_visualtype_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualtype_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_visualtype_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_visualtype_iterator_t>() , 8usize);
}
impl Clone for xcb_visualtype_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_depth_t {
    pub depth: u8,
    pub pad0: u8,
    pub visuals_len: u16,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_depth_t() {
    assert_eq!(::std::mem::size_of::<xcb_depth_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_depth_t>() , 2usize);
}
impl Clone for xcb_depth_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_depth_iterator_t {
    pub data: *mut xcb_depth_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_depth_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_depth_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_depth_iterator_t>() , 8usize);
}
impl Clone for xcb_depth_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_event_mask_t {
    XCB_EVENT_MASK_NO_EVENT = 0,
    XCB_EVENT_MASK_KEY_PRESS = 1,
    XCB_EVENT_MASK_KEY_RELEASE = 2,
    XCB_EVENT_MASK_BUTTON_PRESS = 4,
    XCB_EVENT_MASK_BUTTON_RELEASE = 8,
    XCB_EVENT_MASK_ENTER_WINDOW = 16,
    XCB_EVENT_MASK_LEAVE_WINDOW = 32,
    XCB_EVENT_MASK_POINTER_MOTION = 64,
    XCB_EVENT_MASK_POINTER_MOTION_HINT = 128,
    XCB_EVENT_MASK_BUTTON_1_MOTION = 256,
    XCB_EVENT_MASK_BUTTON_2_MOTION = 512,
    XCB_EVENT_MASK_BUTTON_3_MOTION = 1024,
    XCB_EVENT_MASK_BUTTON_4_MOTION = 2048,
    XCB_EVENT_MASK_BUTTON_5_MOTION = 4096,
    XCB_EVENT_MASK_BUTTON_MOTION = 8192,
    XCB_EVENT_MASK_KEYMAP_STATE = 16384,
    XCB_EVENT_MASK_EXPOSURE = 32768,
    XCB_EVENT_MASK_VISIBILITY_CHANGE = 65536,
    XCB_EVENT_MASK_STRUCTURE_NOTIFY = 131072,
    XCB_EVENT_MASK_RESIZE_REDIRECT = 262144,
    XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY = 524288,
    XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT = 1048576,
    XCB_EVENT_MASK_FOCUS_CHANGE = 2097152,
    XCB_EVENT_MASK_PROPERTY_CHANGE = 4194304,
    XCB_EVENT_MASK_COLOR_MAP_CHANGE = 8388608,
    XCB_EVENT_MASK_OWNER_GRAB_BUTTON = 16777216,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_backing_store_t {
    XCB_BACKING_STORE_NOT_USEFUL = 0,
    XCB_BACKING_STORE_WHEN_MAPPED = 1,
    XCB_BACKING_STORE_ALWAYS = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_screen_t {
    pub root: xcb_window_t,
    pub default_colormap: xcb_colormap_t,
    pub white_pixel: u32,
    pub black_pixel: u32,
    pub current_input_masks: u32,
    pub width_in_pixels: u16,
    pub height_in_pixels: u16,
    pub width_in_millimeters: u16,
    pub height_in_millimeters: u16,
    pub min_installed_maps: u16,
    pub max_installed_maps: u16,
    pub root_visual: xcb_visualid_t,
    pub backing_stores: u8,
    pub save_unders: u8,
    pub root_depth: u8,
    pub allowed_depths_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_screen_t() {
    assert_eq!(::std::mem::size_of::<xcb_screen_t>() , 40usize);
    assert_eq!(::std::mem::align_of::<xcb_screen_t>() , 4usize);
}
impl Clone for xcb_screen_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_screen_iterator_t {
    pub data: *mut xcb_screen_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_screen_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_screen_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_screen_iterator_t>() , 8usize);
}
impl Clone for xcb_screen_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_request_t {
    pub byte_order: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub authorization_protocol_name_len: u16,
    pub authorization_protocol_data_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_request_t>() , 2usize);
}
impl Clone for xcb_setup_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_request_iterator_t {
    pub data: *mut xcb_setup_request_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_request_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_request_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_request_iterator_t>() ,
               8usize);
}
impl Clone for xcb_setup_request_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_failed_t {
    pub status: u8,
    pub reason_len: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_failed_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_failed_t>() , 2usize);
}
impl Clone for xcb_setup_failed_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_failed_iterator_t {
    pub data: *mut xcb_setup_failed_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_failed_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_failed_iterator_t>() ,
               8usize);
}
impl Clone for xcb_setup_failed_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_authenticate_t {
    pub status: u8,
    pub pad0: [u8; 5usize],
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_authenticate_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_authenticate_t>() , 2usize);
}
impl Clone for xcb_setup_authenticate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_authenticate_iterator_t {
    pub data: *mut xcb_setup_authenticate_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_authenticate_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_authenticate_iterator_t>() ,
               8usize);
}
impl Clone for xcb_setup_authenticate_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_image_order_t {
    XCB_IMAGE_ORDER_LSB_FIRST = 0,
    XCB_IMAGE_ORDER_MSB_FIRST = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_t {
    pub status: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
    pub release_number: u32,
    pub resource_id_base: u32,
    pub resource_id_mask: u32,
    pub motion_buffer_size: u32,
    pub vendor_len: u16,
    pub maximum_request_length: u16,
    pub roots_len: u8,
    pub pixmap_formats_len: u8,
    pub image_byte_order: u8,
    pub bitmap_format_bit_order: u8,
    pub bitmap_format_scanline_unit: u8,
    pub bitmap_format_scanline_pad: u8,
    pub min_keycode: xcb_keycode_t,
    pub max_keycode: xcb_keycode_t,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_t>() , 40usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_t>() , 4usize);
}
impl Clone for xcb_setup_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_setup_iterator_t {
    pub data: *mut xcb_setup_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_setup_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_setup_iterator_t>() , 8usize);
}
impl Clone for xcb_setup_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_mod_mask_t {
    XCB_MOD_MASK_SHIFT = 1,
    XCB_MOD_MASK_LOCK = 2,
    XCB_MOD_MASK_CONTROL = 4,
    XCB_MOD_MASK_1 = 8,
    XCB_MOD_MASK_2 = 16,
    XCB_MOD_MASK_3 = 32,
    XCB_MOD_MASK_4 = 64,
    XCB_MOD_MASK_5 = 128,
    XCB_MOD_MASK_ANY = 32768,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_key_but_mask_t {
    XCB_KEY_BUT_MASK_SHIFT = 1,
    XCB_KEY_BUT_MASK_LOCK = 2,
    XCB_KEY_BUT_MASK_CONTROL = 4,
    XCB_KEY_BUT_MASK_MOD_1 = 8,
    XCB_KEY_BUT_MASK_MOD_2 = 16,
    XCB_KEY_BUT_MASK_MOD_3 = 32,
    XCB_KEY_BUT_MASK_MOD_4 = 64,
    XCB_KEY_BUT_MASK_MOD_5 = 128,
    XCB_KEY_BUT_MASK_BUTTON_1 = 256,
    XCB_KEY_BUT_MASK_BUTTON_2 = 512,
    XCB_KEY_BUT_MASK_BUTTON_3 = 1024,
    XCB_KEY_BUT_MASK_BUTTON_4 = 2048,
    XCB_KEY_BUT_MASK_BUTTON_5 = 4096,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_window_enum_t { XCB_WINDOW_NONE = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_key_press_event_t {
    pub response_type: u8,
    pub detail: xcb_keycode_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_key_press_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_key_press_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_key_press_event_t>() , 4usize);
}
impl Clone for xcb_key_press_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_key_release_event_t = xcb_key_press_event_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_button_mask_t {
    XCB_BUTTON_MASK_1 = 256,
    XCB_BUTTON_MASK_2 = 512,
    XCB_BUTTON_MASK_3 = 1024,
    XCB_BUTTON_MASK_4 = 2048,
    XCB_BUTTON_MASK_5 = 4096,
    XCB_BUTTON_MASK_ANY = 32768,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_button_press_event_t {
    pub response_type: u8,
    pub detail: xcb_button_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_button_press_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_button_press_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_button_press_event_t>() , 4usize);
}
impl Clone for xcb_button_press_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_button_release_event_t = xcb_button_press_event_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_motion_t { XCB_MOTION_NORMAL = 0, XCB_MOTION_HINT = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_motion_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_motion_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_motion_notify_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_motion_notify_event_t>() , 4usize);
}
impl Clone for xcb_motion_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_notify_detail_t {
    XCB_NOTIFY_DETAIL_ANCESTOR = 0,
    XCB_NOTIFY_DETAIL_VIRTUAL = 1,
    XCB_NOTIFY_DETAIL_INFERIOR = 2,
    XCB_NOTIFY_DETAIL_NONLINEAR = 3,
    XCB_NOTIFY_DETAIL_NONLINEAR_VIRTUAL = 4,
    XCB_NOTIFY_DETAIL_POINTER = 5,
    XCB_NOTIFY_DETAIL_POINTER_ROOT = 6,
    XCB_NOTIFY_DETAIL_NONE = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_notify_mode_t {
    XCB_NOTIFY_MODE_NORMAL = 0,
    XCB_NOTIFY_MODE_GRAB = 1,
    XCB_NOTIFY_MODE_UNGRAB = 2,
    XCB_NOTIFY_MODE_WHILE_GRABBED = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_enter_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub mode: u8,
    pub same_screen_focus: u8,
}
#[test]
fn bindgen_test_layout_xcb_enter_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_enter_notify_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_enter_notify_event_t>() , 4usize);
}
impl Clone for xcb_enter_notify_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_leave_notify_event_t = xcb_enter_notify_event_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_focus_in_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_focus_in_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_focus_in_event_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_focus_in_event_t>() , 4usize);
}
impl Clone for xcb_focus_in_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_focus_out_event_t = xcb_focus_in_event_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_keymap_notify_event_t {
    pub response_type: u8,
    pub keys: [u8; 31usize],
}
#[test]
fn bindgen_test_layout_xcb_keymap_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_keymap_notify_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_keymap_notify_event_t>() , 1usize);
}
impl Clone for xcb_keymap_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_expose_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub count: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_expose_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_expose_event_t>() , 20usize);
    assert_eq!(::std::mem::align_of::<xcb_expose_event_t>() , 4usize);
}
impl Clone for xcb_expose_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_graphics_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub minor_opcode: u16,
    pub count: u16,
    pub major_opcode: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_graphics_exposure_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_graphics_exposure_event_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_graphics_exposure_event_t>() ,
               4usize);
}
impl Clone for xcb_graphics_exposure_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_no_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_no_exposure_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_no_exposure_event_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_no_exposure_event_t>() , 4usize);
}
impl Clone for xcb_no_exposure_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_visibility_t {
    XCB_VISIBILITY_UNOBSCURED = 0,
    XCB_VISIBILITY_PARTIALLY_OBSCURED = 1,
    XCB_VISIBILITY_FULLY_OBSCURED = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_visibility_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_visibility_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_visibility_notify_event_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_visibility_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_visibility_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_create_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_notify_event_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_create_notify_event_t>() , 4usize);
}
impl Clone for xcb_create_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_destroy_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_destroy_notify_event_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_destroy_notify_event_t>() , 4usize);
}
impl Clone for xcb_destroy_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_unmap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub from_configure: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_unmap_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_unmap_notify_event_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_unmap_notify_event_t>() , 4usize);
}
impl Clone for xcb_unmap_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_map_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_notify_event_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_map_notify_event_t>() , 4usize);
}
impl Clone for xcb_map_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_request_event_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_map_request_event_t>() , 4usize);
}
impl Clone for xcb_map_request_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_reparent_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_reparent_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_reparent_notify_event_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_reparent_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_reparent_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_configure_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub above_sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_configure_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_configure_notify_event_t>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<xcb_configure_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_configure_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_configure_request_event_t {
    pub response_type: u8,
    pub stack_mode: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub value_mask: u16,
}
#[test]
fn bindgen_test_layout_xcb_configure_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_configure_request_event_t>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<xcb_configure_request_event_t>() ,
               4usize);
}
impl Clone for xcb_configure_request_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_gravity_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_gravity_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_gravity_notify_event_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_gravity_notify_event_t>() , 4usize);
}
impl Clone for xcb_gravity_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_resize_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_resize_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_resize_request_event_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_resize_request_event_t>() , 4usize);
}
impl Clone for xcb_resize_request_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_place_t { XCB_PLACE_ON_TOP = 0, XCB_PLACE_ON_BOTTOM = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_circulate_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub pad1: [u8; 4usize],
    pub place: u8,
    pub pad2: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_circulate_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_circulate_notify_event_t>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<xcb_circulate_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_circulate_notify_event_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_circulate_request_event_t = xcb_circulate_notify_event_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_property_t {
    XCB_PROPERTY_NEW_VALUE = 0,
    XCB_PROPERTY_DELETE = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_property_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub atom: xcb_atom_t,
    pub time: xcb_timestamp_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_property_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_property_notify_event_t>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<xcb_property_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_property_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_selection_clear_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_clear_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_selection_clear_event_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_selection_clear_event_t>() ,
               4usize);
}
impl Clone for xcb_selection_clear_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_time_t { XCB_TIME_CURRENT_TIME = 0, }
pub const xcb_atom_enum_t_XCB_ATOM_ANY: xcb_atom_enum_t =
    xcb_atom_enum_t::XCB_ATOM_NONE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_atom_enum_t {
    XCB_ATOM_NONE = 0,
    XCB_ATOM_PRIMARY = 1,
    XCB_ATOM_SECONDARY = 2,
    XCB_ATOM_ARC = 3,
    XCB_ATOM_ATOM = 4,
    XCB_ATOM_BITMAP = 5,
    XCB_ATOM_CARDINAL = 6,
    XCB_ATOM_COLORMAP = 7,
    XCB_ATOM_CURSOR = 8,
    XCB_ATOM_CUT_BUFFER0 = 9,
    XCB_ATOM_CUT_BUFFER1 = 10,
    XCB_ATOM_CUT_BUFFER2 = 11,
    XCB_ATOM_CUT_BUFFER3 = 12,
    XCB_ATOM_CUT_BUFFER4 = 13,
    XCB_ATOM_CUT_BUFFER5 = 14,
    XCB_ATOM_CUT_BUFFER6 = 15,
    XCB_ATOM_CUT_BUFFER7 = 16,
    XCB_ATOM_DRAWABLE = 17,
    XCB_ATOM_FONT = 18,
    XCB_ATOM_INTEGER = 19,
    XCB_ATOM_PIXMAP = 20,
    XCB_ATOM_POINT = 21,
    XCB_ATOM_RECTANGLE = 22,
    XCB_ATOM_RESOURCE_MANAGER = 23,
    XCB_ATOM_RGB_COLOR_MAP = 24,
    XCB_ATOM_RGB_BEST_MAP = 25,
    XCB_ATOM_RGB_BLUE_MAP = 26,
    XCB_ATOM_RGB_DEFAULT_MAP = 27,
    XCB_ATOM_RGB_GRAY_MAP = 28,
    XCB_ATOM_RGB_GREEN_MAP = 29,
    XCB_ATOM_RGB_RED_MAP = 30,
    XCB_ATOM_STRING = 31,
    XCB_ATOM_VISUALID = 32,
    XCB_ATOM_WINDOW = 33,
    XCB_ATOM_WM_COMMAND = 34,
    XCB_ATOM_WM_HINTS = 35,
    XCB_ATOM_WM_CLIENT_MACHINE = 36,
    XCB_ATOM_WM_ICON_NAME = 37,
    XCB_ATOM_WM_ICON_SIZE = 38,
    XCB_ATOM_WM_NAME = 39,
    XCB_ATOM_WM_NORMAL_HINTS = 40,
    XCB_ATOM_WM_SIZE_HINTS = 41,
    XCB_ATOM_WM_ZOOM_HINTS = 42,
    XCB_ATOM_MIN_SPACE = 43,
    XCB_ATOM_NORM_SPACE = 44,
    XCB_ATOM_MAX_SPACE = 45,
    XCB_ATOM_END_SPACE = 46,
    XCB_ATOM_SUPERSCRIPT_X = 47,
    XCB_ATOM_SUPERSCRIPT_Y = 48,
    XCB_ATOM_SUBSCRIPT_X = 49,
    XCB_ATOM_SUBSCRIPT_Y = 50,
    XCB_ATOM_UNDERLINE_POSITION = 51,
    XCB_ATOM_UNDERLINE_THICKNESS = 52,
    XCB_ATOM_STRIKEOUT_ASCENT = 53,
    XCB_ATOM_STRIKEOUT_DESCENT = 54,
    XCB_ATOM_ITALIC_ANGLE = 55,
    XCB_ATOM_X_HEIGHT = 56,
    XCB_ATOM_QUAD_WIDTH = 57,
    XCB_ATOM_WEIGHT = 58,
    XCB_ATOM_POINT_SIZE = 59,
    XCB_ATOM_RESOLUTION = 60,
    XCB_ATOM_COPYRIGHT = 61,
    XCB_ATOM_NOTICE = 62,
    XCB_ATOM_FONT_NAME = 63,
    XCB_ATOM_FAMILY_NAME = 64,
    XCB_ATOM_FULL_NAME = 65,
    XCB_ATOM_CAP_HEIGHT = 66,
    XCB_ATOM_WM_CLASS = 67,
    XCB_ATOM_WM_TRANSIENT_FOR = 68,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_selection_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_request_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_selection_request_event_t>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<xcb_selection_request_event_t>() ,
               4usize);
}
impl Clone for xcb_selection_request_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_selection_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_selection_notify_event_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_selection_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_selection_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_colormap_state_t {
    XCB_COLORMAP_STATE_UNINSTALLED = 0,
    XCB_COLORMAP_STATE_INSTALLED = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_colormap_enum_t { XCB_COLORMAP_NONE = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_colormap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub colormap: xcb_colormap_t,
    pub _new: u8,
    pub state: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_colormap_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_colormap_notify_event_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_colormap_notify_event_t>() ,
               4usize);
}
impl Clone for xcb_colormap_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union xcb_client_message_data_t {
    pub data8: [u8; 20usize],
    pub data16: [u16; 10usize],
    pub data32: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_t() {
    assert_eq!(::std::mem::size_of::<xcb_client_message_data_t>() , 20usize);
    assert_eq!(::std::mem::align_of::<xcb_client_message_data_t>() , 4usize);
}
impl Clone for xcb_client_message_data_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_client_message_data_iterator_t {
    pub data: *mut xcb_client_message_data_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_client_message_data_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_client_message_data_iterator_t>() ,
               8usize);
}
impl Clone for xcb_client_message_data_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct xcb_client_message_event_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub type_: xcb_atom_t,
    pub data: xcb_client_message_data_t,
}
#[test]
fn bindgen_test_layout_xcb_client_message_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_client_message_event_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_client_message_event_t>() , 4usize);
}
impl Clone for xcb_client_message_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_mapping_t {
    XCB_MAPPING_MODIFIER = 0,
    XCB_MAPPING_KEYBOARD = 1,
    XCB_MAPPING_POINTER = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_mapping_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub request: u8,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_mapping_notify_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_mapping_notify_event_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_mapping_notify_event_t>() , 2usize);
}
impl Clone for xcb_mapping_notify_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ge_generic_event_t {
    pub response_type: u8,
    pub extension: u8,
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad0: [u8; 22usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_generic_event_t() {
    assert_eq!(::std::mem::size_of::<xcb_ge_generic_event_t>() , 36usize);
    assert_eq!(::std::mem::align_of::<xcb_ge_generic_event_t>() , 4usize);
}
impl Clone for xcb_ge_generic_event_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_request_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_request_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_request_error_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_request_error_t>() , 4usize);
}
impl Clone for xcb_request_error_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_value_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_value_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_value_error_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_value_error_t>() , 4usize);
}
impl Clone for xcb_value_error_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_window_error_t = xcb_value_error_t;
pub type xcb_pixmap_error_t = xcb_value_error_t;
pub type xcb_atom_error_t = xcb_value_error_t;
pub type xcb_cursor_error_t = xcb_value_error_t;
pub type xcb_font_error_t = xcb_value_error_t;
pub type xcb_match_error_t = xcb_request_error_t;
pub type xcb_drawable_error_t = xcb_value_error_t;
pub type xcb_access_error_t = xcb_request_error_t;
pub type xcb_alloc_error_t = xcb_request_error_t;
pub type xcb_colormap_error_t = xcb_value_error_t;
pub type xcb_g_context_error_t = xcb_value_error_t;
pub type xcb_id_choice_error_t = xcb_value_error_t;
pub type xcb_name_error_t = xcb_request_error_t;
pub type xcb_length_error_t = xcb_request_error_t;
pub type xcb_implementation_error_t = xcb_request_error_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_window_class_t {
    XCB_WINDOW_CLASS_COPY_FROM_PARENT = 0,
    XCB_WINDOW_CLASS_INPUT_OUTPUT = 1,
    XCB_WINDOW_CLASS_INPUT_ONLY = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_cw_t {
    XCB_CW_BACK_PIXMAP = 1,
    XCB_CW_BACK_PIXEL = 2,
    XCB_CW_BORDER_PIXMAP = 4,
    XCB_CW_BORDER_PIXEL = 8,
    XCB_CW_BIT_GRAVITY = 16,
    XCB_CW_WIN_GRAVITY = 32,
    XCB_CW_BACKING_STORE = 64,
    XCB_CW_BACKING_PLANES = 128,
    XCB_CW_BACKING_PIXEL = 256,
    XCB_CW_OVERRIDE_REDIRECT = 512,
    XCB_CW_SAVE_UNDER = 1024,
    XCB_CW_EVENT_MASK = 2048,
    XCB_CW_DONT_PROPAGATE = 4096,
    XCB_CW_COLORMAP = 8192,
    XCB_CW_CURSOR = 16384,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_back_pixmap_t {
    XCB_BACK_PIXMAP_NONE = 0,
    XCB_BACK_PIXMAP_PARENT_RELATIVE = 1,
}
pub const xcb_gravity_t_XCB_GRAVITY_WIN_UNMAP: xcb_gravity_t =
    xcb_gravity_t::XCB_GRAVITY_BIT_FORGET;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_gravity_t {
    XCB_GRAVITY_BIT_FORGET = 0,
    XCB_GRAVITY_NORTH_WEST = 1,
    XCB_GRAVITY_NORTH = 2,
    XCB_GRAVITY_NORTH_EAST = 3,
    XCB_GRAVITY_WEST = 4,
    XCB_GRAVITY_CENTER = 5,
    XCB_GRAVITY_EAST = 6,
    XCB_GRAVITY_SOUTH_WEST = 7,
    XCB_GRAVITY_SOUTH = 8,
    XCB_GRAVITY_SOUTH_EAST = 9,
    XCB_GRAVITY_STATIC = 10,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_window_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_create_window_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_window_value_list_t>() ,
               60usize);
    assert_eq!(::std::mem::align_of::<xcb_create_window_value_list_t>() ,
               4usize);
}
impl Clone for xcb_create_window_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_window_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub wid: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub _class: u16,
    pub visual: xcb_visualid_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_window_request_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_create_window_request_t>() ,
               4usize);
}
impl Clone for xcb_create_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_window_attributes_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_window_attributes_value_list_t>()
               , 60usize);
    assert_eq!(::std::mem::align_of::<xcb_change_window_attributes_value_list_t>()
               , 4usize);
}
impl Clone for xcb_change_window_attributes_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_window_attributes_request_t>()
               , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_change_window_attributes_request_t>()
               , 4usize);
}
impl Clone for xcb_change_window_attributes_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_map_state_t {
    XCB_MAP_STATE_UNMAPPED = 0,
    XCB_MAP_STATE_UNVIEWABLE = 1,
    XCB_MAP_STATE_VIEWABLE = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_window_attributes_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_window_attributes_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_window_attributes_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_window_attributes_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_window_attributes_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_get_window_attributes_request_t>() ,
               4usize);
}
impl Clone for xcb_get_window_attributes_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_window_attributes_reply_t {
    pub response_type: u8,
    pub backing_store: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub _class: u16,
    pub bit_gravity: u8,
    pub win_gravity: u8,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub save_under: u8,
    pub map_is_installed: u8,
    pub map_state: u8,
    pub override_redirect: u8,
    pub colormap: xcb_colormap_t,
    pub all_event_masks: u32,
    pub your_event_mask: u32,
    pub do_not_propagate_mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_window_attributes_reply_t>() ,
               44usize);
    assert_eq!(::std::mem::align_of::<xcb_get_window_attributes_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_window_attributes_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_destroy_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_destroy_window_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_destroy_window_request_t>() ,
               4usize);
}
impl Clone for xcb_destroy_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_destroy_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_subwindows_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_destroy_subwindows_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_destroy_subwindows_request_t>() ,
               4usize);
}
impl Clone for xcb_destroy_subwindows_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_set_mode_t { XCB_SET_MODE_INSERT = 0, XCB_SET_MODE_DELETE = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_save_set_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_change_save_set_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_save_set_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_change_save_set_request_t>() ,
               4usize);
}
impl Clone for xcb_change_save_set_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_reparent_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_reparent_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_reparent_window_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_reparent_window_request_t>() ,
               4usize);
}
impl Clone for xcb_reparent_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_window_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_map_window_request_t>() , 4usize);
}
impl Clone for xcb_map_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_map_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_subwindows_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_map_subwindows_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_map_subwindows_request_t>() ,
               4usize);
}
impl Clone for xcb_map_subwindows_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_unmap_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_unmap_window_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_unmap_window_request_t>() , 4usize);
}
impl Clone for xcb_unmap_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_unmap_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_subwindows_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_unmap_subwindows_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_unmap_subwindows_request_t>() ,
               4usize);
}
impl Clone for xcb_unmap_subwindows_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_config_window_t {
    XCB_CONFIG_WINDOW_X = 1,
    XCB_CONFIG_WINDOW_Y = 2,
    XCB_CONFIG_WINDOW_WIDTH = 4,
    XCB_CONFIG_WINDOW_HEIGHT = 8,
    XCB_CONFIG_WINDOW_BORDER_WIDTH = 16,
    XCB_CONFIG_WINDOW_SIBLING = 32,
    XCB_CONFIG_WINDOW_STACK_MODE = 64,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_stack_mode_t {
    XCB_STACK_MODE_ABOVE = 0,
    XCB_STACK_MODE_BELOW = 1,
    XCB_STACK_MODE_TOP_IF = 2,
    XCB_STACK_MODE_BOTTOM_IF = 3,
    XCB_STACK_MODE_OPPOSITE = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_configure_window_value_list_t {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
    pub border_width: u32,
    pub sibling: xcb_window_t,
    pub stack_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_configure_window_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_configure_window_value_list_t>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<xcb_configure_window_value_list_t>() ,
               4usize);
}
impl Clone for xcb_configure_window_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_configure_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_configure_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_configure_window_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_configure_window_request_t>() ,
               4usize);
}
impl Clone for xcb_configure_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_circulate_t {
    XCB_CIRCULATE_RAISE_LOWEST = 0,
    XCB_CIRCULATE_LOWER_HIGHEST = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_circulate_window_request_t {
    pub major_opcode: u8,
    pub direction: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_circulate_window_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_circulate_window_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_circulate_window_request_t>() ,
               4usize);
}
impl Clone for xcb_circulate_window_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_geometry_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_geometry_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_geometry_cookie_t>() , 4usize);
}
impl Clone for xcb_get_geometry_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_geometry_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_geometry_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_get_geometry_request_t>() , 4usize);
}
impl Clone for xcb_get_geometry_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_geometry_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_geometry_reply_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_get_geometry_reply_t>() , 4usize);
}
impl Clone for xcb_get_geometry_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_tree_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_tree_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_tree_cookie_t>() , 4usize);
}
impl Clone for xcb_query_tree_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_tree_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_tree_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_tree_request_t>() , 4usize);
}
impl Clone for xcb_query_tree_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_tree_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub parent: xcb_window_t,
    pub children_len: u16,
    pub pad1: [u8; 14usize],
}
#[test]
fn bindgen_test_layout_xcb_query_tree_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_tree_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_query_tree_reply_t>() , 4usize);
}
impl Clone for xcb_query_tree_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_intern_atom_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_intern_atom_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_intern_atom_cookie_t>() , 4usize);
}
impl Clone for xcb_intern_atom_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_intern_atom_request_t {
    pub major_opcode: u8,
    pub only_if_exists: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_intern_atom_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_intern_atom_request_t>() , 2usize);
}
impl Clone for xcb_intern_atom_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_intern_atom_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_intern_atom_reply_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_intern_atom_reply_t>() , 4usize);
}
impl Clone for xcb_intern_atom_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_atom_name_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_atom_name_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_atom_name_cookie_t>() , 4usize);
}
impl Clone for xcb_get_atom_name_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_atom_name_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_atom_name_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_get_atom_name_request_t>() ,
               4usize);
}
impl Clone for xcb_get_atom_name_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_atom_name_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub name_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_atom_name_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_atom_name_reply_t>() , 4usize);
}
impl Clone for xcb_get_atom_name_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_prop_mode_t {
    XCB_PROP_MODE_REPLACE = 0,
    XCB_PROP_MODE_PREPEND = 1,
    XCB_PROP_MODE_APPEND = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_property_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub format: u8,
    pub pad0: [u8; 3usize],
    pub data_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_property_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_property_request_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_change_property_request_t>() ,
               4usize);
}
impl Clone for xcb_change_property_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_delete_property_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_delete_property_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_delete_property_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_delete_property_request_t>() ,
               4usize);
}
impl Clone for xcb_delete_property_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_get_property_type_t { XCB_GET_PROPERTY_TYPE_ANY = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_property_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_property_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_property_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_property_cookie_t>() , 4usize);
}
impl Clone for xcb_get_property_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_property_request_t {
    pub major_opcode: u8,
    pub _delete: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub long_offset: u32,
    pub long_length: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_property_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_property_request_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_get_property_request_t>() , 4usize);
}
impl Clone for xcb_get_property_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_property_reply_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub length: u32,
    pub type_: xcb_atom_t,
    pub bytes_after: u32,
    pub value_len: u32,
    pub pad0: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_xcb_get_property_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_property_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_property_reply_t>() , 4usize);
}
impl Clone for xcb_get_property_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_properties_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_properties_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_properties_cookie_t>() ,
               4usize);
}
impl Clone for xcb_list_properties_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_properties_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_list_properties_request_t>() ,
               4usize);
}
impl Clone for xcb_list_properties_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_properties_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atoms_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_properties_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_properties_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_list_properties_reply_t>() ,
               4usize);
}
impl Clone for xcb_list_properties_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_selection_owner_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_selection_owner_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_set_selection_owner_request_t>() ,
               4usize);
}
impl Clone for xcb_set_selection_owner_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_selection_owner_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_selection_owner_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_selection_owner_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_selection_owner_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_selection_owner_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_get_selection_owner_request_t>() ,
               4usize);
}
impl Clone for xcb_get_selection_owner_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_selection_owner_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub owner: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_selection_owner_reply_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_get_selection_owner_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_selection_owner_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_convert_selection_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_convert_selection_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_convert_selection_request_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_convert_selection_request_t>() ,
               4usize);
}
impl Clone for xcb_convert_selection_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_send_event_dest_t {
    XCB_SEND_EVENT_DEST_POINTER_WINDOW = 0,
    XCB_SEND_EVENT_DEST_ITEM_FOCUS = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_send_event_request_t {
    pub major_opcode: u8,
    pub propagate: u8,
    pub length: u16,
    pub destination: xcb_window_t,
    pub event_mask: u32,
    pub event: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_send_event_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_send_event_request_t>() , 44usize);
    assert_eq!(::std::mem::align_of::<xcb_send_event_request_t>() , 4usize);
}
impl Clone for xcb_send_event_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_grab_mode_t { XCB_GRAB_MODE_SYNC = 0, XCB_GRAB_MODE_ASYNC = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_grab_status_t {
    XCB_GRAB_STATUS_SUCCESS = 0,
    XCB_GRAB_STATUS_ALREADY_GRABBED = 1,
    XCB_GRAB_STATUS_INVALID_TIME = 2,
    XCB_GRAB_STATUS_NOT_VIEWABLE = 3,
    XCB_GRAB_STATUS_FROZEN = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_cursor_enum_t { XCB_CURSOR_NONE = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_pointer_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_pointer_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_pointer_cookie_t>() , 4usize);
}
impl Clone for xcb_grab_pointer_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_pointer_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_pointer_request_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_pointer_request_t>() , 4usize);
}
impl Clone for xcb_grab_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_pointer_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_pointer_reply_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_pointer_reply_t>() , 4usize);
}
impl Clone for xcb_grab_pointer_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_pointer_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_ungrab_pointer_request_t>() ,
               4usize);
}
impl Clone for xcb_ungrab_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_button_index_t {
    XCB_BUTTON_INDEX_ANY = 0,
    XCB_BUTTON_INDEX_1 = 1,
    XCB_BUTTON_INDEX_2 = 2,
    XCB_BUTTON_INDEX_3 = 3,
    XCB_BUTTON_INDEX_4 = 4,
    XCB_BUTTON_INDEX_5 = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_button_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub button: u8,
    pub pad0: u8,
    pub modifiers: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_button_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_button_request_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_button_request_t>() , 4usize);
}
impl Clone for xcb_grab_button_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_button_request_t {
    pub major_opcode: u8,
    pub button: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_button_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_button_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_ungrab_button_request_t>() ,
               4usize);
}
impl Clone for xcb_ungrab_button_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_active_pointer_grab_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
    pub event_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_active_pointer_grab_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_active_pointer_grab_request_t>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_change_active_pointer_grab_request_t>()
               , 4usize);
}
impl Clone for xcb_change_active_pointer_grab_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_keyboard_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_keyboard_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_keyboard_cookie_t>() , 4usize);
}
impl Clone for xcb_grab_keyboard_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_keyboard_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub time: xcb_timestamp_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_keyboard_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_keyboard_request_t>() ,
               4usize);
}
impl Clone for xcb_grab_keyboard_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_keyboard_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_keyboard_reply_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_keyboard_reply_t>() , 4usize);
}
impl Clone for xcb_grab_keyboard_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_keyboard_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_keyboard_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_keyboard_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_ungrab_keyboard_request_t>() ,
               4usize);
}
impl Clone for xcb_ungrab_keyboard_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_grab_t { XCB_GRAB_ANY = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_key_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub key: xcb_keycode_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_key_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_key_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_key_request_t>() , 4usize);
}
impl Clone for xcb_grab_key_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_key_request_t {
    pub major_opcode: u8,
    pub key: xcb_keycode_t,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_key_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_key_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_ungrab_key_request_t>() , 4usize);
}
impl Clone for xcb_ungrab_key_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_allow_t {
    XCB_ALLOW_ASYNC_POINTER = 0,
    XCB_ALLOW_SYNC_POINTER = 1,
    XCB_ALLOW_REPLAY_POINTER = 2,
    XCB_ALLOW_ASYNC_KEYBOARD = 3,
    XCB_ALLOW_SYNC_KEYBOARD = 4,
    XCB_ALLOW_REPLAY_KEYBOARD = 5,
    XCB_ALLOW_ASYNC_BOTH = 6,
    XCB_ALLOW_SYNC_BOTH = 7,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_allow_events_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_allow_events_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_allow_events_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_allow_events_request_t>() , 4usize);
}
impl Clone for xcb_allow_events_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_grab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_server_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_grab_server_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_grab_server_request_t>() , 2usize);
}
impl Clone for xcb_grab_server_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_ungrab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_server_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_ungrab_server_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_ungrab_server_request_t>() ,
               2usize);
}
impl Clone for xcb_ungrab_server_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_pointer_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_pointer_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_pointer_cookie_t>() , 4usize);
}
impl Clone for xcb_query_pointer_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_pointer_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_pointer_request_t>() ,
               4usize);
}
impl Clone for xcb_query_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_pointer_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub win_x: i16,
    pub win_y: i16,
    pub mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_pointer_reply_t>() , 28usize);
    assert_eq!(::std::mem::align_of::<xcb_query_pointer_reply_t>() , 4usize);
}
impl Clone for xcb_query_pointer_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_timecoord_t {
    pub time: xcb_timestamp_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_t() {
    assert_eq!(::std::mem::size_of::<xcb_timecoord_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_timecoord_t>() , 4usize);
}
impl Clone for xcb_timecoord_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_timecoord_iterator_t {
    pub data: *mut xcb_timecoord_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_timecoord_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_timecoord_iterator_t>() , 8usize);
}
impl Clone for xcb_timecoord_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_motion_events_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_motion_events_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_motion_events_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_motion_events_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_motion_events_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub start: xcb_timestamp_t,
    pub stop: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_motion_events_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_get_motion_events_request_t>() ,
               4usize);
}
impl Clone for xcb_get_motion_events_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_motion_events_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub events_len: u32,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_motion_events_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_motion_events_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_motion_events_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_translate_coordinates_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_translate_coordinates_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_translate_coordinates_cookie_t>() ,
               4usize);
}
impl Clone for xcb_translate_coordinates_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_translate_coordinates_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_translate_coordinates_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_translate_coordinates_request_t>() ,
               4usize);
}
impl Clone for xcb_translate_coordinates_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_translate_coordinates_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub child: xcb_window_t,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_translate_coordinates_reply_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_translate_coordinates_reply_t>() ,
               4usize);
}
impl Clone for xcb_translate_coordinates_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_warp_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
    pub src_width: u16,
    pub src_height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_warp_pointer_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_warp_pointer_request_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_warp_pointer_request_t>() , 4usize);
}
impl Clone for xcb_warp_pointer_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_input_focus_t {
    XCB_INPUT_FOCUS_NONE = 0,
    XCB_INPUT_FOCUS_POINTER_ROOT = 1,
    XCB_INPUT_FOCUS_PARENT = 2,
    XCB_INPUT_FOCUS_FOLLOW_KEYBOARD = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_input_focus_request_t {
    pub major_opcode: u8,
    pub revert_to: u8,
    pub length: u16,
    pub focus: xcb_window_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_input_focus_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_input_focus_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_set_input_focus_request_t>() ,
               4usize);
}
impl Clone for xcb_set_input_focus_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_input_focus_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_input_focus_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_input_focus_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_input_focus_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_input_focus_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_input_focus_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_input_focus_request_t>() ,
               2usize);
}
impl Clone for xcb_get_input_focus_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_input_focus_reply_t {
    pub response_type: u8,
    pub revert_to: u8,
    pub sequence: u16,
    pub length: u32,
    pub focus: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_input_focus_reply_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_get_input_focus_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_input_focus_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_keymap_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_keymap_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_keymap_cookie_t>() , 4usize);
}
impl Clone for xcb_query_keymap_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_keymap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_keymap_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_keymap_request_t>() , 2usize);
}
impl Clone for xcb_query_keymap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_keymap_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub keys: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_keymap_reply_t>() , 40usize);
    assert_eq!(::std::mem::align_of::<xcb_query_keymap_reply_t>() , 4usize);
}
impl Clone for xcb_query_keymap_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_open_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub fid: xcb_font_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_open_font_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_open_font_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_open_font_request_t>() , 4usize);
}
impl Clone for xcb_open_font_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_close_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_font_t,
}
#[test]
fn bindgen_test_layout_xcb_close_font_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_close_font_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_close_font_request_t>() , 4usize);
}
impl Clone for xcb_close_font_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_font_draw_t {
    XCB_FONT_DRAW_LEFT_TO_RIGHT = 0,
    XCB_FONT_DRAW_RIGHT_TO_LEFT = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fontprop_t {
    pub name: xcb_atom_t,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_t() {
    assert_eq!(::std::mem::size_of::<xcb_fontprop_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_fontprop_t>() , 4usize);
}
impl Clone for xcb_fontprop_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fontprop_iterator_t {
    pub data: *mut xcb_fontprop_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_fontprop_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_fontprop_iterator_t>() , 8usize);
}
impl Clone for xcb_fontprop_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_charinfo_t {
    pub left_side_bearing: i16,
    pub right_side_bearing: i16,
    pub character_width: i16,
    pub ascent: i16,
    pub descent: i16,
    pub attributes: u16,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_t() {
    assert_eq!(::std::mem::size_of::<xcb_charinfo_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_charinfo_t>() , 2usize);
}
impl Clone for xcb_charinfo_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_charinfo_iterator_t {
    pub data: *mut xcb_charinfo_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_charinfo_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_charinfo_iterator_t>() , 8usize);
}
impl Clone for xcb_charinfo_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_font_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_font_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_font_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_font_cookie_t>() , 4usize);
}
impl Clone for xcb_query_font_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_font_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_font_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_font_request_t>() , 4usize);
}
impl Clone for xcb_query_font_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_font_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad2: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub char_infos_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_query_font_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_font_reply_t>() , 60usize);
    assert_eq!(::std::mem::align_of::<xcb_query_font_reply_t>() , 4usize);
}
impl Clone for xcb_query_font_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_text_extents_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_text_extents_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_text_extents_cookie_t>() ,
               4usize);
}
impl Clone for xcb_query_text_extents_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_text_extents_request_t {
    pub major_opcode: u8,
    pub odd_length: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_text_extents_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_text_extents_request_t>() ,
               4usize);
}
impl Clone for xcb_query_text_extents_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_text_extents_reply_t {
    pub response_type: u8,
    pub draw_direction: u8,
    pub sequence: u16,
    pub length: u32,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub overall_ascent: i16,
    pub overall_descent: i16,
    pub overall_width: i32,
    pub overall_left: i32,
    pub overall_right: i32,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_text_extents_reply_t>() ,
               28usize);
    assert_eq!(::std::mem::align_of::<xcb_query_text_extents_reply_t>() ,
               4usize);
}
impl Clone for xcb_query_text_extents_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_str_t {
    pub name_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_str_t() {
    assert_eq!(::std::mem::size_of::<xcb_str_t>() , 1usize);
    assert_eq!(::std::mem::align_of::<xcb_str_t>() , 1usize);
}
impl Clone for xcb_str_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_str_iterator_t {
    pub data: *mut xcb_str_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_str_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_str_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_str_iterator_t>() , 8usize);
}
impl Clone for xcb_str_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_cookie_t>() , 4usize);
}
impl Clone for xcb_list_fonts_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_request_t>() , 2usize);
}
impl Clone for xcb_list_fonts_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub names_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_reply_t>() , 4usize);
}
impl Clone for xcb_list_fonts_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_with_info_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_with_info_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_with_info_cookie_t>() ,
               4usize);
}
impl Clone for xcb_list_fonts_with_info_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_with_info_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_with_info_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_with_info_request_t>() ,
               2usize);
}
impl Clone for xcb_list_fonts_with_info_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_fonts_with_info_reply_t {
    pub response_type: u8,
    pub name_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad0: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub replies_hint: u32,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_fonts_with_info_reply_t>() ,
               60usize);
    assert_eq!(::std::mem::align_of::<xcb_list_fonts_with_info_reply_t>() ,
               4usize);
}
impl Clone for xcb_list_fonts_with_info_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font_qty: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_set_font_path_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_font_path_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_set_font_path_request_t>() ,
               2usize);
}
impl Clone for xcb_set_font_path_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_font_path_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_font_path_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_font_path_cookie_t>() , 4usize);
}
impl Clone for xcb_get_font_path_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_font_path_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_font_path_request_t>() ,
               2usize);
}
impl Clone for xcb_get_font_path_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_font_path_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub path_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_font_path_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_font_path_reply_t>() , 4usize);
}
impl Clone for xcb_get_font_path_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_pixmap_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub pid: xcb_pixmap_t,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_pixmap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_pixmap_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_create_pixmap_request_t>() ,
               4usize);
}
impl Clone for xcb_create_pixmap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_pixmap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub pixmap: xcb_pixmap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_pixmap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_pixmap_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_free_pixmap_request_t>() , 4usize);
}
impl Clone for xcb_free_pixmap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_gc_t {
    XCB_GC_FUNCTION = 1,
    XCB_GC_PLANE_MASK = 2,
    XCB_GC_FOREGROUND = 4,
    XCB_GC_BACKGROUND = 8,
    XCB_GC_LINE_WIDTH = 16,
    XCB_GC_LINE_STYLE = 32,
    XCB_GC_CAP_STYLE = 64,
    XCB_GC_JOIN_STYLE = 128,
    XCB_GC_FILL_STYLE = 256,
    XCB_GC_FILL_RULE = 512,
    XCB_GC_TILE = 1024,
    XCB_GC_STIPPLE = 2048,
    XCB_GC_TILE_STIPPLE_ORIGIN_X = 4096,
    XCB_GC_TILE_STIPPLE_ORIGIN_Y = 8192,
    XCB_GC_FONT = 16384,
    XCB_GC_SUBWINDOW_MODE = 32768,
    XCB_GC_GRAPHICS_EXPOSURES = 65536,
    XCB_GC_CLIP_ORIGIN_X = 131072,
    XCB_GC_CLIP_ORIGIN_Y = 262144,
    XCB_GC_CLIP_MASK = 524288,
    XCB_GC_DASH_OFFSET = 1048576,
    XCB_GC_DASH_LIST = 2097152,
    XCB_GC_ARC_MODE = 4194304,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_gx_t {
    XCB_GX_CLEAR = 0,
    XCB_GX_AND = 1,
    XCB_GX_AND_REVERSE = 2,
    XCB_GX_COPY = 3,
    XCB_GX_AND_INVERTED = 4,
    XCB_GX_NOOP = 5,
    XCB_GX_XOR = 6,
    XCB_GX_OR = 7,
    XCB_GX_NOR = 8,
    XCB_GX_EQUIV = 9,
    XCB_GX_INVERT = 10,
    XCB_GX_OR_REVERSE = 11,
    XCB_GX_COPY_INVERTED = 12,
    XCB_GX_OR_INVERTED = 13,
    XCB_GX_NAND = 14,
    XCB_GX_SET = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_line_style_t {
    XCB_LINE_STYLE_SOLID = 0,
    XCB_LINE_STYLE_ON_OFF_DASH = 1,
    XCB_LINE_STYLE_DOUBLE_DASH = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_cap_style_t {
    XCB_CAP_STYLE_NOT_LAST = 0,
    XCB_CAP_STYLE_BUTT = 1,
    XCB_CAP_STYLE_ROUND = 2,
    XCB_CAP_STYLE_PROJECTING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_join_style_t {
    XCB_JOIN_STYLE_MITER = 0,
    XCB_JOIN_STYLE_ROUND = 1,
    XCB_JOIN_STYLE_BEVEL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_fill_style_t {
    XCB_FILL_STYLE_SOLID = 0,
    XCB_FILL_STYLE_TILED = 1,
    XCB_FILL_STYLE_STIPPLED = 2,
    XCB_FILL_STYLE_OPAQUE_STIPPLED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_fill_rule_t {
    XCB_FILL_RULE_EVEN_ODD = 0,
    XCB_FILL_RULE_WINDING = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_subwindow_mode_t {
    XCB_SUBWINDOW_MODE_CLIP_BY_CHILDREN = 0,
    XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_arc_mode_t {
    XCB_ARC_MODE_CHORD = 0,
    XCB_ARC_MODE_PIE_SLICE = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_gc_value_list_t>() , 92usize);
    assert_eq!(::std::mem::align_of::<xcb_create_gc_value_list_t>() , 4usize);
}
impl Clone for xcb_create_gc_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_gcontext_t,
    pub drawable: xcb_drawable_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_gc_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_create_gc_request_t>() , 4usize);
}
impl Clone for xcb_create_gc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_gc_value_list_t>() , 92usize);
    assert_eq!(::std::mem::align_of::<xcb_change_gc_value_list_t>() , 4usize);
}
impl Clone for xcb_change_gc_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_gc_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_change_gc_request_t>() , 4usize);
}
impl Clone for xcb_change_gc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_gc: xcb_gcontext_t,
    pub dst_gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_gc_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_copy_gc_request_t>() , 4usize);
}
impl Clone for xcb_copy_gc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_dashes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub dash_offset: u16,
    pub dashes_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_dashes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_dashes_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_set_dashes_request_t>() , 4usize);
}
impl Clone for xcb_set_dashes_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_clip_ordering_t {
    XCB_CLIP_ORDERING_UNSORTED = 0,
    XCB_CLIP_ORDERING_Y_SORTED = 1,
    XCB_CLIP_ORDERING_YX_SORTED = 2,
    XCB_CLIP_ORDERING_YX_BANDED = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_clip_rectangles_request_t {
    pub major_opcode: u8,
    pub ordering: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub clip_x_origin: i16,
    pub clip_y_origin: i16,
}
#[test]
fn bindgen_test_layout_xcb_set_clip_rectangles_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_clip_rectangles_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_set_clip_rectangles_request_t>() ,
               4usize);
}
impl Clone for xcb_set_clip_rectangles_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_free_gc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_gc_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_free_gc_request_t>() , 4usize);
}
impl Clone for xcb_free_gc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_clear_area_request_t {
    pub major_opcode: u8,
    pub exposures: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_clear_area_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_clear_area_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_clear_area_request_t>() , 4usize);
}
impl Clone for xcb_clear_area_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_area_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_copy_area_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_area_request_t>() , 28usize);
    assert_eq!(::std::mem::align_of::<xcb_copy_area_request_t>() , 4usize);
}
impl Clone for xcb_copy_area_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_plane_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
    pub bit_plane: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_plane_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_plane_request_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_copy_plane_request_t>() , 4usize);
}
impl Clone for xcb_copy_plane_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_coord_mode_t {
    XCB_COORD_MODE_ORIGIN = 0,
    XCB_COORD_MODE_PREVIOUS = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_point_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_point_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_point_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_point_request_t>() , 4usize);
}
impl Clone for xcb_poly_point_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_line_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_line_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_line_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_line_request_t>() , 4usize);
}
impl Clone for xcb_poly_line_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_segment_t {
    pub x1: i16,
    pub y1: i16,
    pub x2: i16,
    pub y2: i16,
}
#[test]
fn bindgen_test_layout_xcb_segment_t() {
    assert_eq!(::std::mem::size_of::<xcb_segment_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_segment_t>() , 2usize);
}
impl Clone for xcb_segment_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_segment_iterator_t {
    pub data: *mut xcb_segment_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_segment_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_segment_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_segment_iterator_t>() , 8usize);
}
impl Clone for xcb_segment_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_segment_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_segment_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_segment_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_segment_request_t>() , 4usize);
}
impl Clone for xcb_poly_segment_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_rectangle_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_rectangle_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_rectangle_request_t>() ,
               4usize);
}
impl Clone for xcb_poly_rectangle_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_arc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_arc_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_arc_request_t>() , 4usize);
}
impl Clone for xcb_poly_arc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_poly_shape_t {
    XCB_POLY_SHAPE_COMPLEX = 0,
    XCB_POLY_SHAPE_NONCONVEX = 1,
    XCB_POLY_SHAPE_CONVEX = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_fill_poly_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub shape: u8,
    pub coordinate_mode: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_fill_poly_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_fill_poly_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_fill_poly_request_t>() , 4usize);
}
impl Clone for xcb_fill_poly_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_fill_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_rectangle_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_fill_rectangle_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_fill_rectangle_request_t>() ,
               4usize);
}
impl Clone for xcb_poly_fill_rectangle_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_fill_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_arc_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_fill_arc_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_fill_arc_request_t>() ,
               4usize);
}
impl Clone for xcb_poly_fill_arc_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_image_format_t {
    XCB_IMAGE_FORMAT_XY_BITMAP = 0,
    XCB_IMAGE_FORMAT_XY_PIXMAP = 1,
    XCB_IMAGE_FORMAT_Z_PIXMAP = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_put_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub width: u16,
    pub height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub left_pad: u8,
    pub depth: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_put_image_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_put_image_request_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_put_image_request_t>() , 4usize);
}
impl Clone for xcb_put_image_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_image_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_image_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_image_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_image_cookie_t>() , 4usize);
}
impl Clone for xcb_get_image_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_image_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_image_request_t>() , 20usize);
    assert_eq!(::std::mem::align_of::<xcb_get_image_request_t>() , 4usize);
}
impl Clone for xcb_get_image_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_image_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub pad0: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_image_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_image_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_image_reply_t>() , 4usize);
}
impl Clone for xcb_get_image_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_text_8_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_8_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_text_8_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_text_8_request_t>() , 4usize);
}
impl Clone for xcb_poly_text_8_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_poly_text_16_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_16_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_poly_text_16_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_poly_text_16_request_t>() , 4usize);
}
impl Clone for xcb_poly_text_16_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_image_text_8_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_8_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_image_text_8_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_image_text_8_request_t>() , 4usize);
}
impl Clone for xcb_image_text_8_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_image_text_16_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_16_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_image_text_16_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_image_text_16_request_t>() ,
               4usize);
}
impl Clone for xcb_image_text_16_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_colormap_alloc_t {
    XCB_COLORMAP_ALLOC_NONE = 0,
    XCB_COLORMAP_ALLOC_ALL = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_colormap_request_t {
    pub major_opcode: u8,
    pub alloc: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub window: xcb_window_t,
    pub visual: xcb_visualid_t,
}
#[test]
fn bindgen_test_layout_xcb_create_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_colormap_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_create_colormap_request_t>() ,
               4usize);
}
impl Clone for xcb_create_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_colormap_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_free_colormap_request_t>() ,
               4usize);
}
impl Clone for xcb_free_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_copy_colormap_and_free_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub src_cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_copy_colormap_and_free_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_copy_colormap_and_free_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_copy_colormap_and_free_request_t>()
               , 4usize);
}
impl Clone for xcb_copy_colormap_and_free_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_install_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_install_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_install_colormap_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_install_colormap_request_t>() ,
               4usize);
}
impl Clone for xcb_install_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_uninstall_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_uninstall_colormap_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_uninstall_colormap_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_uninstall_colormap_request_t>() ,
               4usize);
}
impl Clone for xcb_uninstall_colormap_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_installed_colormaps_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_installed_colormaps_cookie_t>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_installed_colormaps_cookie_t>()
               , 4usize);
}
impl Clone for xcb_list_installed_colormaps_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_installed_colormaps_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_installed_colormaps_request_t>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_list_installed_colormaps_request_t>()
               , 4usize);
}
impl Clone for xcb_list_installed_colormaps_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_installed_colormaps_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub cmaps_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_installed_colormaps_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_list_installed_colormaps_reply_t>()
               , 4usize);
}
impl Clone for xcb_list_installed_colormaps_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_cookie_t>() , 4usize);
}
impl Clone for xcb_alloc_color_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_request_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_request_t>() , 4usize);
}
impl Clone for xcb_alloc_color_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
    pub pixel: u32,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_reply_t>() , 20usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_reply_t>() , 4usize);
}
impl Clone for xcb_alloc_color_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_named_color_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_named_color_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_named_color_cookie_t>() ,
               4usize);
}
impl Clone for xcb_alloc_named_color_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_named_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_named_color_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_named_color_request_t>() ,
               4usize);
}
impl Clone for xcb_alloc_named_color_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_named_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixel: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_named_color_reply_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_named_color_reply_t>() ,
               4usize);
}
impl Clone for xcb_alloc_named_color_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cells_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cells_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_cells_cookie_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_cells_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cells_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub planes: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cells_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_cells_request_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_cells_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_cells_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub masks_len: u16,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_cells_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_cells_reply_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_cells_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_planes_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_planes_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_planes_cookie_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_planes_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_planes_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub reds: u16,
    pub greens: u16,
    pub blues: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_planes_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_planes_request_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_planes_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_alloc_color_planes_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub pad1: [u8; 2usize],
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad2: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_alloc_color_planes_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_alloc_color_planes_reply_t>() ,
               4usize);
}
impl Clone for xcb_alloc_color_planes_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_free_colors_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_colors_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_free_colors_request_t>() , 4usize);
}
impl Clone for xcb_free_colors_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_color_flag_t {
    XCB_COLOR_FLAG_RED = 1,
    XCB_COLOR_FLAG_GREEN = 2,
    XCB_COLOR_FLAG_BLUE = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_coloritem_t {
    pub pixel: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub flags: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_t() {
    assert_eq!(::std::mem::size_of::<xcb_coloritem_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_coloritem_t>() , 4usize);
}
impl Clone for xcb_coloritem_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_coloritem_iterator_t {
    pub data: *mut xcb_coloritem_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_coloritem_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_coloritem_iterator_t>() , 8usize);
}
impl Clone for xcb_coloritem_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_store_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_store_colors_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_store_colors_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_store_colors_request_t>() , 4usize);
}
impl Clone for xcb_store_colors_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_store_named_color_request_t {
    pub major_opcode: u8,
    pub flags: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub pixel: u32,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_store_named_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_store_named_color_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_store_named_color_request_t>() ,
               4usize);
}
impl Clone for xcb_store_named_color_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rgb_t {
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_rgb_t() {
    assert_eq!(::std::mem::size_of::<xcb_rgb_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_rgb_t>() , 2usize);
}
impl Clone for xcb_rgb_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rgb_iterator_t {
    pub data: *mut xcb_rgb_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rgb_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_rgb_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_rgb_iterator_t>() , 8usize);
}
impl Clone for xcb_rgb_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_colors_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_colors_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_colors_cookie_t>() , 4usize);
}
impl Clone for xcb_query_colors_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_colors_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_colors_request_t>() , 4usize);
}
impl Clone for xcb_query_colors_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_colors_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub colors_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_query_colors_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_colors_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_query_colors_reply_t>() , 4usize);
}
impl Clone for xcb_query_colors_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_lookup_color_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_lookup_color_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_lookup_color_cookie_t>() , 4usize);
}
impl Clone for xcb_lookup_color_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_lookup_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_lookup_color_request_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_lookup_color_request_t>() , 4usize);
}
impl Clone for xcb_lookup_color_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_lookup_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_lookup_color_reply_t>() , 20usize);
    assert_eq!(::std::mem::align_of::<xcb_lookup_color_reply_t>() , 4usize);
}
impl Clone for xcb_lookup_color_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_pixmap_enum_t { XCB_PIXMAP_NONE = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source: xcb_pixmap_t,
    pub mask: xcb_pixmap_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
    pub x: u16,
    pub y: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_cursor_request_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_create_cursor_request_t>() ,
               4usize);
}
impl Clone for xcb_create_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_font_enum_t { XCB_FONT_NONE = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_create_glyph_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source_font: xcb_font_t,
    pub mask_font: xcb_font_t,
    pub source_char: u16,
    pub mask_char: u16,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_glyph_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_create_glyph_cursor_request_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_create_glyph_cursor_request_t>() ,
               4usize);
}
impl Clone for xcb_create_glyph_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_free_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_free_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_free_cursor_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_free_cursor_request_t>() , 4usize);
}
impl Clone for xcb_free_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_recolor_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_recolor_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_recolor_cursor_request_t>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<xcb_recolor_cursor_request_t>() ,
               4usize);
}
impl Clone for xcb_recolor_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_query_shape_of_t {
    XCB_QUERY_SHAPE_OF_LARGEST_CURSOR = 0,
    XCB_QUERY_SHAPE_OF_FASTEST_TILE = 1,
    XCB_QUERY_SHAPE_OF_FASTEST_STIPPLE = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_best_size_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_best_size_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_best_size_cookie_t>() ,
               4usize);
}
impl Clone for xcb_query_best_size_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_best_size_request_t {
    pub major_opcode: u8,
    pub _class: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_best_size_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_query_best_size_request_t>() ,
               4usize);
}
impl Clone for xcb_query_best_size_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_best_size_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_best_size_reply_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_query_best_size_reply_t>() ,
               4usize);
}
impl Clone for xcb_query_best_size_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_extension_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_extension_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_query_extension_cookie_t>() ,
               4usize);
}
impl Clone for xcb_query_extension_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_extension_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_extension_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_extension_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_query_extension_request_t>() ,
               2usize);
}
impl Clone for xcb_query_extension_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_query_extension_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub present: u8,
    pub major_opcode: u8,
    pub first_event: u8,
    pub first_error: u8,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_query_extension_reply_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_query_extension_reply_t>() ,
               4usize);
}
impl Clone for xcb_query_extension_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_extensions_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_extensions_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_extensions_cookie_t>() ,
               4usize);
}
impl Clone for xcb_list_extensions_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_extensions_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_extensions_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_extensions_request_t>() ,
               2usize);
}
impl Clone for xcb_list_extensions_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_extensions_reply_t {
    pub response_type: u8,
    pub names_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_extensions_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_list_extensions_reply_t>() ,
               4usize);
}
impl Clone for xcb_list_extensions_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub keycode_count: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub keysyms_per_keycode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_keyboard_mapping_request_t>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_change_keyboard_mapping_request_t>()
               , 2usize);
}
impl Clone for xcb_change_keyboard_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_mapping_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_mapping_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_mapping_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_keyboard_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_mapping_request_t>() ,
               6usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_mapping_request_t>() ,
               2usize);
}
impl Clone for xcb_get_keyboard_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_mapping_reply_t {
    pub response_type: u8,
    pub keysyms_per_keycode: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_mapping_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_mapping_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_keyboard_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_kb_t {
    XCB_KB_KEY_CLICK_PERCENT = 1,
    XCB_KB_BELL_PERCENT = 2,
    XCB_KB_BELL_PITCH = 4,
    XCB_KB_BELL_DURATION = 8,
    XCB_KB_LED = 16,
    XCB_KB_LED_MODE = 32,
    XCB_KB_KEY = 64,
    XCB_KB_AUTO_REPEAT_MODE = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_led_mode_t { XCB_LED_MODE_OFF = 0, XCB_LED_MODE_ON = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_auto_repeat_mode_t {
    XCB_AUTO_REPEAT_MODE_OFF = 0,
    XCB_AUTO_REPEAT_MODE_ON = 1,
    XCB_AUTO_REPEAT_MODE_DEFAULT = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_keyboard_control_value_list_t {
    pub key_click_percent: i32,
    pub bell_percent: i32,
    pub bell_pitch: i32,
    pub bell_duration: i32,
    pub led: u32,
    pub led_mode: u32,
    pub key: xcb_keycode32_t,
    pub auto_repeat_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_keyboard_control_value_list_t>()
               , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_change_keyboard_control_value_list_t>()
               , 4usize);
}
impl Clone for xcb_change_keyboard_control_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_keyboard_control_request_t>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_change_keyboard_control_request_t>()
               , 4usize);
}
impl Clone for xcb_change_keyboard_control_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_control_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_control_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_control_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_keyboard_control_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_control_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_control_request_t>() ,
               2usize);
}
impl Clone for xcb_get_keyboard_control_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_keyboard_control_reply_t {
    pub response_type: u8,
    pub global_auto_repeat: u8,
    pub sequence: u16,
    pub length: u32,
    pub led_mask: u32,
    pub key_click_percent: u8,
    pub bell_percent: u8,
    pub bell_pitch: u16,
    pub bell_duration: u16,
    pub pad0: [u8; 2usize],
    pub auto_repeats: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_keyboard_control_reply_t>() ,
               52usize);
    assert_eq!(::std::mem::align_of::<xcb_get_keyboard_control_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_keyboard_control_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_bell_request_t {
    pub major_opcode: u8,
    pub percent: i8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_bell_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_bell_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_bell_request_t>() , 2usize);
}
impl Clone for xcb_bell_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub acceleration_numerator: i16,
    pub acceleration_denominator: i16,
    pub threshold: i16,
    pub do_acceleration: u8,
    pub do_threshold: u8,
}
#[test]
fn bindgen_test_layout_xcb_change_pointer_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_pointer_control_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_change_pointer_control_request_t>()
               , 2usize);
}
impl Clone for xcb_change_pointer_control_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_control_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_control_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_control_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_pointer_control_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_control_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_control_request_t>() ,
               2usize);
}
impl Clone for xcb_get_pointer_control_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_control_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub acceleration_numerator: u16,
    pub acceleration_denominator: u16,
    pub threshold: u16,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_control_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_control_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_pointer_control_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_blanking_t {
    XCB_BLANKING_NOT_PREFERRED = 0,
    XCB_BLANKING_PREFERRED = 1,
    XCB_BLANKING_DEFAULT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_exposures_t {
    XCB_EXPOSURES_NOT_ALLOWED = 0,
    XCB_EXPOSURES_ALLOWED = 1,
    XCB_EXPOSURES_DEFAULT = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub timeout: i16,
    pub interval: i16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
}
#[test]
fn bindgen_test_layout_xcb_set_screen_saver_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_screen_saver_request_t>() ,
               10usize);
    assert_eq!(::std::mem::align_of::<xcb_set_screen_saver_request_t>() ,
               2usize);
}
impl Clone for xcb_set_screen_saver_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_screen_saver_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_screen_saver_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_screen_saver_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_screen_saver_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_screen_saver_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_screen_saver_request_t>() ,
               2usize);
}
impl Clone for xcb_get_screen_saver_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_screen_saver_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub timeout: u16,
    pub interval: u16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_screen_saver_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_screen_saver_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_screen_saver_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_host_mode_t {
    XCB_HOST_MODE_INSERT = 0,
    XCB_HOST_MODE_DELETE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_family_t {
    XCB_FAMILY_INTERNET = 0,
    XCB_FAMILY_DECNET = 1,
    XCB_FAMILY_CHAOS = 2,
    XCB_FAMILY_SERVER_INTERPRETED = 5,
    XCB_FAMILY_INTERNET_6 = 6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_change_hosts_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_change_hosts_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_change_hosts_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_change_hosts_request_t>() , 2usize);
}
impl Clone for xcb_change_hosts_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_host_t {
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_host_t() {
    assert_eq!(::std::mem::size_of::<xcb_host_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_host_t>() , 2usize);
}
impl Clone for xcb_host_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_host_iterator_t {
    pub data: *mut xcb_host_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_host_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_host_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_host_iterator_t>() , 8usize);
}
impl Clone for xcb_host_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_hosts_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_hosts_cookie_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_hosts_cookie_t>() , 4usize);
}
impl Clone for xcb_list_hosts_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_hosts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_hosts_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_list_hosts_request_t>() , 2usize);
}
impl Clone for xcb_list_hosts_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_list_hosts_reply_t {
    pub response_type: u8,
    pub mode: u8,
    pub sequence: u16,
    pub length: u32,
    pub hosts_len: u16,
    pub pad0: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_list_hosts_reply_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_list_hosts_reply_t>() , 4usize);
}
impl Clone for xcb_list_hosts_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_access_control_t {
    XCB_ACCESS_CONTROL_DISABLE = 0,
    XCB_ACCESS_CONTROL_ENABLE = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_access_control_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_access_control_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_access_control_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_access_control_request_t>() ,
               2usize);
}
impl Clone for xcb_set_access_control_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_close_down_t {
    XCB_CLOSE_DOWN_DESTROY_ALL = 0,
    XCB_CLOSE_DOWN_RETAIN_PERMANENT = 1,
    XCB_CLOSE_DOWN_RETAIN_TEMPORARY = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_close_down_mode_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_close_down_mode_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_close_down_mode_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_close_down_mode_request_t>() ,
               2usize);
}
impl Clone for xcb_set_close_down_mode_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_kill_t { XCB_KILL_ALL_TEMPORARY = 0, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_kill_client_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub resource: u32,
}
#[test]
fn bindgen_test_layout_xcb_kill_client_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_kill_client_request_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_kill_client_request_t>() , 4usize);
}
impl Clone for xcb_kill_client_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_rotate_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub atoms_len: u16,
    pub delta: i16,
}
#[test]
fn bindgen_test_layout_xcb_rotate_properties_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_rotate_properties_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_rotate_properties_request_t>() ,
               4usize);
}
impl Clone for xcb_rotate_properties_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_screen_saver_t {
    XCB_SCREEN_SAVER_RESET = 0,
    XCB_SCREEN_SAVER_ACTIVE = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_force_screen_saver_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_force_screen_saver_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_force_screen_saver_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_force_screen_saver_request_t>() ,
               2usize);
}
impl Clone for xcb_force_screen_saver_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_mapping_status_t {
    XCB_MAPPING_STATUS_SUCCESS = 0,
    XCB_MAPPING_STATUS_BUSY = 1,
    XCB_MAPPING_STATUS_FAILURE = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_pointer_mapping_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_pointer_mapping_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_pointer_mapping_cookie_t>() ,
               4usize);
}
impl Clone for xcb_set_pointer_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub map_len: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_pointer_mapping_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_pointer_mapping_request_t>() ,
               2usize);
}
impl Clone for xcb_set_pointer_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_pointer_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_pointer_mapping_reply_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_set_pointer_mapping_reply_t>() ,
               4usize);
}
impl Clone for xcb_set_pointer_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_mapping_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_mapping_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_mapping_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_pointer_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_mapping_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_mapping_request_t>() ,
               2usize);
}
impl Clone for xcb_get_pointer_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_pointer_mapping_reply_t {
    pub response_type: u8,
    pub map_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_pointer_mapping_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_pointer_mapping_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_pointer_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_map_index_t {
    XCB_MAP_INDEX_SHIFT = 0,
    XCB_MAP_INDEX_LOCK = 1,
    XCB_MAP_INDEX_CONTROL = 2,
    XCB_MAP_INDEX_1 = 3,
    XCB_MAP_INDEX_2 = 4,
    XCB_MAP_INDEX_3 = 5,
    XCB_MAP_INDEX_4 = 6,
    XCB_MAP_INDEX_5 = 7,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_modifier_mapping_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_modifier_mapping_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_modifier_mapping_cookie_t>() ,
               4usize);
}
impl Clone for xcb_set_modifier_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub keycodes_per_modifier: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_modifier_mapping_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_set_modifier_mapping_request_t>() ,
               2usize);
}
impl Clone for xcb_set_modifier_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_set_modifier_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_set_modifier_mapping_reply_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_set_modifier_mapping_reply_t>() ,
               4usize);
}
impl Clone for xcb_set_modifier_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_modifier_mapping_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_modifier_mapping_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_modifier_mapping_cookie_t>() ,
               4usize);
}
impl Clone for xcb_get_modifier_mapping_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_modifier_mapping_request_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_get_modifier_mapping_request_t>() ,
               2usize);
}
impl Clone for xcb_get_modifier_mapping_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_get_modifier_mapping_reply_t {
    pub response_type: u8,
    pub keycodes_per_modifier: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_get_modifier_mapping_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_get_modifier_mapping_reply_t>() ,
               4usize);
}
impl Clone for xcb_get_modifier_mapping_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_no_operation_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_no_operation_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_no_operation_request_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_no_operation_request_t>() , 2usize);
}
impl Clone for xcb_no_operation_request_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn xcb_char2b_next(i: *mut xcb_char2b_iterator_t);
}
extern "C" {
    pub fn xcb_char2b_end(i: xcb_char2b_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_window_next(i: *mut xcb_window_iterator_t);
}
extern "C" {
    pub fn xcb_window_end(i: xcb_window_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_pixmap_next(i: *mut xcb_pixmap_iterator_t);
}
extern "C" {
    pub fn xcb_pixmap_end(i: xcb_pixmap_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_cursor_next(i: *mut xcb_cursor_iterator_t);
}
extern "C" {
    pub fn xcb_cursor_end(i: xcb_cursor_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_font_next(i: *mut xcb_font_iterator_t);
}
extern "C" {
    pub fn xcb_font_end(i: xcb_font_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_gcontext_next(i: *mut xcb_gcontext_iterator_t);
}
extern "C" {
    pub fn xcb_gcontext_end(i: xcb_gcontext_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_colormap_next(i: *mut xcb_colormap_iterator_t);
}
extern "C" {
    pub fn xcb_colormap_end(i: xcb_colormap_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_atom_next(i: *mut xcb_atom_iterator_t);
}
extern "C" {
    pub fn xcb_atom_end(i: xcb_atom_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_drawable_next(i: *mut xcb_drawable_iterator_t);
}
extern "C" {
    pub fn xcb_drawable_end(i: xcb_drawable_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_fontable_next(i: *mut xcb_fontable_iterator_t);
}
extern "C" {
    pub fn xcb_fontable_end(i: xcb_fontable_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_bool32_next(i: *mut xcb_bool32_iterator_t);
}
extern "C" {
    pub fn xcb_bool32_end(i: xcb_bool32_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_visualid_next(i: *mut xcb_visualid_iterator_t);
}
extern "C" {
    pub fn xcb_visualid_end(i: xcb_visualid_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_timestamp_next(i: *mut xcb_timestamp_iterator_t);
}
extern "C" {
    pub fn xcb_timestamp_end(i: xcb_timestamp_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keysym_next(i: *mut xcb_keysym_iterator_t);
}
extern "C" {
    pub fn xcb_keysym_end(i: xcb_keysym_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keycode_next(i: *mut xcb_keycode_iterator_t);
}
extern "C" {
    pub fn xcb_keycode_end(i: xcb_keycode_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keycode32_next(i: *mut xcb_keycode32_iterator_t);
}
extern "C" {
    pub fn xcb_keycode32_end(i: xcb_keycode32_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_button_next(i: *mut xcb_button_iterator_t);
}
extern "C" {
    pub fn xcb_button_end(i: xcb_button_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_point_next(i: *mut xcb_point_iterator_t);
}
extern "C" {
    pub fn xcb_point_end(i: xcb_point_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_rectangle_next(i: *mut xcb_rectangle_iterator_t);
}
extern "C" {
    pub fn xcb_rectangle_end(i: xcb_rectangle_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_arc_next(i: *mut xcb_arc_iterator_t);
}
extern "C" {
    pub fn xcb_arc_end(i: xcb_arc_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_format_next(i: *mut xcb_format_iterator_t);
}
extern "C" {
    pub fn xcb_format_end(i: xcb_format_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_visualtype_next(i: *mut xcb_visualtype_iterator_t);
}
extern "C" {
    pub fn xcb_visualtype_end(i: xcb_visualtype_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_depth_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals(R: *const xcb_depth_t) -> *mut xcb_visualtype_t;
}
extern "C" {
    pub fn xcb_depth_visuals_length(R: *const xcb_depth_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals_iterator(R: *const xcb_depth_t)
     -> xcb_visualtype_iterator_t;
}
extern "C" {
    pub fn xcb_depth_next(i: *mut xcb_depth_iterator_t);
}
extern "C" {
    pub fn xcb_depth_end(i: xcb_depth_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_screen_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_length(R: *const xcb_screen_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_iterator(R: *const xcb_screen_t)
     -> xcb_depth_iterator_t;
}
extern "C" {
    pub fn xcb_screen_next(i: *mut xcb_screen_iterator_t);
}
extern "C" {
    pub fn xcb_screen_end(i: xcb_screen_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name(R:
                                                             *const xcb_setup_request_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_length(R:
                                                                    *const xcb_setup_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_end(R:
                                                                 *const xcb_setup_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data(R:
                                                             *const xcb_setup_request_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_length(R:
                                                                    *const xcb_setup_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_end(R:
                                                                 *const xcb_setup_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_next(i: *mut xcb_setup_request_iterator_t);
}
extern "C" {
    pub fn xcb_setup_request_end(i: xcb_setup_request_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason(R: *const xcb_setup_failed_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_setup_failed_reason_length(R: *const xcb_setup_failed_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason_end(R: *const xcb_setup_failed_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_next(i: *mut xcb_setup_failed_iterator_t);
}
extern "C" {
    pub fn xcb_setup_failed_end(i: xcb_setup_failed_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason(R: *const xcb_setup_authenticate_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_length(R:
                                                    *const xcb_setup_authenticate_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_end(R:
                                                 *const xcb_setup_authenticate_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_next(i:
                                           *mut xcb_setup_authenticate_iterator_t);
}
extern "C" {
    pub fn xcb_setup_authenticate_end(i: xcb_setup_authenticate_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor(R: *const xcb_setup_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_setup_vendor_length(R: *const xcb_setup_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor_end(R: *const xcb_setup_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats(R: *const xcb_setup_t)
     -> *mut xcb_format_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_length(R: *const xcb_setup_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_iterator(R: *const xcb_setup_t)
     -> xcb_format_iterator_t;
}
extern "C" {
    pub fn xcb_setup_roots_length(R: *const xcb_setup_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_setup_roots_iterator(R: *const xcb_setup_t)
     -> xcb_screen_iterator_t;
}
extern "C" {
    pub fn xcb_setup_next(i: *mut xcb_setup_iterator_t);
}
extern "C" {
    pub fn xcb_setup_end(i: xcb_setup_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_client_message_data_next(i:
                                            *mut xcb_client_message_data_iterator_t);
}
extern "C" {
    pub fn xcb_client_message_data_end(i: xcb_client_message_data_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_create_window_value_list_serialize(_buffer:
                                                      *mut *mut libc::c_void,
                                                  value_mask: u32,
                                                  _aux:
                                                      *const xcb_create_window_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_unpack(_buffer: *const libc::c_void,
                                               value_mask: u32,
                                               _aux:
                                                   *mut xcb_create_window_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_sizeof(_buffer: *const libc::c_void,
                                               value_mask: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_window_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_window_checked(c: *mut xcb_connection_t, depth: u8,
                                     wid: xcb_window_t, parent: xcb_window_t,
                                     x: i16, y: i16, width: u16, height: u16,
                                     border_width: u16, _class: u16,
                                     visual: xcb_visualid_t, value_mask: u32,
                                     value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window(c: *mut xcb_connection_t, depth: u8,
                             wid: xcb_window_t, parent: xcb_window_t, x: i16,
                             y: i16, width: u16, height: u16,
                             border_width: u16, _class: u16,
                             visual: xcb_visualid_t, value_mask: u32,
                             value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_aux_checked(c: *mut xcb_connection_t, depth: u8,
                                         wid: xcb_window_t,
                                         parent: xcb_window_t, x: i16, y: i16,
                                         width: u16, height: u16,
                                         border_width: u16, _class: u16,
                                         visual: xcb_visualid_t,
                                         value_mask: u32,
                                         value_list:
                                             *const xcb_create_window_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_aux(c: *mut xcb_connection_t, depth: u8,
                                 wid: xcb_window_t, parent: xcb_window_t,
                                 x: i16, y: i16, width: u16, height: u16,
                                 border_width: u16, _class: u16,
                                 visual: xcb_visualid_t, value_mask: u32,
                                 value_list:
                                     *const xcb_create_window_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_value_list(R: *const xcb_create_window_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_serialize(_buffer:
                                                                 *mut *mut libc::c_void,
                                                             value_mask: u32,
                                                             _aux:
                                                                 *const xcb_change_window_attributes_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_unpack(_buffer:
                                                              *const libc::c_void,
                                                          value_mask: u32,
                                                          _aux:
                                                              *mut xcb_change_window_attributes_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_sizeof(_buffer:
                                                              *const libc::c_void,
                                                          value_mask: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_checked(c: *mut xcb_connection_t,
                                                window: xcb_window_t,
                                                value_mask: u32,
                                                value_list:
                                                    *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes(c: *mut xcb_connection_t,
                                        window: xcb_window_t, value_mask: u32,
                                        value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_aux_checked(c: *mut xcb_connection_t,
                                                    window: xcb_window_t,
                                                    value_mask: u32,
                                                    value_list:
                                                        *const xcb_change_window_attributes_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_aux(c: *mut xcb_connection_t,
                                            window: xcb_window_t,
                                            value_mask: u32,
                                            value_list:
                                                *const xcb_change_window_attributes_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list(R:
                                                       *const xcb_change_window_attributes_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_get_window_attributes(c: *mut xcb_connection_t,
                                     window: xcb_window_t)
     -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    pub fn xcb_get_window_attributes_unchecked(c: *mut xcb_connection_t,
                                               window: xcb_window_t)
     -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    pub fn xcb_get_window_attributes_reply(c: *mut xcb_connection_t,
                                           cookie:
                                               xcb_get_window_attributes_cookie_t,
                                           e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_window_attributes_reply_t;
}
extern "C" {
    pub fn xcb_destroy_window_checked(c: *mut xcb_connection_t,
                                      window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_window(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_subwindows_checked(c: *mut xcb_connection_t,
                                          window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_subwindows(c: *mut xcb_connection_t,
                                  window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_save_set_checked(c: *mut xcb_connection_t, mode: u8,
                                       window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_save_set(c: *mut xcb_connection_t, mode: u8,
                               window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_reparent_window_checked(c: *mut xcb_connection_t,
                                       window: xcb_window_t,
                                       parent: xcb_window_t, x: i16, y: i16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_reparent_window(c: *mut xcb_connection_t, window: xcb_window_t,
                               parent: xcb_window_t, x: i16, y: i16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_window_checked(c: *mut xcb_connection_t,
                                  window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_window(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_subwindows_checked(c: *mut xcb_connection_t,
                                      window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_subwindows(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_window_checked(c: *mut xcb_connection_t,
                                    window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_window(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_subwindows_checked(c: *mut xcb_connection_t,
                                        window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_subwindows(c: *mut xcb_connection_t,
                                window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list_serialize(_buffer:
                                                         *mut *mut libc::c_void,
                                                     value_mask: u16,
                                                     _aux:
                                                         *const xcb_configure_window_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_unpack(_buffer:
                                                      *const libc::c_void,
                                                  value_mask: u16,
                                                  _aux:
                                                      *mut xcb_configure_window_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_sizeof(_buffer:
                                                      *const libc::c_void,
                                                  value_mask: u16)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_configure_window_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_configure_window_checked(c: *mut xcb_connection_t,
                                        window: xcb_window_t, value_mask: u16,
                                        value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window(c: *mut xcb_connection_t,
                                window: xcb_window_t, value_mask: u16,
                                value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_aux_checked(c: *mut xcb_connection_t,
                                            window: xcb_window_t,
                                            value_mask: u16,
                                            value_list:
                                                *const xcb_configure_window_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_aux(c: *mut xcb_connection_t,
                                    window: xcb_window_t, value_mask: u16,
                                    value_list:
                                        *const xcb_configure_window_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list(R:
                                               *const xcb_configure_window_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_circulate_window_checked(c: *mut xcb_connection_t,
                                        direction: u8, window: xcb_window_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_circulate_window(c: *mut xcb_connection_t, direction: u8,
                                window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry(c: *mut xcb_connection_t,
                            drawable: xcb_drawable_t)
     -> xcb_get_geometry_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry_unchecked(c: *mut xcb_connection_t,
                                      drawable: xcb_drawable_t)
     -> xcb_get_geometry_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_get_geometry_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_geometry_reply_t;
}
extern "C" {
    pub fn xcb_query_tree_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_tree(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_unchecked(c: *mut xcb_connection_t,
                                    window: xcb_window_t)
     -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_children(R: *const xcb_query_tree_reply_t)
     -> *mut xcb_window_t;
}
extern "C" {
    pub fn xcb_query_tree_children_length(R: *const xcb_query_tree_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_tree_children_end(R: *const xcb_query_tree_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_tree_reply(c: *mut xcb_connection_t,
                                cookie: xcb_query_tree_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_tree_reply_t;
}
extern "C" {
    pub fn xcb_intern_atom_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_intern_atom(c: *mut xcb_connection_t, only_if_exists: u8,
                           name_len: u16, name: *const libc::c_char)
     -> xcb_intern_atom_cookie_t;
}
extern "C" {
    pub fn xcb_intern_atom_unchecked(c: *mut xcb_connection_t,
                                     only_if_exists: u8, name_len: u16,
                                     name: *const libc::c_char)
     -> xcb_intern_atom_cookie_t;
}
extern "C" {
    pub fn xcb_intern_atom_reply(c: *mut xcb_connection_t,
                                 cookie: xcb_intern_atom_cookie_t,
                                 e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_intern_atom_reply_t;
}
extern "C" {
    pub fn xcb_get_atom_name_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name(c: *mut xcb_connection_t, atom: xcb_atom_t)
     -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_unchecked(c: *mut xcb_connection_t,
                                       atom: xcb_atom_t)
     -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_name(R: *const xcb_get_atom_name_reply_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_get_atom_name_name_length(R: *const xcb_get_atom_name_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name_name_end(R: *const xcb_get_atom_name_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_atom_name_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_get_atom_name_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_atom_name_reply_t;
}
extern "C" {
    pub fn xcb_change_property_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_property_checked(c: *mut xcb_connection_t, mode: u8,
                                       window: xcb_window_t,
                                       property: xcb_atom_t,
                                       type_: xcb_atom_t, format: u8,
                                       data_len: u32,
                                       data: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_property(c: *mut xcb_connection_t, mode: u8,
                               window: xcb_window_t, property: xcb_atom_t,
                               type_: xcb_atom_t, format: u8, data_len: u32,
                               data: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_property_data(R: *const xcb_change_property_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_change_property_data_length(R:
                                               *const xcb_change_property_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_property_data_end(R:
                                            *const xcb_change_property_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_delete_property_checked(c: *mut xcb_connection_t,
                                       window: xcb_window_t,
                                       property: xcb_atom_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_delete_property(c: *mut xcb_connection_t, window: xcb_window_t,
                               property: xcb_atom_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_property(c: *mut xcb_connection_t, _delete: u8,
                            window: xcb_window_t, property: xcb_atom_t,
                            type_: xcb_atom_t, long_offset: u32,
                            long_length: u32) -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_unchecked(c: *mut xcb_connection_t, _delete: u8,
                                      window: xcb_window_t,
                                      property: xcb_atom_t, type_: xcb_atom_t,
                                      long_offset: u32, long_length: u32)
     -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_value(R: *const xcb_get_property_reply_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_get_property_value_length(R: *const xcb_get_property_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_property_value_end(R: *const xcb_get_property_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_property_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_get_property_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_property_reply_t;
}
extern "C" {
    pub fn xcb_list_properties_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_properties(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_unchecked(c: *mut xcb_connection_t,
                                         window: xcb_window_t)
     -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms(R: *const xcb_list_properties_reply_t)
     -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms_length(R:
                                                *const xcb_list_properties_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_properties_atoms_end(R:
                                             *const xcb_list_properties_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_properties_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_list_properties_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_properties_reply_t;
}
extern "C" {
    pub fn xcb_set_selection_owner_checked(c: *mut xcb_connection_t,
                                           owner: xcb_window_t,
                                           selection: xcb_atom_t,
                                           time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_selection_owner(c: *mut xcb_connection_t,
                                   owner: xcb_window_t, selection: xcb_atom_t,
                                   time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner(c: *mut xcb_connection_t,
                                   selection: xcb_atom_t)
     -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner_unchecked(c: *mut xcb_connection_t,
                                             selection: xcb_atom_t)
     -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_get_selection_owner_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_selection_owner_reply_t;
}
extern "C" {
    pub fn xcb_convert_selection_checked(c: *mut xcb_connection_t,
                                         requestor: xcb_window_t,
                                         selection: xcb_atom_t,
                                         target: xcb_atom_t,
                                         property: xcb_atom_t,
                                         time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_convert_selection(c: *mut xcb_connection_t,
                                 requestor: xcb_window_t,
                                 selection: xcb_atom_t, target: xcb_atom_t,
                                 property: xcb_atom_t, time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_send_event_checked(c: *mut xcb_connection_t, propagate: u8,
                                  destination: xcb_window_t, event_mask: u32,
                                  event: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_send_event(c: *mut xcb_connection_t, propagate: u8,
                          destination: xcb_window_t, event_mask: u32,
                          event: *const libc::c_char) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer(c: *mut xcb_connection_t, owner_events: u8,
                            grab_window: xcb_window_t, event_mask: u16,
                            pointer_mode: u8, keyboard_mode: u8,
                            confine_to: xcb_window_t, cursor: xcb_cursor_t,
                            time: xcb_timestamp_t)
     -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer_unchecked(c: *mut xcb_connection_t,
                                      owner_events: u8,
                                      grab_window: xcb_window_t,
                                      event_mask: u16, pointer_mode: u8,
                                      keyboard_mode: u8,
                                      confine_to: xcb_window_t,
                                      cursor: xcb_cursor_t,
                                      time: xcb_timestamp_t)
     -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_grab_pointer_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_grab_pointer_reply_t;
}
extern "C" {
    pub fn xcb_ungrab_pointer_checked(c: *mut xcb_connection_t,
                                      time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_pointer(c: *mut xcb_connection_t, time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_button_checked(c: *mut xcb_connection_t, owner_events: u8,
                                   grab_window: xcb_window_t, event_mask: u16,
                                   pointer_mode: u8, keyboard_mode: u8,
                                   confine_to: xcb_window_t,
                                   cursor: xcb_cursor_t, button: u8,
                                   modifiers: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_button(c: *mut xcb_connection_t, owner_events: u8,
                           grab_window: xcb_window_t, event_mask: u16,
                           pointer_mode: u8, keyboard_mode: u8,
                           confine_to: xcb_window_t, cursor: xcb_cursor_t,
                           button: u8, modifiers: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_button_checked(c: *mut xcb_connection_t, button: u8,
                                     grab_window: xcb_window_t,
                                     modifiers: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_button(c: *mut xcb_connection_t, button: u8,
                             grab_window: xcb_window_t, modifiers: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_active_pointer_grab_checked(c: *mut xcb_connection_t,
                                                  cursor: xcb_cursor_t,
                                                  time: xcb_timestamp_t,
                                                  event_mask: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_active_pointer_grab(c: *mut xcb_connection_t,
                                          cursor: xcb_cursor_t,
                                          time: xcb_timestamp_t,
                                          event_mask: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard(c: *mut xcb_connection_t, owner_events: u8,
                             grab_window: xcb_window_t, time: xcb_timestamp_t,
                             pointer_mode: u8, keyboard_mode: u8)
     -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard_unchecked(c: *mut xcb_connection_t,
                                       owner_events: u8,
                                       grab_window: xcb_window_t,
                                       time: xcb_timestamp_t,
                                       pointer_mode: u8, keyboard_mode: u8)
     -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_grab_keyboard_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_grab_keyboard_reply_t;
}
extern "C" {
    pub fn xcb_ungrab_keyboard_checked(c: *mut xcb_connection_t,
                                       time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_keyboard(c: *mut xcb_connection_t,
                               time: xcb_timestamp_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_key_checked(c: *mut xcb_connection_t, owner_events: u8,
                                grab_window: xcb_window_t, modifiers: u16,
                                key: xcb_keycode_t, pointer_mode: u8,
                                keyboard_mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_key(c: *mut xcb_connection_t, owner_events: u8,
                        grab_window: xcb_window_t, modifiers: u16,
                        key: xcb_keycode_t, pointer_mode: u8,
                        keyboard_mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_key_checked(c: *mut xcb_connection_t,
                                  key: xcb_keycode_t,
                                  grab_window: xcb_window_t, modifiers: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_key(c: *mut xcb_connection_t, key: xcb_keycode_t,
                          grab_window: xcb_window_t, modifiers: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_allow_events_checked(c: *mut xcb_connection_t, mode: u8,
                                    time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_allow_events(c: *mut xcb_connection_t, mode: u8,
                            time: xcb_timestamp_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_server_checked(c: *mut xcb_connection_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_server_checked(c: *mut xcb_connection_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer(c: *mut xcb_connection_t, window: xcb_window_t)
     -> xcb_query_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer_unchecked(c: *mut xcb_connection_t,
                                       window: xcb_window_t)
     -> xcb_query_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_query_pointer_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_pointer_reply_t;
}
extern "C" {
    pub fn xcb_timecoord_next(i: *mut xcb_timecoord_iterator_t);
}
extern "C" {
    pub fn xcb_timecoord_end(i: xcb_timecoord_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events(c: *mut xcb_connection_t,
                                 window: xcb_window_t, start: xcb_timestamp_t,
                                 stop: xcb_timestamp_t)
     -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_unchecked(c: *mut xcb_connection_t,
                                           window: xcb_window_t,
                                           start: xcb_timestamp_t,
                                           stop: xcb_timestamp_t)
     -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events(R:
                                            *const xcb_get_motion_events_reply_t)
     -> *mut xcb_timecoord_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events_length(R:
                                                   *const xcb_get_motion_events_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events_events_iterator(R:
                                                     *const xcb_get_motion_events_reply_t)
     -> xcb_timecoord_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_reply(c: *mut xcb_connection_t,
                                       cookie: xcb_get_motion_events_cookie_t,
                                       e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_motion_events_reply_t;
}
extern "C" {
    pub fn xcb_translate_coordinates(c: *mut xcb_connection_t,
                                     src_window: xcb_window_t,
                                     dst_window: xcb_window_t, src_x: i16,
                                     src_y: i16)
     -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    pub fn xcb_translate_coordinates_unchecked(c: *mut xcb_connection_t,
                                               src_window: xcb_window_t,
                                               dst_window: xcb_window_t,
                                               src_x: i16, src_y: i16)
     -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    pub fn xcb_translate_coordinates_reply(c: *mut xcb_connection_t,
                                           cookie:
                                               xcb_translate_coordinates_cookie_t,
                                           e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_translate_coordinates_reply_t;
}
extern "C" {
    pub fn xcb_warp_pointer_checked(c: *mut xcb_connection_t,
                                    src_window: xcb_window_t,
                                    dst_window: xcb_window_t, src_x: i16,
                                    src_y: i16, src_width: u16,
                                    src_height: u16, dst_x: i16, dst_y: i16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_warp_pointer(c: *mut xcb_connection_t,
                            src_window: xcb_window_t,
                            dst_window: xcb_window_t, src_x: i16, src_y: i16,
                            src_width: u16, src_height: u16, dst_x: i16,
                            dst_y: i16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_input_focus_checked(c: *mut xcb_connection_t,
                                       revert_to: u8, focus: xcb_window_t,
                                       time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_input_focus(c: *mut xcb_connection_t, revert_to: u8,
                               focus: xcb_window_t, time: xcb_timestamp_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus(c: *mut xcb_connection_t)
     -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_get_input_focus_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_input_focus_reply_t;
}
extern "C" {
    pub fn xcb_query_keymap(c: *mut xcb_connection_t)
     -> xcb_query_keymap_cookie_t;
}
extern "C" {
    pub fn xcb_query_keymap_unchecked(c: *mut xcb_connection_t)
     -> xcb_query_keymap_cookie_t;
}
extern "C" {
    pub fn xcb_query_keymap_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_query_keymap_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_keymap_reply_t;
}
extern "C" {
    pub fn xcb_open_font_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_open_font_checked(c: *mut xcb_connection_t, fid: xcb_font_t,
                                 name_len: u16, name: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_open_font(c: *mut xcb_connection_t, fid: xcb_font_t,
                         name_len: u16, name: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_open_font_name(R: *const xcb_open_font_request_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_open_font_name_length(R: *const xcb_open_font_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_open_font_name_end(R: *const xcb_open_font_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_close_font_checked(c: *mut xcb_connection_t, font: xcb_font_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_close_font(c: *mut xcb_connection_t, font: xcb_font_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fontprop_next(i: *mut xcb_fontprop_iterator_t);
}
extern "C" {
    pub fn xcb_fontprop_end(i: xcb_fontprop_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_charinfo_next(i: *mut xcb_charinfo_iterator_t);
}
extern "C" {
    pub fn xcb_charinfo_end(i: xcb_charinfo_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_font(c: *mut xcb_connection_t, font: xcb_fontable_t)
     -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_unchecked(c: *mut xcb_connection_t,
                                    font: xcb_fontable_t)
     -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_properties(R: *const xcb_query_font_reply_t)
     -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_query_font_properties_length(R: *const xcb_query_font_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_font_properties_iterator(R:
                                                  *const xcb_query_font_reply_t)
     -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos(R: *const xcb_query_font_reply_t)
     -> *mut xcb_charinfo_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos_length(R: *const xcb_query_font_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_font_char_infos_iterator(R:
                                                  *const xcb_query_font_reply_t)
     -> xcb_charinfo_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_reply(c: *mut xcb_connection_t,
                                cookie: xcb_query_font_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_font_reply_t;
}
extern "C" {
    pub fn xcb_query_text_extents_sizeof(_buffer: *const libc::c_void,
                                         string_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_text_extents(c: *mut xcb_connection_t,
                                  font: xcb_fontable_t, string_len: u32,
                                  string: *const xcb_char2b_t)
     -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    pub fn xcb_query_text_extents_unchecked(c: *mut xcb_connection_t,
                                            font: xcb_fontable_t,
                                            string_len: u32,
                                            string: *const xcb_char2b_t)
     -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    pub fn xcb_query_text_extents_reply(c: *mut xcb_connection_t,
                                        cookie:
                                            xcb_query_text_extents_cookie_t,
                                        e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_text_extents_reply_t;
}
extern "C" {
    pub fn xcb_str_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_str_name(R: *const xcb_str_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_str_name_length(R: *const xcb_str_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_str_name_end(R: *const xcb_str_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_str_next(i: *mut xcb_str_iterator_t);
}
extern "C" {
    pub fn xcb_str_end(i: xcb_str_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_fonts(c: *mut xcb_connection_t, max_names: u16,
                          pattern_len: u16, pattern: *const libc::c_char)
     -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_unchecked(c: *mut xcb_connection_t, max_names: u16,
                                    pattern_len: u16,
                                    pattern: *const libc::c_char)
     -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_names_length(R: *const xcb_list_fonts_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_names_iterator(R: *const xcb_list_fonts_reply_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_reply(c: *mut xcb_connection_t,
                                cookie: xcb_list_fonts_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_fonts_reply_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info(c: *mut xcb_connection_t, max_names: u16,
                                    pattern_len: u16,
                                    pattern: *const libc::c_char)
     -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_unchecked(c: *mut xcb_connection_t,
                                              max_names: u16,
                                              pattern_len: u16,
                                              pattern: *const libc::c_char)
     -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties(R:
                                                   *const xcb_list_fonts_with_info_reply_t)
     -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_length(R:
                                                          *const xcb_list_fonts_with_info_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_iterator(R:
                                                            *const xcb_list_fonts_with_info_reply_t)
     -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name(R:
                                             *const xcb_list_fonts_with_info_reply_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_length(R:
                                                    *const xcb_list_fonts_with_info_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_end(R:
                                                 *const xcb_list_fonts_with_info_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_list_fonts_with_info_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_fonts_with_info_reply_t;
}
extern "C" {
    pub fn xcb_set_font_path_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_font_path_checked(c: *mut xcb_connection_t, font_qty: u16,
                                     font: *const xcb_str_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_font_path(c: *mut xcb_connection_t, font_qty: u16,
                             font: *const xcb_str_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_font_path_font_length(R:
                                             *const xcb_set_font_path_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_font_path_font_iterator(R:
                                               *const xcb_set_font_path_request_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_get_font_path_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_font_path(c: *mut xcb_connection_t)
     -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_path_length(R: *const xcb_get_font_path_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_font_path_path_iterator(R:
                                               *const xcb_get_font_path_reply_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_get_font_path_reply(c: *mut xcb_connection_t,
                                   cookie: xcb_get_font_path_cookie_t,
                                   e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_font_path_reply_t;
}
extern "C" {
    pub fn xcb_create_pixmap_checked(c: *mut xcb_connection_t, depth: u8,
                                     pid: xcb_pixmap_t,
                                     drawable: xcb_drawable_t, width: u16,
                                     height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_pixmap(c: *mut xcb_connection_t, depth: u8,
                             pid: xcb_pixmap_t, drawable: xcb_drawable_t,
                             width: u16, height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_pixmap_checked(c: *mut xcb_connection_t,
                                   pixmap: xcb_pixmap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_pixmap(c: *mut xcb_connection_t, pixmap: xcb_pixmap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list_serialize(_buffer: *mut *mut libc::c_void,
                                              value_mask: u32,
                                              _aux:
                                                  *const xcb_create_gc_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_unpack(_buffer: *const libc::c_void,
                                           value_mask: u32,
                                           _aux:
                                               *mut xcb_create_gc_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_sizeof(_buffer: *const libc::c_void,
                                           value_mask: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_gc_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_create_gc_checked(c: *mut xcb_connection_t,
                                 cid: xcb_gcontext_t,
                                 drawable: xcb_drawable_t, value_mask: u32,
                                 value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc(c: *mut xcb_connection_t, cid: xcb_gcontext_t,
                         drawable: xcb_drawable_t, value_mask: u32,
                         value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_aux_checked(c: *mut xcb_connection_t,
                                     cid: xcb_gcontext_t,
                                     drawable: xcb_drawable_t,
                                     value_mask: u32,
                                     value_list:
                                         *const xcb_create_gc_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_aux(c: *mut xcb_connection_t, cid: xcb_gcontext_t,
                             drawable: xcb_drawable_t, value_mask: u32,
                             value_list: *const xcb_create_gc_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list(R: *const xcb_create_gc_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_change_gc_value_list_serialize(_buffer: *mut *mut libc::c_void,
                                              value_mask: u32,
                                              _aux:
                                                  *const xcb_change_gc_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_unpack(_buffer: *const libc::c_void,
                                           value_mask: u32,
                                           _aux:
                                               *mut xcb_change_gc_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_sizeof(_buffer: *const libc::c_void,
                                           value_mask: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_gc_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_gc_checked(c: *mut xcb_connection_t, gc: xcb_gcontext_t,
                                 value_mask: u32,
                                 value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc(c: *mut xcb_connection_t, gc: xcb_gcontext_t,
                         value_mask: u32, value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_aux_checked(c: *mut xcb_connection_t,
                                     gc: xcb_gcontext_t, value_mask: u32,
                                     value_list:
                                         *const xcb_change_gc_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_aux(c: *mut xcb_connection_t, gc: xcb_gcontext_t,
                             value_mask: u32,
                             value_list: *const xcb_change_gc_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_value_list(R: *const xcb_change_gc_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_copy_gc_checked(c: *mut xcb_connection_t,
                               src_gc: xcb_gcontext_t, dst_gc: xcb_gcontext_t,
                               value_mask: u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_gc(c: *mut xcb_connection_t, src_gc: xcb_gcontext_t,
                       dst_gc: xcb_gcontext_t, value_mask: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_dashes_checked(c: *mut xcb_connection_t,
                                  gc: xcb_gcontext_t, dash_offset: u16,
                                  dashes_len: u16, dashes: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes(c: *mut xcb_connection_t, gc: xcb_gcontext_t,
                          dash_offset: u16, dashes_len: u16,
                          dashes: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_dashes(R: *const xcb_set_dashes_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_length(R: *const xcb_set_dashes_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_end(R: *const xcb_set_dashes_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_sizeof(_buffer: *const libc::c_void,
                                          rectangles_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_checked(c: *mut xcb_connection_t,
                                           ordering: u8, gc: xcb_gcontext_t,
                                           clip_x_origin: i16,
                                           clip_y_origin: i16,
                                           rectangles_len: u32,
                                           rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles(c: *mut xcb_connection_t, ordering: u8,
                                   gc: xcb_gcontext_t, clip_x_origin: i16,
                                   clip_y_origin: i16, rectangles_len: u32,
                                   rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles(R:
                                                  *const xcb_set_clip_rectangles_request_t)
     -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_length(R:
                                                         *const xcb_set_clip_rectangles_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_iterator(R:
                                                           *const xcb_set_clip_rectangles_request_t)
     -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_free_gc_checked(c: *mut xcb_connection_t, gc: xcb_gcontext_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_gc(c: *mut xcb_connection_t, gc: xcb_gcontext_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_clear_area_checked(c: *mut xcb_connection_t, exposures: u8,
                                  window: xcb_window_t, x: i16, y: i16,
                                  width: u16, height: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_clear_area(c: *mut xcb_connection_t, exposures: u8,
                          window: xcb_window_t, x: i16, y: i16, width: u16,
                          height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_area_checked(c: *mut xcb_connection_t,
                                 src_drawable: xcb_drawable_t,
                                 dst_drawable: xcb_drawable_t,
                                 gc: xcb_gcontext_t, src_x: i16, src_y: i16,
                                 dst_x: i16, dst_y: i16, width: u16,
                                 height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_area(c: *mut xcb_connection_t,
                         src_drawable: xcb_drawable_t,
                         dst_drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                         src_x: i16, src_y: i16, dst_x: i16, dst_y: i16,
                         width: u16, height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_plane_checked(c: *mut xcb_connection_t,
                                  src_drawable: xcb_drawable_t,
                                  dst_drawable: xcb_drawable_t,
                                  gc: xcb_gcontext_t, src_x: i16, src_y: i16,
                                  dst_x: i16, dst_y: i16, width: u16,
                                  height: u16, bit_plane: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_plane(c: *mut xcb_connection_t,
                          src_drawable: xcb_drawable_t,
                          dst_drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                          src_x: i16, src_y: i16, dst_x: i16, dst_y: i16,
                          width: u16, height: u16, bit_plane: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_sizeof(_buffer: *const libc::c_void,
                                 points_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_point_checked(c: *mut xcb_connection_t,
                                  coordinate_mode: u8,
                                  drawable: xcb_drawable_t,
                                  gc: xcb_gcontext_t, points_len: u32,
                                  points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point(c: *mut xcb_connection_t, coordinate_mode: u8,
                          drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                          points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_points(R: *const xcb_poly_point_request_t)
     -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_point_points_length(R: *const xcb_poly_point_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_point_points_iterator(R: *const xcb_poly_point_request_t)
     -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_line_sizeof(_buffer: *const libc::c_void, points_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_line_checked(c: *mut xcb_connection_t,
                                 coordinate_mode: u8,
                                 drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                 points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line(c: *mut xcb_connection_t, coordinate_mode: u8,
                         drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                         points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line_points(R: *const xcb_poly_line_request_t)
     -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_line_points_length(R: *const xcb_poly_line_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_line_points_iterator(R: *const xcb_poly_line_request_t)
     -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_segment_next(i: *mut xcb_segment_iterator_t);
}
extern "C" {
    pub fn xcb_segment_end(i: xcb_segment_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_segment_sizeof(_buffer: *const libc::c_void,
                                   segments_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_segment_checked(c: *mut xcb_connection_t,
                                    drawable: xcb_drawable_t,
                                    gc: xcb_gcontext_t, segments_len: u32,
                                    segments: *const xcb_segment_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_segment(c: *mut xcb_connection_t,
                            drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                            segments_len: u32, segments: *const xcb_segment_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments(R: *const xcb_poly_segment_request_t)
     -> *mut xcb_segment_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments_length(R:
                                                *const xcb_poly_segment_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_segment_segments_iterator(R:
                                                  *const xcb_poly_segment_request_t)
     -> xcb_segment_iterator_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_sizeof(_buffer: *const libc::c_void,
                                     rectangles_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_rectangle_checked(c: *mut xcb_connection_t,
                                      drawable: xcb_drawable_t,
                                      gc: xcb_gcontext_t, rectangles_len: u32,
                                      rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle(c: *mut xcb_connection_t,
                              drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                              rectangles_len: u32,
                              rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles(R:
                                             *const xcb_poly_rectangle_request_t)
     -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_length(R:
                                                    *const xcb_poly_rectangle_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_iterator(R:
                                                      *const xcb_poly_rectangle_request_t)
     -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_arc_sizeof(_buffer: *const libc::c_void, arcs_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_arc_checked(c: *mut xcb_connection_t,
                                drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                arcs_len: u32, arcs: *const xcb_arc_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc(c: *mut xcb_connection_t, drawable: xcb_drawable_t,
                        gc: xcb_gcontext_t, arcs_len: u32,
                        arcs: *const xcb_arc_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs(R: *const xcb_poly_arc_request_t)
     -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_length(R: *const xcb_poly_arc_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_iterator(R: *const xcb_poly_arc_request_t)
     -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_fill_poly_sizeof(_buffer: *const libc::c_void, points_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_fill_poly_checked(c: *mut xcb_connection_t,
                                 drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                 shape: u8, coordinate_mode: u8,
                                 points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly(c: *mut xcb_connection_t, drawable: xcb_drawable_t,
                         gc: xcb_gcontext_t, shape: u8, coordinate_mode: u8,
                         points_len: u32, points: *const xcb_point_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly_points(R: *const xcb_fill_poly_request_t)
     -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_fill_poly_points_length(R: *const xcb_fill_poly_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_fill_poly_points_iterator(R: *const xcb_fill_poly_request_t)
     -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_sizeof(_buffer: *const libc::c_void,
                                          rectangles_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_checked(c: *mut xcb_connection_t,
                                           drawable: xcb_drawable_t,
                                           gc: xcb_gcontext_t,
                                           rectangles_len: u32,
                                           rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle(c: *mut xcb_connection_t,
                                   drawable: xcb_drawable_t,
                                   gc: xcb_gcontext_t, rectangles_len: u32,
                                   rectangles: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles(R:
                                                  *const xcb_poly_fill_rectangle_request_t)
     -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_length(R:
                                                         *const xcb_poly_fill_rectangle_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_iterator(R:
                                                           *const xcb_poly_fill_rectangle_request_t)
     -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_sizeof(_buffer: *const libc::c_void,
                                    arcs_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_arc_checked(c: *mut xcb_connection_t,
                                     drawable: xcb_drawable_t,
                                     gc: xcb_gcontext_t, arcs_len: u32,
                                     arcs: *const xcb_arc_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc(c: *mut xcb_connection_t,
                             drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                             arcs_len: u32, arcs: *const xcb_arc_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs(R: *const xcb_poly_fill_arc_request_t)
     -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_length(R:
                                             *const xcb_poly_fill_arc_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_iterator(R:
                                               *const xcb_poly_fill_arc_request_t)
     -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_put_image_sizeof(_buffer: *const libc::c_void, data_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_put_image_checked(c: *mut xcb_connection_t, format: u8,
                                 drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                                 width: u16, height: u16, dst_x: i16,
                                 dst_y: i16, left_pad: u8, depth: u8,
                                 data_len: u32, data: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image(c: *mut xcb_connection_t, format: u8,
                         drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                         width: u16, height: u16, dst_x: i16, dst_y: i16,
                         left_pad: u8, depth: u8, data_len: u32,
                         data: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image_data(R: *const xcb_put_image_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_put_image_data_length(R: *const xcb_put_image_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_put_image_data_end(R: *const xcb_put_image_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_image_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_image(c: *mut xcb_connection_t, format: u8,
                         drawable: xcb_drawable_t, x: i16, y: i16, width: u16,
                         height: u16, plane_mask: u32)
     -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_unchecked(c: *mut xcb_connection_t, format: u8,
                                   drawable: xcb_drawable_t, x: i16, y: i16,
                                   width: u16, height: u16, plane_mask: u32)
     -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_data(R: *const xcb_get_image_reply_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_get_image_data_length(R: *const xcb_get_image_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_image_data_end(R: *const xcb_get_image_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_image_reply(c: *mut xcb_connection_t,
                               cookie: xcb_get_image_cookie_t,
                               e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_image_reply_t;
}
extern "C" {
    pub fn xcb_poly_text_8_sizeof(_buffer: *const libc::c_void,
                                  items_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_text_8_checked(c: *mut xcb_connection_t,
                                   drawable: xcb_drawable_t,
                                   gc: xcb_gcontext_t, x: i16, y: i16,
                                   items_len: u32, items: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_8(c: *mut xcb_connection_t, drawable: xcb_drawable_t,
                           gc: xcb_gcontext_t, x: i16, y: i16, items_len: u32,
                           items: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_8_items(R: *const xcb_poly_text_8_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_8_items_length(R: *const xcb_poly_text_8_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_text_8_items_end(R: *const xcb_poly_text_8_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_text_16_sizeof(_buffer: *const libc::c_void,
                                   items_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_text_16_checked(c: *mut xcb_connection_t,
                                    drawable: xcb_drawable_t,
                                    gc: xcb_gcontext_t, x: i16, y: i16,
                                    items_len: u32, items: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16(c: *mut xcb_connection_t,
                            drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                            x: i16, y: i16, items_len: u32, items: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16_items(R: *const xcb_poly_text_16_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_16_items_length(R: *const xcb_poly_text_16_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_poly_text_16_items_end(R: *const xcb_poly_text_16_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_8_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_image_text_8_checked(c: *mut xcb_connection_t, string_len: u8,
                                    drawable: xcb_drawable_t,
                                    gc: xcb_gcontext_t, x: i16, y: i16,
                                    string: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8(c: *mut xcb_connection_t, string_len: u8,
                            drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                            x: i16, y: i16, string: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8_string(R: *const xcb_image_text_8_request_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_image_text_8_string_length(R:
                                              *const xcb_image_text_8_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_image_text_8_string_end(R: *const xcb_image_text_8_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_16_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_image_text_16_checked(c: *mut xcb_connection_t, string_len: u8,
                                     drawable: xcb_drawable_t,
                                     gc: xcb_gcontext_t, x: i16, y: i16,
                                     string: *const xcb_char2b_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16(c: *mut xcb_connection_t, string_len: u8,
                             drawable: xcb_drawable_t, gc: xcb_gcontext_t,
                             x: i16, y: i16, string: *const xcb_char2b_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16_string(R: *const xcb_image_text_16_request_t)
     -> *mut xcb_char2b_t;
}
extern "C" {
    pub fn xcb_image_text_16_string_length(R:
                                               *const xcb_image_text_16_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_image_text_16_string_iterator(R:
                                                 *const xcb_image_text_16_request_t)
     -> xcb_char2b_iterator_t;
}
extern "C" {
    pub fn xcb_create_colormap_checked(c: *mut xcb_connection_t, alloc: u8,
                                       mid: xcb_colormap_t,
                                       window: xcb_window_t,
                                       visual: xcb_visualid_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_colormap(c: *mut xcb_connection_t, alloc: u8,
                               mid: xcb_colormap_t, window: xcb_window_t,
                               visual: xcb_visualid_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colormap_checked(c: *mut xcb_connection_t,
                                     cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colormap(c: *mut xcb_connection_t, cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_colormap_and_free_checked(c: *mut xcb_connection_t,
                                              mid: xcb_colormap_t,
                                              src_cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_colormap_and_free(c: *mut xcb_connection_t,
                                      mid: xcb_colormap_t,
                                      src_cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_install_colormap_checked(c: *mut xcb_connection_t,
                                        cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_install_colormap(c: *mut xcb_connection_t,
                                cmap: xcb_colormap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_uninstall_colormap_checked(c: *mut xcb_connection_t,
                                          cmap: xcb_colormap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_uninstall_colormap(c: *mut xcb_connection_t,
                                  cmap: xcb_colormap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps(c: *mut xcb_connection_t,
                                        window: xcb_window_t)
     -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_unchecked(c: *mut xcb_connection_t,
                                                  window: xcb_window_t)
     -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps(R:
                                                  *const xcb_list_installed_colormaps_reply_t)
     -> *mut xcb_colormap_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_length(R:
                                                         *const xcb_list_installed_colormaps_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_end(R:
                                                      *const xcb_list_installed_colormaps_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_reply(c: *mut xcb_connection_t,
                                              cookie:
                                                  xcb_list_installed_colormaps_cookie_t,
                                              e:
                                                  *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_installed_colormaps_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                           red: u16, green: u16, blue: u16)
     -> xcb_alloc_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_unchecked(c: *mut xcb_connection_t,
                                     cmap: xcb_colormap_t, red: u16,
                                     green: u16, blue: u16)
     -> xcb_alloc_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_reply(c: *mut xcb_connection_t,
                                 cookie: xcb_alloc_color_cookie_t,
                                 e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_named_color(c: *mut xcb_connection_t,
                                 cmap: xcb_colormap_t, name_len: u16,
                                 name: *const libc::c_char)
     -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_unchecked(c: *mut xcb_connection_t,
                                           cmap: xcb_colormap_t,
                                           name_len: u16,
                                           name: *const libc::c_char)
     -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_reply(c: *mut xcb_connection_t,
                                       cookie: xcb_alloc_named_color_cookie_t,
                                       e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_named_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells(c: *mut xcb_connection_t, contiguous: u8,
                                 cmap: xcb_colormap_t, colors: u16,
                                 planes: u16)
     -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_unchecked(c: *mut xcb_connection_t,
                                           contiguous: u8,
                                           cmap: xcb_colormap_t, colors: u16,
                                           planes: u16)
     -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels(R:
                                            *const xcb_alloc_color_cells_reply_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_length(R:
                                                   *const xcb_alloc_color_cells_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_end(R:
                                                *const xcb_alloc_color_cells_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks(R:
                                           *const xcb_alloc_color_cells_reply_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_length(R:
                                                  *const xcb_alloc_color_cells_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_end(R:
                                               *const xcb_alloc_color_cells_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_reply(c: *mut xcb_connection_t,
                                       cookie: xcb_alloc_color_cells_cookie_t,
                                       e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_color_cells_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes(c: *mut xcb_connection_t, contiguous: u8,
                                  cmap: xcb_colormap_t, colors: u16,
                                  reds: u16, greens: u16, blues: u16)
     -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_unchecked(c: *mut xcb_connection_t,
                                            contiguous: u8,
                                            cmap: xcb_colormap_t, colors: u16,
                                            reds: u16, greens: u16,
                                            blues: u16)
     -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels(R:
                                             *const xcb_alloc_color_planes_reply_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_length(R:
                                                    *const xcb_alloc_color_planes_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_end(R:
                                                 *const xcb_alloc_color_planes_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_reply(c: *mut xcb_connection_t,
                                        cookie:
                                            xcb_alloc_color_planes_cookie_t,
                                        e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_alloc_color_planes_reply_t;
}
extern "C" {
    pub fn xcb_free_colors_sizeof(_buffer: *const libc::c_void,
                                  pixels_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_free_colors_checked(c: *mut xcb_connection_t,
                                   cmap: xcb_colormap_t, plane_mask: u32,
                                   pixels_len: u32, pixels: *const u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colors(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                           plane_mask: u32, pixels_len: u32,
                           pixels: *const u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colors_pixels(R: *const xcb_free_colors_request_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_free_colors_pixels_length(R: *const xcb_free_colors_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_free_colors_pixels_end(R: *const xcb_free_colors_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_coloritem_next(i: *mut xcb_coloritem_iterator_t);
}
extern "C" {
    pub fn xcb_coloritem_end(i: xcb_coloritem_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_store_colors_sizeof(_buffer: *const libc::c_void,
                                   items_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_store_colors_checked(c: *mut xcb_connection_t,
                                    cmap: xcb_colormap_t, items_len: u32,
                                    items: *const xcb_coloritem_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_colors(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                            items_len: u32, items: *const xcb_coloritem_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_colors_items(R: *const xcb_store_colors_request_t)
     -> *mut xcb_coloritem_t;
}
extern "C" {
    pub fn xcb_store_colors_items_length(R: *const xcb_store_colors_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_store_colors_items_iterator(R:
                                               *const xcb_store_colors_request_t)
     -> xcb_coloritem_iterator_t;
}
extern "C" {
    pub fn xcb_store_named_color_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_store_named_color_checked(c: *mut xcb_connection_t, flags: u8,
                                         cmap: xcb_colormap_t, pixel: u32,
                                         name_len: u16,
                                         name: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color(c: *mut xcb_connection_t, flags: u8,
                                 cmap: xcb_colormap_t, pixel: u32,
                                 name_len: u16, name: *const libc::c_char)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color_name(R:
                                          *const xcb_store_named_color_request_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_store_named_color_name_length(R:
                                                 *const xcb_store_named_color_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_store_named_color_name_end(R:
                                              *const xcb_store_named_color_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_rgb_next(i: *mut xcb_rgb_iterator_t);
}
extern "C" {
    pub fn xcb_rgb_end(i: xcb_rgb_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_sizeof(_buffer: *const libc::c_void,
                                   pixels_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_colors(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                            pixels_len: u32, pixels: *const u32)
     -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_unchecked(c: *mut xcb_connection_t,
                                      cmap: xcb_colormap_t, pixels_len: u32,
                                      pixels: *const u32)
     -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_colors(R: *const xcb_query_colors_reply_t)
     -> *mut xcb_rgb_t;
}
extern "C" {
    pub fn xcb_query_colors_colors_length(R: *const xcb_query_colors_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_colors_colors_iterator(R:
                                                *const xcb_query_colors_reply_t)
     -> xcb_rgb_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_query_colors_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_colors_reply_t;
}
extern "C" {
    pub fn xcb_lookup_color_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_lookup_color(c: *mut xcb_connection_t, cmap: xcb_colormap_t,
                            name_len: u16, name: *const libc::c_char)
     -> xcb_lookup_color_cookie_t;
}
extern "C" {
    pub fn xcb_lookup_color_unchecked(c: *mut xcb_connection_t,
                                      cmap: xcb_colormap_t, name_len: u16,
                                      name: *const libc::c_char)
     -> xcb_lookup_color_cookie_t;
}
extern "C" {
    pub fn xcb_lookup_color_reply(c: *mut xcb_connection_t,
                                  cookie: xcb_lookup_color_cookie_t,
                                  e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_lookup_color_reply_t;
}
extern "C" {
    pub fn xcb_create_cursor_checked(c: *mut xcb_connection_t,
                                     cid: xcb_cursor_t, source: xcb_pixmap_t,
                                     mask: xcb_pixmap_t, fore_red: u16,
                                     fore_green: u16, fore_blue: u16,
                                     back_red: u16, back_green: u16,
                                     back_blue: u16, x: u16, y: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_cursor(c: *mut xcb_connection_t, cid: xcb_cursor_t,
                             source: xcb_pixmap_t, mask: xcb_pixmap_t,
                             fore_red: u16, fore_green: u16, fore_blue: u16,
                             back_red: u16, back_green: u16, back_blue: u16,
                             x: u16, y: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_glyph_cursor_checked(c: *mut xcb_connection_t,
                                           cid: xcb_cursor_t,
                                           source_font: xcb_font_t,
                                           mask_font: xcb_font_t,
                                           source_char: u16, mask_char: u16,
                                           fore_red: u16, fore_green: u16,
                                           fore_blue: u16, back_red: u16,
                                           back_green: u16, back_blue: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_glyph_cursor(c: *mut xcb_connection_t,
                                   cid: xcb_cursor_t, source_font: xcb_font_t,
                                   mask_font: xcb_font_t, source_char: u16,
                                   mask_char: u16, fore_red: u16,
                                   fore_green: u16, fore_blue: u16,
                                   back_red: u16, back_green: u16,
                                   back_blue: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_cursor_checked(c: *mut xcb_connection_t,
                                   cursor: xcb_cursor_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_cursor(c: *mut xcb_connection_t, cursor: xcb_cursor_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_recolor_cursor_checked(c: *mut xcb_connection_t,
                                      cursor: xcb_cursor_t, fore_red: u16,
                                      fore_green: u16, fore_blue: u16,
                                      back_red: u16, back_green: u16,
                                      back_blue: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_recolor_cursor(c: *mut xcb_connection_t, cursor: xcb_cursor_t,
                              fore_red: u16, fore_green: u16, fore_blue: u16,
                              back_red: u16, back_green: u16, back_blue: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size(c: *mut xcb_connection_t, _class: u8,
                               drawable: xcb_drawable_t, width: u16,
                               height: u16) -> xcb_query_best_size_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size_unchecked(c: *mut xcb_connection_t, _class: u8,
                                         drawable: xcb_drawable_t, width: u16,
                                         height: u16)
     -> xcb_query_best_size_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_query_best_size_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_best_size_reply_t;
}
extern "C" {
    pub fn xcb_query_extension_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_query_extension(c: *mut xcb_connection_t, name_len: u16,
                               name: *const libc::c_char)
     -> xcb_query_extension_cookie_t;
}
extern "C" {
    pub fn xcb_query_extension_unchecked(c: *mut xcb_connection_t,
                                         name_len: u16,
                                         name: *const libc::c_char)
     -> xcb_query_extension_cookie_t;
}
extern "C" {
    pub fn xcb_query_extension_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_query_extension_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_list_extensions_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_extensions(c: *mut xcb_connection_t)
     -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_unchecked(c: *mut xcb_connection_t)
     -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_names_length(R:
                                                *const xcb_list_extensions_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_extensions_names_iterator(R:
                                                  *const xcb_list_extensions_reply_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_list_extensions_reply(c: *mut xcb_connection_t,
                                     cookie: xcb_list_extensions_cookie_t,
                                     e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_extensions_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_checked(c: *mut xcb_connection_t,
                                               keycode_count: u8,
                                               first_keycode: xcb_keycode_t,
                                               keysyms_per_keycode: u8,
                                               keysyms: *const xcb_keysym_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping(c: *mut xcb_connection_t,
                                       keycode_count: u8,
                                       first_keycode: xcb_keycode_t,
                                       keysyms_per_keycode: u8,
                                       keysyms: *const xcb_keysym_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms(R:
                                                   *const xcb_change_keyboard_mapping_request_t)
     -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_length(R:
                                                          *const xcb_change_keyboard_mapping_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_end(R:
                                                       *const xcb_change_keyboard_mapping_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping(c: *mut xcb_connection_t,
                                    first_keycode: xcb_keycode_t, count: u8)
     -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_unchecked(c: *mut xcb_connection_t,
                                              first_keycode: xcb_keycode_t,
                                              count: u8)
     -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms(R:
                                                *const xcb_get_keyboard_mapping_reply_t)
     -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_length(R:
                                                       *const xcb_get_keyboard_mapping_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_end(R:
                                                    *const xcb_get_keyboard_mapping_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_get_keyboard_mapping_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_keyboard_mapping_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_serialize(_buffer:
                                                                *mut *mut libc::c_void,
                                                            value_mask: u32,
                                                            _aux:
                                                                *const xcb_change_keyboard_control_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_unpack(_buffer:
                                                             *const libc::c_void,
                                                         value_mask: u32,
                                                         _aux:
                                                             *mut xcb_change_keyboard_control_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_sizeof(_buffer:
                                                             *const libc::c_void,
                                                         value_mask: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_checked(c: *mut xcb_connection_t,
                                               value_mask: u32,
                                               value_list:
                                                   *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control(c: *mut xcb_connection_t,
                                       value_mask: u32,
                                       value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_aux_checked(c: *mut xcb_connection_t,
                                                   value_mask: u32,
                                                   value_list:
                                                       *const xcb_change_keyboard_control_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_aux(c: *mut xcb_connection_t,
                                           value_mask: u32,
                                           value_list:
                                               *const xcb_change_keyboard_control_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list(R:
                                                      *const xcb_change_keyboard_control_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_get_keyboard_control(c: *mut xcb_connection_t)
     -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_control_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_control_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_get_keyboard_control_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_keyboard_control_reply_t;
}
extern "C" {
    pub fn xcb_bell_checked(c: *mut xcb_connection_t, percent: i8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_bell(c: *mut xcb_connection_t, percent: i8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_pointer_control_checked(c: *mut xcb_connection_t,
                                              acceleration_numerator: i16,
                                              acceleration_denominator: i16,
                                              threshold: i16,
                                              do_acceleration: u8,
                                              do_threshold: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_pointer_control(c: *mut xcb_connection_t,
                                      acceleration_numerator: i16,
                                      acceleration_denominator: i16,
                                      threshold: i16, do_acceleration: u8,
                                      do_threshold: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control(c: *mut xcb_connection_t)
     -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_get_pointer_control_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_pointer_control_reply_t;
}
extern "C" {
    pub fn xcb_set_screen_saver_checked(c: *mut xcb_connection_t,
                                        timeout: i16, interval: i16,
                                        prefer_blanking: u8,
                                        allow_exposures: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_screen_saver(c: *mut xcb_connection_t, timeout: i16,
                                interval: i16, prefer_blanking: u8,
                                allow_exposures: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver(c: *mut xcb_connection_t)
     -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver_reply(c: *mut xcb_connection_t,
                                      cookie: xcb_get_screen_saver_cookie_t,
                                      e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_screen_saver_reply_t;
}
extern "C" {
    pub fn xcb_change_hosts_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_hosts_checked(c: *mut xcb_connection_t, mode: u8,
                                    family: u8, address_len: u16,
                                    address: *const u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_hosts(c: *mut xcb_connection_t, mode: u8, family: u8,
                            address_len: u16, address: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_hosts_address(R: *const xcb_change_hosts_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_change_hosts_address_length(R:
                                               *const xcb_change_hosts_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_change_hosts_address_end(R: *const xcb_change_hosts_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_host_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_host_address(R: *const xcb_host_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_host_address_length(R: *const xcb_host_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_host_address_end(R: *const xcb_host_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_host_next(i: *mut xcb_host_iterator_t);
}
extern "C" {
    pub fn xcb_host_end(i: xcb_host_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_sizeof(_buffer: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_hosts(c: *mut xcb_connection_t)
     -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_unchecked(c: *mut xcb_connection_t)
     -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_length(R: *const xcb_list_hosts_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_iterator(R: *const xcb_list_hosts_reply_t)
     -> xcb_host_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_reply(c: *mut xcb_connection_t,
                                cookie: xcb_list_hosts_cookie_t,
                                e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_list_hosts_reply_t;
}
extern "C" {
    pub fn xcb_set_access_control_checked(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_access_control(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_close_down_mode_checked(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_close_down_mode(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_kill_client_checked(c: *mut xcb_connection_t, resource: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_kill_client(c: *mut xcb_connection_t, resource: u32)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_rotate_properties_checked(c: *mut xcb_connection_t,
                                         window: xcb_window_t, atoms_len: u16,
                                         delta: i16, atoms: *const xcb_atom_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties(c: *mut xcb_connection_t,
                                 window: xcb_window_t, atoms_len: u16,
                                 delta: i16, atoms: *const xcb_atom_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms(R:
                                           *const xcb_rotate_properties_request_t)
     -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_length(R:
                                                  *const xcb_rotate_properties_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_end(R:
                                               *const xcb_rotate_properties_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_force_screen_saver_checked(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_force_screen_saver(c: *mut xcb_connection_t, mode: u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_pointer_mapping(c: *mut xcb_connection_t, map_len: u8,
                                   map: *const u8)
     -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_unchecked(c: *mut xcb_connection_t,
                                             map_len: u8, map: *const u8)
     -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_set_pointer_mapping_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_set_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping(c: *mut xcb_connection_t)
     -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map(R:
                                           *const xcb_get_pointer_mapping_reply_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_length(R:
                                                  *const xcb_get_pointer_mapping_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_end(R:
                                               *const xcb_get_pointer_mapping_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_reply(c: *mut xcb_connection_t,
                                         cookie:
                                             xcb_get_pointer_mapping_cookie_t,
                                         e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_set_modifier_mapping(c: *mut xcb_connection_t,
                                    keycodes_per_modifier: u8,
                                    keycodes: *const xcb_keycode_t)
     -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_unchecked(c: *mut xcb_connection_t,
                                              keycodes_per_modifier: u8,
                                              keycodes: *const xcb_keycode_t)
     -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_set_modifier_mapping_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_set_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping(c: *mut xcb_connection_t)
     -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_unchecked(c: *mut xcb_connection_t)
     -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes(R:
                                                 *const xcb_get_modifier_mapping_reply_t)
     -> *mut xcb_keycode_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_length(R:
                                                        *const xcb_get_modifier_mapping_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_end(R:
                                                     *const xcb_get_modifier_mapping_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_get_modifier_mapping_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_get_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_no_operation_checked(c: *mut xcb_connection_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_no_operation(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_auth_info_t {
    pub namelen: libc::c_int,
    pub name: *mut libc::c_char,
    pub datalen: libc::c_int,
    pub data: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_xcb_auth_info_t() {
    assert_eq!(::std::mem::size_of::<xcb_auth_info_t>() , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_auth_info_t>() , 8usize);
}
impl Clone for xcb_auth_info_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn xcb_flush(c: *mut xcb_connection_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_get_maximum_request_length(c: *mut xcb_connection_t) -> u32;
}
extern "C" {
    pub fn xcb_prefetch_maximum_request_length(c: *mut xcb_connection_t);
}
extern "C" {
    pub fn xcb_wait_for_event(c: *mut xcb_connection_t)
     -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_poll_for_event(c: *mut xcb_connection_t)
     -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_poll_for_queued_event(c: *mut xcb_connection_t)
     -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_special_event([u8; 0]);
pub type xcb_special_event_t = xcb_special_event;
extern "C" {
    pub fn xcb_poll_for_special_event(c: *mut xcb_connection_t,
                                      se: *mut xcb_special_event_t)
     -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_wait_for_special_event(c: *mut xcb_connection_t,
                                      se: *mut xcb_special_event_t)
     -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_extension_t([u8; 0]);
extern "C" {
    pub fn xcb_register_for_special_xge(c: *mut xcb_connection_t,
                                        ext: *mut xcb_extension_t, eid: u32,
                                        stamp: *mut u32)
     -> *mut xcb_special_event_t;
}
extern "C" {
    pub fn xcb_unregister_for_special_event(c: *mut xcb_connection_t,
                                            se: *mut xcb_special_event_t);
}
extern "C" {
    pub fn xcb_request_check(c: *mut xcb_connection_t,
                             cookie: xcb_void_cookie_t)
     -> *mut xcb_generic_error_t;
}
extern "C" {
    pub fn xcb_discard_reply(c: *mut xcb_connection_t,
                             sequence: libc::c_uint);
}
extern "C" {
    pub fn xcb_discard_reply64(c: *mut xcb_connection_t, sequence: u64);
}
extern "C" {
    pub fn xcb_get_extension_data(c: *mut xcb_connection_t,
                                  ext: *mut xcb_extension_t)
     -> *const xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_prefetch_extension_data(c: *mut xcb_connection_t,
                                       ext: *mut xcb_extension_t);
}
extern "C" {
    pub fn xcb_get_setup(c: *mut xcb_connection_t) -> *const xcb_setup_t;
}
extern "C" {
    pub fn xcb_get_file_descriptor(c: *mut xcb_connection_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_connection_has_error(c: *mut xcb_connection_t) -> libc::c_int;
}
extern "C" {
    pub fn xcb_connect_to_fd(fd: libc::c_int, auth_info: *mut xcb_auth_info_t)
     -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_disconnect(c: *mut xcb_connection_t);
}
extern "C" {
    pub fn xcb_parse_display(name: *const libc::c_char,
                             host: *mut *mut libc::c_char,
                             display: *mut libc::c_int,
                             screen: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn xcb_connect(displayname: *const libc::c_char,
                       screenp: *mut libc::c_int) -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_connect_to_display_with_auth_info(display: *const libc::c_char,
                                                 auth: *mut xcb_auth_info_t,
                                                 screen: *mut libc::c_int)
     -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_generate_id(c: *mut xcb_connection_t) -> u32;
}
extern "C" {
    #[link_name = "xcb_render_id"]
    pub static mut xcb_render_id: xcb_extension_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_render_pict_type_t {
    XCB_RENDER_PICT_TYPE_INDEXED = 0,
    XCB_RENDER_PICT_TYPE_DIRECT = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_render_picture_enum_t { XCB_RENDER_PICTURE_NONE = 0, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_render_pict_op_t {
    XCB_RENDER_PICT_OP_CLEAR = 0,
    XCB_RENDER_PICT_OP_SRC = 1,
    XCB_RENDER_PICT_OP_DST = 2,
    XCB_RENDER_PICT_OP_OVER = 3,
    XCB_RENDER_PICT_OP_OVER_REVERSE = 4,
    XCB_RENDER_PICT_OP_IN = 5,
    XCB_RENDER_PICT_OP_IN_REVERSE = 6,
    XCB_RENDER_PICT_OP_OUT = 7,
    XCB_RENDER_PICT_OP_OUT_REVERSE = 8,
    XCB_RENDER_PICT_OP_ATOP = 9,
    XCB_RENDER_PICT_OP_ATOP_REVERSE = 10,
    XCB_RENDER_PICT_OP_XOR = 11,
    XCB_RENDER_PICT_OP_ADD = 12,
    XCB_RENDER_PICT_OP_SATURATE = 13,
    XCB_RENDER_PICT_OP_DISJOINT_CLEAR = 16,
    XCB_RENDER_PICT_OP_DISJOINT_SRC = 17,
    XCB_RENDER_PICT_OP_DISJOINT_DST = 18,
    XCB_RENDER_PICT_OP_DISJOINT_OVER = 19,
    XCB_RENDER_PICT_OP_DISJOINT_OVER_REVERSE = 20,
    XCB_RENDER_PICT_OP_DISJOINT_IN = 21,
    XCB_RENDER_PICT_OP_DISJOINT_IN_REVERSE = 22,
    XCB_RENDER_PICT_OP_DISJOINT_OUT = 23,
    XCB_RENDER_PICT_OP_DISJOINT_OUT_REVERSE = 24,
    XCB_RENDER_PICT_OP_DISJOINT_ATOP = 25,
    XCB_RENDER_PICT_OP_DISJOINT_ATOP_REVERSE = 26,
    XCB_RENDER_PICT_OP_DISJOINT_XOR = 27,
    XCB_RENDER_PICT_OP_CONJOINT_CLEAR = 32,
    XCB_RENDER_PICT_OP_CONJOINT_SRC = 33,
    XCB_RENDER_PICT_OP_CONJOINT_DST = 34,
    XCB_RENDER_PICT_OP_CONJOINT_OVER = 35,
    XCB_RENDER_PICT_OP_CONJOINT_OVER_REVERSE = 36,
    XCB_RENDER_PICT_OP_CONJOINT_IN = 37,
    XCB_RENDER_PICT_OP_CONJOINT_IN_REVERSE = 38,
    XCB_RENDER_PICT_OP_CONJOINT_OUT = 39,
    XCB_RENDER_PICT_OP_CONJOINT_OUT_REVERSE = 40,
    XCB_RENDER_PICT_OP_CONJOINT_ATOP = 41,
    XCB_RENDER_PICT_OP_CONJOINT_ATOP_REVERSE = 42,
    XCB_RENDER_PICT_OP_CONJOINT_XOR = 43,
    XCB_RENDER_PICT_OP_MULTIPLY = 48,
    XCB_RENDER_PICT_OP_SCREEN = 49,
    XCB_RENDER_PICT_OP_OVERLAY = 50,
    XCB_RENDER_PICT_OP_DARKEN = 51,
    XCB_RENDER_PICT_OP_LIGHTEN = 52,
    XCB_RENDER_PICT_OP_COLOR_DODGE = 53,
    XCB_RENDER_PICT_OP_COLOR_BURN = 54,
    XCB_RENDER_PICT_OP_HARD_LIGHT = 55,
    XCB_RENDER_PICT_OP_SOFT_LIGHT = 56,
    XCB_RENDER_PICT_OP_DIFFERENCE = 57,
    XCB_RENDER_PICT_OP_EXCLUSION = 58,
    XCB_RENDER_PICT_OP_HSL_HUE = 59,
    XCB_RENDER_PICT_OP_HSL_SATURATION = 60,
    XCB_RENDER_PICT_OP_HSL_COLOR = 61,
    XCB_RENDER_PICT_OP_HSL_LUMINOSITY = 62,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_render_poly_edge_t {
    XCB_RENDER_POLY_EDGE_SHARP = 0,
    XCB_RENDER_POLY_EDGE_SMOOTH = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_render_poly_mode_t {
    XCB_RENDER_POLY_MODE_PRECISE = 0,
    XCB_RENDER_POLY_MODE_IMPRECISE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_render_cp_t {
    XCB_RENDER_CP_REPEAT = 1,
    XCB_RENDER_CP_ALPHA_MAP = 2,
    XCB_RENDER_CP_ALPHA_X_ORIGIN = 4,
    XCB_RENDER_CP_ALPHA_Y_ORIGIN = 8,
    XCB_RENDER_CP_CLIP_X_ORIGIN = 16,
    XCB_RENDER_CP_CLIP_Y_ORIGIN = 32,
    XCB_RENDER_CP_CLIP_MASK = 64,
    XCB_RENDER_CP_GRAPHICS_EXPOSURE = 128,
    XCB_RENDER_CP_SUBWINDOW_MODE = 256,
    XCB_RENDER_CP_POLY_EDGE = 512,
    XCB_RENDER_CP_POLY_MODE = 1024,
    XCB_RENDER_CP_DITHER = 2048,
    XCB_RENDER_CP_COMPONENT_ALPHA = 4096,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_render_sub_pixel_t {
    XCB_RENDER_SUB_PIXEL_UNKNOWN = 0,
    XCB_RENDER_SUB_PIXEL_HORIZONTAL_RGB = 1,
    XCB_RENDER_SUB_PIXEL_HORIZONTAL_BGR = 2,
    XCB_RENDER_SUB_PIXEL_VERTICAL_RGB = 3,
    XCB_RENDER_SUB_PIXEL_VERTICAL_BGR = 4,
    XCB_RENDER_SUB_PIXEL_NONE = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum xcb_render_repeat_t {
    XCB_RENDER_REPEAT_NONE = 0,
    XCB_RENDER_REPEAT_NORMAL = 1,
    XCB_RENDER_REPEAT_PAD = 2,
    XCB_RENDER_REPEAT_REFLECT = 3,
}
pub type xcb_render_glyph_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_glyph_iterator_t {
    pub data: *mut xcb_render_glyph_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_glyph_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_glyph_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_glyph_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_glyph_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_render_glyphset_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_glyphset_iterator_t {
    pub data: *mut xcb_render_glyphset_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_glyphset_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_glyphset_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_glyphset_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_glyphset_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_render_picture_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_picture_iterator_t {
    pub data: *mut xcb_render_picture_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_picture_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_picture_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_picture_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_picture_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_render_pictformat_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pictformat_iterator_t {
    pub data: *mut xcb_render_pictformat_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_pictformat_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pictformat_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pictformat_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_pictformat_iterator_t {
    fn clone(&self) -> Self { *self }
}
pub type xcb_render_fixed_t = i32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_fixed_iterator_t {
    pub data: *mut xcb_render_fixed_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_fixed_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_fixed_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_fixed_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_fixed_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pict_format_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
}
#[test]
fn bindgen_test_layout_xcb_render_pict_format_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pict_format_error_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pict_format_error_t>() ,
               2usize);
}
impl Clone for xcb_render_pict_format_error_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_picture_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
}
#[test]
fn bindgen_test_layout_xcb_render_picture_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_picture_error_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_render_picture_error_t>() , 2usize);
}
impl Clone for xcb_render_picture_error_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pict_op_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
}
#[test]
fn bindgen_test_layout_xcb_render_pict_op_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pict_op_error_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pict_op_error_t>() , 2usize);
}
impl Clone for xcb_render_pict_op_error_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_glyph_set_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
}
#[test]
fn bindgen_test_layout_xcb_render_glyph_set_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_glyph_set_error_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_render_glyph_set_error_t>() ,
               2usize);
}
impl Clone for xcb_render_glyph_set_error_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_glyph_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
}
#[test]
fn bindgen_test_layout_xcb_render_glyph_error_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_glyph_error_t>() , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_render_glyph_error_t>() , 2usize);
}
impl Clone for xcb_render_glyph_error_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_directformat_t {
    pub red_shift: u16,
    pub red_mask: u16,
    pub green_shift: u16,
    pub green_mask: u16,
    pub blue_shift: u16,
    pub blue_mask: u16,
    pub alpha_shift: u16,
    pub alpha_mask: u16,
}
#[test]
fn bindgen_test_layout_xcb_render_directformat_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_directformat_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_directformat_t>() , 2usize);
}
impl Clone for xcb_render_directformat_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_directformat_iterator_t {
    pub data: *mut xcb_render_directformat_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_directformat_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_directformat_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_directformat_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_directformat_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pictforminfo_t {
    pub id: xcb_render_pictformat_t,
    pub type_: u8,
    pub depth: u8,
    pub pad0: [u8; 2usize],
    pub direct: xcb_render_directformat_t,
    pub colormap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_render_pictforminfo_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pictforminfo_t>() , 28usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pictforminfo_t>() , 4usize);
}
impl Clone for xcb_render_pictforminfo_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pictforminfo_iterator_t {
    pub data: *mut xcb_render_pictforminfo_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_pictforminfo_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pictforminfo_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pictforminfo_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_pictforminfo_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pictvisual_t {
    pub visual: xcb_visualid_t,
    pub format: xcb_render_pictformat_t,
}
#[test]
fn bindgen_test_layout_xcb_render_pictvisual_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pictvisual_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pictvisual_t>() , 4usize);
}
impl Clone for xcb_render_pictvisual_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pictvisual_iterator_t {
    pub data: *mut xcb_render_pictvisual_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_pictvisual_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pictvisual_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pictvisual_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_pictvisual_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pictdepth_t {
    pub depth: u8,
    pub pad0: u8,
    pub num_visuals: u16,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_render_pictdepth_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pictdepth_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pictdepth_t>() , 2usize);
}
impl Clone for xcb_render_pictdepth_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pictdepth_iterator_t {
    pub data: *mut xcb_render_pictdepth_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_pictdepth_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pictdepth_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pictdepth_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_pictdepth_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pictscreen_t {
    pub num_depths: u32,
    pub fallback: xcb_render_pictformat_t,
}
#[test]
fn bindgen_test_layout_xcb_render_pictscreen_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pictscreen_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pictscreen_t>() , 4usize);
}
impl Clone for xcb_render_pictscreen_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pictscreen_iterator_t {
    pub data: *mut xcb_render_pictscreen_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_pictscreen_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pictscreen_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pictscreen_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_pictscreen_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_indexvalue_t {
    pub pixel: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub alpha: u16,
}
#[test]
fn bindgen_test_layout_xcb_render_indexvalue_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_indexvalue_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_render_indexvalue_t>() , 4usize);
}
impl Clone for xcb_render_indexvalue_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_indexvalue_iterator_t {
    pub data: *mut xcb_render_indexvalue_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_indexvalue_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_indexvalue_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_indexvalue_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_indexvalue_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_color_t {
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub alpha: u16,
}
#[test]
fn bindgen_test_layout_xcb_render_color_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_color_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_color_t>() , 2usize);
}
impl Clone for xcb_render_color_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_color_iterator_t {
    pub data: *mut xcb_render_color_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_color_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_color_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_color_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_color_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pointfix_t {
    pub x: xcb_render_fixed_t,
    pub y: xcb_render_fixed_t,
}
#[test]
fn bindgen_test_layout_xcb_render_pointfix_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pointfix_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pointfix_t>() , 4usize);
}
impl Clone for xcb_render_pointfix_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_pointfix_iterator_t {
    pub data: *mut xcb_render_pointfix_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_pointfix_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_pointfix_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_pointfix_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_pointfix_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_linefix_t {
    pub p1: xcb_render_pointfix_t,
    pub p2: xcb_render_pointfix_t,
}
#[test]
fn bindgen_test_layout_xcb_render_linefix_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_linefix_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_linefix_t>() , 4usize);
}
impl Clone for xcb_render_linefix_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_linefix_iterator_t {
    pub data: *mut xcb_render_linefix_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_linefix_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_linefix_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_linefix_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_linefix_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_triangle_t {
    pub p1: xcb_render_pointfix_t,
    pub p2: xcb_render_pointfix_t,
    pub p3: xcb_render_pointfix_t,
}
#[test]
fn bindgen_test_layout_xcb_render_triangle_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_triangle_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_render_triangle_t>() , 4usize);
}
impl Clone for xcb_render_triangle_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_triangle_iterator_t {
    pub data: *mut xcb_render_triangle_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_triangle_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_triangle_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_triangle_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_triangle_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_trapezoid_t {
    pub top: xcb_render_fixed_t,
    pub bottom: xcb_render_fixed_t,
    pub left: xcb_render_linefix_t,
    pub right: xcb_render_linefix_t,
}
#[test]
fn bindgen_test_layout_xcb_render_trapezoid_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_trapezoid_t>() , 40usize);
    assert_eq!(::std::mem::align_of::<xcb_render_trapezoid_t>() , 4usize);
}
impl Clone for xcb_render_trapezoid_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_trapezoid_iterator_t {
    pub data: *mut xcb_render_trapezoid_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_trapezoid_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_trapezoid_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_trapezoid_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_trapezoid_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_glyphinfo_t {
    pub width: u16,
    pub height: u16,
    pub x: i16,
    pub y: i16,
    pub x_off: i16,
    pub y_off: i16,
}
#[test]
fn bindgen_test_layout_xcb_render_glyphinfo_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_glyphinfo_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_render_glyphinfo_t>() , 2usize);
}
impl Clone for xcb_render_glyphinfo_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_glyphinfo_iterator_t {
    pub data: *mut xcb_render_glyphinfo_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_glyphinfo_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_glyphinfo_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_glyphinfo_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_glyphinfo_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_version_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_render_query_version_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_version_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_version_cookie_t>() ,
               4usize);
}
impl Clone for xcb_render_query_version_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_version_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub client_major_version: u32,
    pub client_minor_version: u32,
}
#[test]
fn bindgen_test_layout_xcb_render_query_version_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_version_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_version_request_t>() ,
               4usize);
}
impl Clone for xcb_render_query_version_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_version_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub major_version: u32,
    pub minor_version: u32,
    pub pad1: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_xcb_render_query_version_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_version_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_version_reply_t>() ,
               4usize);
}
impl Clone for xcb_render_query_version_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_pict_formats_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_render_query_pict_formats_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_pict_formats_cookie_t>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_pict_formats_cookie_t>()
               , 4usize);
}
impl Clone for xcb_render_query_pict_formats_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_pict_formats_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_render_query_pict_formats_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_pict_formats_request_t>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_pict_formats_request_t>()
               , 2usize);
}
impl Clone for xcb_render_query_pict_formats_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_pict_formats_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub num_formats: u32,
    pub num_screens: u32,
    pub num_depths: u32,
    pub num_visuals: u32,
    pub num_subpixel: u32,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_render_query_pict_formats_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_pict_formats_reply_t>()
               , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_pict_formats_reply_t>()
               , 4usize);
}
impl Clone for xcb_render_query_pict_formats_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_pict_index_values_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_render_query_pict_index_values_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_pict_index_values_cookie_t>()
               , 4usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_pict_index_values_cookie_t>()
               , 4usize);
}
impl Clone for xcb_render_query_pict_index_values_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_pict_index_values_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub format: xcb_render_pictformat_t,
}
#[test]
fn bindgen_test_layout_xcb_render_query_pict_index_values_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_pict_index_values_request_t>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_pict_index_values_request_t>()
               , 4usize);
}
impl Clone for xcb_render_query_pict_index_values_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_pict_index_values_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub num_values: u32,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_render_query_pict_index_values_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_pict_index_values_reply_t>()
               , 32usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_pict_index_values_reply_t>()
               , 4usize);
}
impl Clone for xcb_render_query_pict_index_values_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_create_picture_value_list_t {
    pub repeat: u32,
    pub alphamap: xcb_render_picture_t,
    pub alphaxorigin: i32,
    pub alphayorigin: i32,
    pub clipxorigin: i32,
    pub clipyorigin: i32,
    pub clipmask: xcb_pixmap_t,
    pub graphicsexposure: u32,
    pub subwindowmode: u32,
    pub polyedge: u32,
    pub polymode: u32,
    pub dither: xcb_atom_t,
    pub componentalpha: u32,
}
#[test]
fn bindgen_test_layout_xcb_render_create_picture_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_create_picture_value_list_t>()
               , 52usize);
    assert_eq!(::std::mem::align_of::<xcb_render_create_picture_value_list_t>()
               , 4usize);
}
impl Clone for xcb_render_create_picture_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_create_picture_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub pid: xcb_render_picture_t,
    pub drawable: xcb_drawable_t,
    pub format: xcb_render_pictformat_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_render_create_picture_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_create_picture_request_t>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<xcb_render_create_picture_request_t>() ,
               4usize);
}
impl Clone for xcb_render_create_picture_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_change_picture_value_list_t {
    pub repeat: u32,
    pub alphamap: xcb_render_picture_t,
    pub alphaxorigin: i32,
    pub alphayorigin: i32,
    pub clipxorigin: i32,
    pub clipyorigin: i32,
    pub clipmask: xcb_pixmap_t,
    pub graphicsexposure: u32,
    pub subwindowmode: u32,
    pub polyedge: u32,
    pub polymode: u32,
    pub dither: xcb_atom_t,
    pub componentalpha: u32,
}
#[test]
fn bindgen_test_layout_xcb_render_change_picture_value_list_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_change_picture_value_list_t>()
               , 52usize);
    assert_eq!(::std::mem::align_of::<xcb_render_change_picture_value_list_t>()
               , 4usize);
}
impl Clone for xcb_render_change_picture_value_list_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_change_picture_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub picture: xcb_render_picture_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_render_change_picture_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_change_picture_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_render_change_picture_request_t>() ,
               4usize);
}
impl Clone for xcb_render_change_picture_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_set_picture_clip_rectangles_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub picture: xcb_render_picture_t,
    pub clip_x_origin: i16,
    pub clip_y_origin: i16,
}
#[test]
fn bindgen_test_layout_xcb_render_set_picture_clip_rectangles_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_set_picture_clip_rectangles_request_t>()
               , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_render_set_picture_clip_rectangles_request_t>()
               , 4usize);
}
impl Clone for xcb_render_set_picture_clip_rectangles_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_free_picture_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub picture: xcb_render_picture_t,
}
#[test]
fn bindgen_test_layout_xcb_render_free_picture_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_free_picture_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_free_picture_request_t>() ,
               4usize);
}
impl Clone for xcb_render_free_picture_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_composite_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub op: u8,
    pub pad0: [u8; 3usize],
    pub src: xcb_render_picture_t,
    pub mask: xcb_render_picture_t,
    pub dst: xcb_render_picture_t,
    pub src_x: i16,
    pub src_y: i16,
    pub mask_x: i16,
    pub mask_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_render_composite_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_composite_request_t>() ,
               36usize);
    assert_eq!(::std::mem::align_of::<xcb_render_composite_request_t>() ,
               4usize);
}
impl Clone for xcb_render_composite_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_trapezoids_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub op: u8,
    pub pad0: [u8; 3usize],
    pub src: xcb_render_picture_t,
    pub dst: xcb_render_picture_t,
    pub mask_format: xcb_render_pictformat_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_render_trapezoids_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_trapezoids_request_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_render_trapezoids_request_t>() ,
               4usize);
}
impl Clone for xcb_render_trapezoids_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_triangles_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub op: u8,
    pub pad0: [u8; 3usize],
    pub src: xcb_render_picture_t,
    pub dst: xcb_render_picture_t,
    pub mask_format: xcb_render_pictformat_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_render_triangles_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_triangles_request_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_render_triangles_request_t>() ,
               4usize);
}
impl Clone for xcb_render_triangles_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_tri_strip_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub op: u8,
    pub pad0: [u8; 3usize],
    pub src: xcb_render_picture_t,
    pub dst: xcb_render_picture_t,
    pub mask_format: xcb_render_pictformat_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_render_tri_strip_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_tri_strip_request_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_render_tri_strip_request_t>() ,
               4usize);
}
impl Clone for xcb_render_tri_strip_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_tri_fan_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub op: u8,
    pub pad0: [u8; 3usize],
    pub src: xcb_render_picture_t,
    pub dst: xcb_render_picture_t,
    pub mask_format: xcb_render_pictformat_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_render_tri_fan_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_tri_fan_request_t>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<xcb_render_tri_fan_request_t>() ,
               4usize);
}
impl Clone for xcb_render_tri_fan_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_create_glyph_set_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub gsid: xcb_render_glyphset_t,
    pub format: xcb_render_pictformat_t,
}
#[test]
fn bindgen_test_layout_xcb_render_create_glyph_set_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_create_glyph_set_request_t>()
               , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_render_create_glyph_set_request_t>()
               , 4usize);
}
impl Clone for xcb_render_create_glyph_set_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_reference_glyph_set_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub gsid: xcb_render_glyphset_t,
    pub existing: xcb_render_glyphset_t,
}
#[test]
fn bindgen_test_layout_xcb_render_reference_glyph_set_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_reference_glyph_set_request_t>()
               , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_render_reference_glyph_set_request_t>()
               , 4usize);
}
impl Clone for xcb_render_reference_glyph_set_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_free_glyph_set_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub glyphset: xcb_render_glyphset_t,
}
#[test]
fn bindgen_test_layout_xcb_render_free_glyph_set_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_free_glyph_set_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_free_glyph_set_request_t>() ,
               4usize);
}
impl Clone for xcb_render_free_glyph_set_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_add_glyphs_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub glyphset: xcb_render_glyphset_t,
    pub glyphs_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_render_add_glyphs_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_add_glyphs_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_render_add_glyphs_request_t>() ,
               4usize);
}
impl Clone for xcb_render_add_glyphs_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_free_glyphs_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub glyphset: xcb_render_glyphset_t,
}
#[test]
fn bindgen_test_layout_xcb_render_free_glyphs_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_free_glyphs_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_free_glyphs_request_t>() ,
               4usize);
}
impl Clone for xcb_render_free_glyphs_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_composite_glyphs_8_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub op: u8,
    pub pad0: [u8; 3usize],
    pub src: xcb_render_picture_t,
    pub dst: xcb_render_picture_t,
    pub mask_format: xcb_render_pictformat_t,
    pub glyphset: xcb_render_glyphset_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_render_composite_glyphs_8_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_composite_glyphs_8_request_t>()
               , 28usize);
    assert_eq!(::std::mem::align_of::<xcb_render_composite_glyphs_8_request_t>()
               , 4usize);
}
impl Clone for xcb_render_composite_glyphs_8_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_composite_glyphs_16_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub op: u8,
    pub pad0: [u8; 3usize],
    pub src: xcb_render_picture_t,
    pub dst: xcb_render_picture_t,
    pub mask_format: xcb_render_pictformat_t,
    pub glyphset: xcb_render_glyphset_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_render_composite_glyphs_16_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_composite_glyphs_16_request_t>()
               , 28usize);
    assert_eq!(::std::mem::align_of::<xcb_render_composite_glyphs_16_request_t>()
               , 4usize);
}
impl Clone for xcb_render_composite_glyphs_16_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_composite_glyphs_32_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub op: u8,
    pub pad0: [u8; 3usize],
    pub src: xcb_render_picture_t,
    pub dst: xcb_render_picture_t,
    pub mask_format: xcb_render_pictformat_t,
    pub glyphset: xcb_render_glyphset_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_render_composite_glyphs_32_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_composite_glyphs_32_request_t>()
               , 28usize);
    assert_eq!(::std::mem::align_of::<xcb_render_composite_glyphs_32_request_t>()
               , 4usize);
}
impl Clone for xcb_render_composite_glyphs_32_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_fill_rectangles_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub op: u8,
    pub pad0: [u8; 3usize],
    pub dst: xcb_render_picture_t,
    pub color: xcb_render_color_t,
}
#[test]
fn bindgen_test_layout_xcb_render_fill_rectangles_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_fill_rectangles_request_t>() ,
               20usize);
    assert_eq!(::std::mem::align_of::<xcb_render_fill_rectangles_request_t>()
               , 4usize);
}
impl Clone for xcb_render_fill_rectangles_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_create_cursor_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source: xcb_render_picture_t,
    pub x: u16,
    pub y: u16,
}
#[test]
fn bindgen_test_layout_xcb_render_create_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_create_cursor_request_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_create_cursor_request_t>() ,
               4usize);
}
impl Clone for xcb_render_create_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_transform_t {
    pub matrix11: xcb_render_fixed_t,
    pub matrix12: xcb_render_fixed_t,
    pub matrix13: xcb_render_fixed_t,
    pub matrix21: xcb_render_fixed_t,
    pub matrix22: xcb_render_fixed_t,
    pub matrix23: xcb_render_fixed_t,
    pub matrix31: xcb_render_fixed_t,
    pub matrix32: xcb_render_fixed_t,
    pub matrix33: xcb_render_fixed_t,
}
#[test]
fn bindgen_test_layout_xcb_render_transform_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_transform_t>() , 36usize);
    assert_eq!(::std::mem::align_of::<xcb_render_transform_t>() , 4usize);
}
impl Clone for xcb_render_transform_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_transform_iterator_t {
    pub data: *mut xcb_render_transform_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_transform_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_transform_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_transform_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_transform_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_set_picture_transform_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub picture: xcb_render_picture_t,
    pub transform: xcb_render_transform_t,
}
#[test]
fn bindgen_test_layout_xcb_render_set_picture_transform_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_set_picture_transform_request_t>()
               , 44usize);
    assert_eq!(::std::mem::align_of::<xcb_render_set_picture_transform_request_t>()
               , 4usize);
}
impl Clone for xcb_render_set_picture_transform_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_filters_cookie_t {
    pub sequence: libc::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_render_query_filters_cookie_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_filters_cookie_t>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_filters_cookie_t>() ,
               4usize);
}
impl Clone for xcb_render_query_filters_cookie_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_filters_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
}
#[test]
fn bindgen_test_layout_xcb_render_query_filters_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_filters_request_t>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_filters_request_t>() ,
               4usize);
}
impl Clone for xcb_render_query_filters_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_query_filters_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub num_aliases: u32,
    pub num_filters: u32,
    pub pad1: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_xcb_render_query_filters_reply_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_query_filters_reply_t>() ,
               32usize);
    assert_eq!(::std::mem::align_of::<xcb_render_query_filters_reply_t>() ,
               4usize);
}
impl Clone for xcb_render_query_filters_reply_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_set_picture_filter_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub picture: xcb_render_picture_t,
    pub filter_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_render_set_picture_filter_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_set_picture_filter_request_t>()
               , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_render_set_picture_filter_request_t>()
               , 4usize);
}
impl Clone for xcb_render_set_picture_filter_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_animcursorelt_t {
    pub cursor: xcb_cursor_t,
    pub delay: u32,
}
#[test]
fn bindgen_test_layout_xcb_render_animcursorelt_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_animcursorelt_t>() , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_animcursorelt_t>() , 4usize);
}
impl Clone for xcb_render_animcursorelt_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_animcursorelt_iterator_t {
    pub data: *mut xcb_render_animcursorelt_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_animcursorelt_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_animcursorelt_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_animcursorelt_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_animcursorelt_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_create_anim_cursor_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_render_create_anim_cursor_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_create_anim_cursor_request_t>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<xcb_render_create_anim_cursor_request_t>()
               , 4usize);
}
impl Clone for xcb_render_create_anim_cursor_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_spanfix_t {
    pub l: xcb_render_fixed_t,
    pub r: xcb_render_fixed_t,
    pub y: xcb_render_fixed_t,
}
#[test]
fn bindgen_test_layout_xcb_render_spanfix_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_spanfix_t>() , 12usize);
    assert_eq!(::std::mem::align_of::<xcb_render_spanfix_t>() , 4usize);
}
impl Clone for xcb_render_spanfix_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_spanfix_iterator_t {
    pub data: *mut xcb_render_spanfix_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_spanfix_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_spanfix_iterator_t>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_spanfix_iterator_t>() ,
               8usize);
}
impl Clone for xcb_render_spanfix_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_trap_t {
    pub top: xcb_render_spanfix_t,
    pub bot: xcb_render_spanfix_t,
}
#[test]
fn bindgen_test_layout_xcb_render_trap_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_trap_t>() , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_render_trap_t>() , 4usize);
}
impl Clone for xcb_render_trap_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_trap_iterator_t {
    pub data: *mut xcb_render_trap_t,
    pub rem: libc::c_int,
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_xcb_render_trap_iterator_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_trap_iterator_t>() , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_trap_iterator_t>() , 8usize);
}
impl Clone for xcb_render_trap_iterator_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_add_traps_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub picture: xcb_render_picture_t,
    pub x_off: i16,
    pub y_off: i16,
}
#[test]
fn bindgen_test_layout_xcb_render_add_traps_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_add_traps_request_t>() ,
               12usize);
    assert_eq!(::std::mem::align_of::<xcb_render_add_traps_request_t>() ,
               4usize);
}
impl Clone for xcb_render_add_traps_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_create_solid_fill_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub picture: xcb_render_picture_t,
    pub color: xcb_render_color_t,
}
#[test]
fn bindgen_test_layout_xcb_render_create_solid_fill_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_create_solid_fill_request_t>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<xcb_render_create_solid_fill_request_t>()
               , 4usize);
}
impl Clone for xcb_render_create_solid_fill_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_create_linear_gradient_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub picture: xcb_render_picture_t,
    pub p1: xcb_render_pointfix_t,
    pub p2: xcb_render_pointfix_t,
    pub num_stops: u32,
}
#[test]
fn bindgen_test_layout_xcb_render_create_linear_gradient_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_create_linear_gradient_request_t>()
               , 28usize);
    assert_eq!(::std::mem::align_of::<xcb_render_create_linear_gradient_request_t>()
               , 4usize);
}
impl Clone for xcb_render_create_linear_gradient_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_create_radial_gradient_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub picture: xcb_render_picture_t,
    pub inner: xcb_render_pointfix_t,
    pub outer: xcb_render_pointfix_t,
    pub inner_radius: xcb_render_fixed_t,
    pub outer_radius: xcb_render_fixed_t,
    pub num_stops: u32,
}
#[test]
fn bindgen_test_layout_xcb_render_create_radial_gradient_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_create_radial_gradient_request_t>()
               , 36usize);
    assert_eq!(::std::mem::align_of::<xcb_render_create_radial_gradient_request_t>()
               , 4usize);
}
impl Clone for xcb_render_create_radial_gradient_request_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xcb_render_create_conical_gradient_request_t {
    pub major_opcode: u8,
    pub minor_opcode: u8,
    pub length: u16,
    pub picture: xcb_render_picture_t,
    pub center: xcb_render_pointfix_t,
    pub angle: xcb_render_fixed_t,
    pub num_stops: u32,
}
#[test]
fn bindgen_test_layout_xcb_render_create_conical_gradient_request_t() {
    assert_eq!(::std::mem::size_of::<xcb_render_create_conical_gradient_request_t>()
               , 24usize);
    assert_eq!(::std::mem::align_of::<xcb_render_create_conical_gradient_request_t>()
               , 4usize);
}
impl Clone for xcb_render_create_conical_gradient_request_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn xcb_render_glyph_next(i: *mut xcb_render_glyph_iterator_t);
}
extern "C" {
    pub fn xcb_render_glyph_end(i: xcb_render_glyph_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_glyphset_next(i: *mut xcb_render_glyphset_iterator_t);
}
extern "C" {
    pub fn xcb_render_glyphset_end(i: xcb_render_glyphset_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_picture_next(i: *mut xcb_render_picture_iterator_t);
}
extern "C" {
    pub fn xcb_render_picture_end(i: xcb_render_picture_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_pictformat_next(i:
                                          *mut xcb_render_pictformat_iterator_t);
}
extern "C" {
    pub fn xcb_render_pictformat_end(i: xcb_render_pictformat_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_fixed_next(i: *mut xcb_render_fixed_iterator_t);
}
extern "C" {
    pub fn xcb_render_fixed_end(i: xcb_render_fixed_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_directformat_next(i:
                                            *mut xcb_render_directformat_iterator_t);
}
extern "C" {
    pub fn xcb_render_directformat_end(i: xcb_render_directformat_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_pictforminfo_next(i:
                                            *mut xcb_render_pictforminfo_iterator_t);
}
extern "C" {
    pub fn xcb_render_pictforminfo_end(i: xcb_render_pictforminfo_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_pictvisual_next(i:
                                          *mut xcb_render_pictvisual_iterator_t);
}
extern "C" {
    pub fn xcb_render_pictvisual_end(i: xcb_render_pictvisual_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_pictdepth_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_pictdepth_visuals(R: *const xcb_render_pictdepth_t)
     -> *mut xcb_render_pictvisual_t;
}
extern "C" {
    pub fn xcb_render_pictdepth_visuals_length(R:
                                                   *const xcb_render_pictdepth_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_pictdepth_visuals_iterator(R:
                                                     *const xcb_render_pictdepth_t)
     -> xcb_render_pictvisual_iterator_t;
}
extern "C" {
    pub fn xcb_render_pictdepth_next(i: *mut xcb_render_pictdepth_iterator_t);
}
extern "C" {
    pub fn xcb_render_pictdepth_end(i: xcb_render_pictdepth_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_pictscreen_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_pictscreen_depths_length(R:
                                                   *const xcb_render_pictscreen_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_pictscreen_depths_iterator(R:
                                                     *const xcb_render_pictscreen_t)
     -> xcb_render_pictdepth_iterator_t;
}
extern "C" {
    pub fn xcb_render_pictscreen_next(i:
                                          *mut xcb_render_pictscreen_iterator_t);
}
extern "C" {
    pub fn xcb_render_pictscreen_end(i: xcb_render_pictscreen_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_indexvalue_next(i:
                                          *mut xcb_render_indexvalue_iterator_t);
}
extern "C" {
    pub fn xcb_render_indexvalue_end(i: xcb_render_indexvalue_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_color_next(i: *mut xcb_render_color_iterator_t);
}
extern "C" {
    pub fn xcb_render_color_end(i: xcb_render_color_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_pointfix_next(i: *mut xcb_render_pointfix_iterator_t);
}
extern "C" {
    pub fn xcb_render_pointfix_end(i: xcb_render_pointfix_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_linefix_next(i: *mut xcb_render_linefix_iterator_t);
}
extern "C" {
    pub fn xcb_render_linefix_end(i: xcb_render_linefix_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_triangle_next(i: *mut xcb_render_triangle_iterator_t);
}
extern "C" {
    pub fn xcb_render_triangle_end(i: xcb_render_triangle_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_trapezoid_next(i: *mut xcb_render_trapezoid_iterator_t);
}
extern "C" {
    pub fn xcb_render_trapezoid_end(i: xcb_render_trapezoid_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_glyphinfo_next(i: *mut xcb_render_glyphinfo_iterator_t);
}
extern "C" {
    pub fn xcb_render_glyphinfo_end(i: xcb_render_glyphinfo_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_query_version(c: *mut xcb_connection_t,
                                    client_major_version: u32,
                                    client_minor_version: u32)
     -> xcb_render_query_version_cookie_t;
}
extern "C" {
    pub fn xcb_render_query_version_unchecked(c: *mut xcb_connection_t,
                                              client_major_version: u32,
                                              client_minor_version: u32)
     -> xcb_render_query_version_cookie_t;
}
extern "C" {
    pub fn xcb_render_query_version_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_render_query_version_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_render_query_version_reply_t;
}
extern "C" {
    pub fn xcb_render_query_pict_formats_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_query_pict_formats(c: *mut xcb_connection_t)
     -> xcb_render_query_pict_formats_cookie_t;
}
extern "C" {
    pub fn xcb_render_query_pict_formats_unchecked(c: *mut xcb_connection_t)
     -> xcb_render_query_pict_formats_cookie_t;
}
extern "C" {
    pub fn xcb_render_query_pict_formats_formats(R:
                                                     *const xcb_render_query_pict_formats_reply_t)
     -> *mut xcb_render_pictforminfo_t;
}
extern "C" {
    pub fn xcb_render_query_pict_formats_formats_length(R:
                                                            *const xcb_render_query_pict_formats_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_query_pict_formats_formats_iterator(R:
                                                              *const xcb_render_query_pict_formats_reply_t)
     -> xcb_render_pictforminfo_iterator_t;
}
extern "C" {
    pub fn xcb_render_query_pict_formats_screens_length(R:
                                                            *const xcb_render_query_pict_formats_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_query_pict_formats_screens_iterator(R:
                                                              *const xcb_render_query_pict_formats_reply_t)
     -> xcb_render_pictscreen_iterator_t;
}
extern "C" {
    pub fn xcb_render_query_pict_formats_subpixels(R:
                                                       *const xcb_render_query_pict_formats_reply_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_render_query_pict_formats_subpixels_length(R:
                                                              *const xcb_render_query_pict_formats_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_query_pict_formats_subpixels_end(R:
                                                           *const xcb_render_query_pict_formats_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_query_pict_formats_reply(c: *mut xcb_connection_t,
                                               cookie:
                                                   xcb_render_query_pict_formats_cookie_t,
                                               e:
                                                   *mut *mut xcb_generic_error_t)
     -> *mut xcb_render_query_pict_formats_reply_t;
}
extern "C" {
    pub fn xcb_render_query_pict_index_values_sizeof(_buffer:
                                                         *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_query_pict_index_values(c: *mut xcb_connection_t,
                                              format: xcb_render_pictformat_t)
     -> xcb_render_query_pict_index_values_cookie_t;
}
extern "C" {
    pub fn xcb_render_query_pict_index_values_unchecked(c:
                                                            *mut xcb_connection_t,
                                                        format:
                                                            xcb_render_pictformat_t)
     -> xcb_render_query_pict_index_values_cookie_t;
}
extern "C" {
    pub fn xcb_render_query_pict_index_values_values(R:
                                                         *const xcb_render_query_pict_index_values_reply_t)
     -> *mut xcb_render_indexvalue_t;
}
extern "C" {
    pub fn xcb_render_query_pict_index_values_values_length(R:
                                                                *const xcb_render_query_pict_index_values_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_query_pict_index_values_values_iterator(R:
                                                                  *const xcb_render_query_pict_index_values_reply_t)
     -> xcb_render_indexvalue_iterator_t;
}
extern "C" {
    pub fn xcb_render_query_pict_index_values_reply(c: *mut xcb_connection_t,
                                                    cookie:
                                                        xcb_render_query_pict_index_values_cookie_t,
                                                    e:
                                                        *mut *mut xcb_generic_error_t)
     -> *mut xcb_render_query_pict_index_values_reply_t;
}
extern "C" {
    pub fn xcb_render_create_picture_value_list_serialize(_buffer:
                                                              *mut *mut libc::c_void,
                                                          value_mask: u32,
                                                          _aux:
                                                              *const xcb_render_create_picture_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_picture_value_list_unpack(_buffer:
                                                           *const libc::c_void,
                                                       value_mask: u32,
                                                       _aux:
                                                           *mut xcb_render_create_picture_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_picture_value_list_sizeof(_buffer:
                                                           *const libc::c_void,
                                                       value_mask: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_picture_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_picture_checked(c: *mut xcb_connection_t,
                                             pid: xcb_render_picture_t,
                                             drawable: xcb_drawable_t,
                                             format: xcb_render_pictformat_t,
                                             value_mask: u32,
                                             value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_picture(c: *mut xcb_connection_t,
                                     pid: xcb_render_picture_t,
                                     drawable: xcb_drawable_t,
                                     format: xcb_render_pictformat_t,
                                     value_mask: u32,
                                     value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_picture_aux_checked(c: *mut xcb_connection_t,
                                                 pid: xcb_render_picture_t,
                                                 drawable: xcb_drawable_t,
                                                 format:
                                                     xcb_render_pictformat_t,
                                                 value_mask: u32,
                                                 value_list:
                                                     *const xcb_render_create_picture_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_picture_aux(c: *mut xcb_connection_t,
                                         pid: xcb_render_picture_t,
                                         drawable: xcb_drawable_t,
                                         format: xcb_render_pictformat_t,
                                         value_mask: u32,
                                         value_list:
                                             *const xcb_render_create_picture_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_picture_value_list(R:
                                                    *const xcb_render_create_picture_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_render_change_picture_value_list_serialize(_buffer:
                                                              *mut *mut libc::c_void,
                                                          value_mask: u32,
                                                          _aux:
                                                              *const xcb_render_change_picture_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_change_picture_value_list_unpack(_buffer:
                                                           *const libc::c_void,
                                                       value_mask: u32,
                                                       _aux:
                                                           *mut xcb_render_change_picture_value_list_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_change_picture_value_list_sizeof(_buffer:
                                                           *const libc::c_void,
                                                       value_mask: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_change_picture_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_change_picture_checked(c: *mut xcb_connection_t,
                                             picture: xcb_render_picture_t,
                                             value_mask: u32,
                                             value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_change_picture(c: *mut xcb_connection_t,
                                     picture: xcb_render_picture_t,
                                     value_mask: u32,
                                     value_list: *const libc::c_void)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_change_picture_aux_checked(c: *mut xcb_connection_t,
                                                 picture:
                                                     xcb_render_picture_t,
                                                 value_mask: u32,
                                                 value_list:
                                                     *const xcb_render_change_picture_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_change_picture_aux(c: *mut xcb_connection_t,
                                         picture: xcb_render_picture_t,
                                         value_mask: u32,
                                         value_list:
                                             *const xcb_render_change_picture_value_list_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_change_picture_value_list(R:
                                                    *const xcb_render_change_picture_request_t)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn xcb_render_set_picture_clip_rectangles_sizeof(_buffer:
                                                             *const libc::c_void,
                                                         rectangles_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_set_picture_clip_rectangles_checked(c:
                                                              *mut xcb_connection_t,
                                                          picture:
                                                              xcb_render_picture_t,
                                                          clip_x_origin: i16,
                                                          clip_y_origin: i16,
                                                          rectangles_len: u32,
                                                          rectangles:
                                                              *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_set_picture_clip_rectangles(c: *mut xcb_connection_t,
                                                  picture:
                                                      xcb_render_picture_t,
                                                  clip_x_origin: i16,
                                                  clip_y_origin: i16,
                                                  rectangles_len: u32,
                                                  rectangles:
                                                      *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_set_picture_clip_rectangles_rectangles(R:
                                                                 *const xcb_render_set_picture_clip_rectangles_request_t)
     -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_render_set_picture_clip_rectangles_rectangles_length(R:
                                                                        *const xcb_render_set_picture_clip_rectangles_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_set_picture_clip_rectangles_rectangles_iterator(R:
                                                                          *const xcb_render_set_picture_clip_rectangles_request_t)
     -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_render_free_picture_checked(c: *mut xcb_connection_t,
                                           picture: xcb_render_picture_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_free_picture(c: *mut xcb_connection_t,
                                   picture: xcb_render_picture_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_composite_checked(c: *mut xcb_connection_t, op: u8,
                                        src: xcb_render_picture_t,
                                        mask: xcb_render_picture_t,
                                        dst: xcb_render_picture_t, src_x: i16,
                                        src_y: i16, mask_x: i16, mask_y: i16,
                                        dst_x: i16, dst_y: i16, width: u16,
                                        height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_composite(c: *mut xcb_connection_t, op: u8,
                                src: xcb_render_picture_t,
                                mask: xcb_render_picture_t,
                                dst: xcb_render_picture_t, src_x: i16,
                                src_y: i16, mask_x: i16, mask_y: i16,
                                dst_x: i16, dst_y: i16, width: u16,
                                height: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_trapezoids_sizeof(_buffer: *const libc::c_void,
                                        traps_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_trapezoids_checked(c: *mut xcb_connection_t, op: u8,
                                         src: xcb_render_picture_t,
                                         dst: xcb_render_picture_t,
                                         mask_format: xcb_render_pictformat_t,
                                         src_x: i16, src_y: i16,
                                         traps_len: u32,
                                         traps: *const xcb_render_trapezoid_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_trapezoids(c: *mut xcb_connection_t, op: u8,
                                 src: xcb_render_picture_t,
                                 dst: xcb_render_picture_t,
                                 mask_format: xcb_render_pictformat_t,
                                 src_x: i16, src_y: i16, traps_len: u32,
                                 traps: *const xcb_render_trapezoid_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_trapezoids_traps(R:
                                           *const xcb_render_trapezoids_request_t)
     -> *mut xcb_render_trapezoid_t;
}
extern "C" {
    pub fn xcb_render_trapezoids_traps_length(R:
                                                  *const xcb_render_trapezoids_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_trapezoids_traps_iterator(R:
                                                    *const xcb_render_trapezoids_request_t)
     -> xcb_render_trapezoid_iterator_t;
}
extern "C" {
    pub fn xcb_render_triangles_sizeof(_buffer: *const libc::c_void,
                                       triangles_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_triangles_checked(c: *mut xcb_connection_t, op: u8,
                                        src: xcb_render_picture_t,
                                        dst: xcb_render_picture_t,
                                        mask_format: xcb_render_pictformat_t,
                                        src_x: i16, src_y: i16,
                                        triangles_len: u32,
                                        triangles:
                                            *const xcb_render_triangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_triangles(c: *mut xcb_connection_t, op: u8,
                                src: xcb_render_picture_t,
                                dst: xcb_render_picture_t,
                                mask_format: xcb_render_pictformat_t,
                                src_x: i16, src_y: i16, triangles_len: u32,
                                triangles: *const xcb_render_triangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_triangles_triangles(R:
                                              *const xcb_render_triangles_request_t)
     -> *mut xcb_render_triangle_t;
}
extern "C" {
    pub fn xcb_render_triangles_triangles_length(R:
                                                     *const xcb_render_triangles_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_triangles_triangles_iterator(R:
                                                       *const xcb_render_triangles_request_t)
     -> xcb_render_triangle_iterator_t;
}
extern "C" {
    pub fn xcb_render_tri_strip_sizeof(_buffer: *const libc::c_void,
                                       points_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_tri_strip_checked(c: *mut xcb_connection_t, op: u8,
                                        src: xcb_render_picture_t,
                                        dst: xcb_render_picture_t,
                                        mask_format: xcb_render_pictformat_t,
                                        src_x: i16, src_y: i16,
                                        points_len: u32,
                                        points: *const xcb_render_pointfix_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_tri_strip(c: *mut xcb_connection_t, op: u8,
                                src: xcb_render_picture_t,
                                dst: xcb_render_picture_t,
                                mask_format: xcb_render_pictformat_t,
                                src_x: i16, src_y: i16, points_len: u32,
                                points: *const xcb_render_pointfix_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_tri_strip_points(R:
                                           *const xcb_render_tri_strip_request_t)
     -> *mut xcb_render_pointfix_t;
}
extern "C" {
    pub fn xcb_render_tri_strip_points_length(R:
                                                  *const xcb_render_tri_strip_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_tri_strip_points_iterator(R:
                                                    *const xcb_render_tri_strip_request_t)
     -> xcb_render_pointfix_iterator_t;
}
extern "C" {
    pub fn xcb_render_tri_fan_sizeof(_buffer: *const libc::c_void,
                                     points_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_tri_fan_checked(c: *mut xcb_connection_t, op: u8,
                                      src: xcb_render_picture_t,
                                      dst: xcb_render_picture_t,
                                      mask_format: xcb_render_pictformat_t,
                                      src_x: i16, src_y: i16, points_len: u32,
                                      points: *const xcb_render_pointfix_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_tri_fan(c: *mut xcb_connection_t, op: u8,
                              src: xcb_render_picture_t,
                              dst: xcb_render_picture_t,
                              mask_format: xcb_render_pictformat_t,
                              src_x: i16, src_y: i16, points_len: u32,
                              points: *const xcb_render_pointfix_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_tri_fan_points(R: *const xcb_render_tri_fan_request_t)
     -> *mut xcb_render_pointfix_t;
}
extern "C" {
    pub fn xcb_render_tri_fan_points_length(R:
                                                *const xcb_render_tri_fan_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_tri_fan_points_iterator(R:
                                                  *const xcb_render_tri_fan_request_t)
     -> xcb_render_pointfix_iterator_t;
}
extern "C" {
    pub fn xcb_render_create_glyph_set_checked(c: *mut xcb_connection_t,
                                               gsid: xcb_render_glyphset_t,
                                               format:
                                                   xcb_render_pictformat_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_glyph_set(c: *mut xcb_connection_t,
                                       gsid: xcb_render_glyphset_t,
                                       format: xcb_render_pictformat_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_reference_glyph_set_checked(c: *mut xcb_connection_t,
                                                  gsid: xcb_render_glyphset_t,
                                                  existing:
                                                      xcb_render_glyphset_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_reference_glyph_set(c: *mut xcb_connection_t,
                                          gsid: xcb_render_glyphset_t,
                                          existing: xcb_render_glyphset_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_free_glyph_set_checked(c: *mut xcb_connection_t,
                                             glyphset: xcb_render_glyphset_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_free_glyph_set(c: *mut xcb_connection_t,
                                     glyphset: xcb_render_glyphset_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_add_glyphs_sizeof(_buffer: *const libc::c_void,
                                        data_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_add_glyphs_checked(c: *mut xcb_connection_t,
                                         glyphset: xcb_render_glyphset_t,
                                         glyphs_len: u32,
                                         glyphids: *const u32,
                                         glyphs:
                                             *const xcb_render_glyphinfo_t,
                                         data_len: u32, data: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_add_glyphs(c: *mut xcb_connection_t,
                                 glyphset: xcb_render_glyphset_t,
                                 glyphs_len: u32, glyphids: *const u32,
                                 glyphs: *const xcb_render_glyphinfo_t,
                                 data_len: u32, data: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_add_glyphs_glyphids(R:
                                              *const xcb_render_add_glyphs_request_t)
     -> *mut u32;
}
extern "C" {
    pub fn xcb_render_add_glyphs_glyphids_length(R:
                                                     *const xcb_render_add_glyphs_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_add_glyphs_glyphids_end(R:
                                                  *const xcb_render_add_glyphs_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_add_glyphs_glyphs(R:
                                            *const xcb_render_add_glyphs_request_t)
     -> *mut xcb_render_glyphinfo_t;
}
extern "C" {
    pub fn xcb_render_add_glyphs_glyphs_length(R:
                                                   *const xcb_render_add_glyphs_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_add_glyphs_glyphs_iterator(R:
                                                     *const xcb_render_add_glyphs_request_t)
     -> xcb_render_glyphinfo_iterator_t;
}
extern "C" {
    pub fn xcb_render_add_glyphs_data(R:
                                          *const xcb_render_add_glyphs_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_render_add_glyphs_data_length(R:
                                                 *const xcb_render_add_glyphs_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_add_glyphs_data_end(R:
                                              *const xcb_render_add_glyphs_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_free_glyphs_sizeof(_buffer: *const libc::c_void,
                                         glyphs_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_free_glyphs_checked(c: *mut xcb_connection_t,
                                          glyphset: xcb_render_glyphset_t,
                                          glyphs_len: u32,
                                          glyphs: *const xcb_render_glyph_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_free_glyphs(c: *mut xcb_connection_t,
                                  glyphset: xcb_render_glyphset_t,
                                  glyphs_len: u32,
                                  glyphs: *const xcb_render_glyph_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_free_glyphs_glyphs(R:
                                             *const xcb_render_free_glyphs_request_t)
     -> *mut xcb_render_glyph_t;
}
extern "C" {
    pub fn xcb_render_free_glyphs_glyphs_length(R:
                                                    *const xcb_render_free_glyphs_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_free_glyphs_glyphs_end(R:
                                                 *const xcb_render_free_glyphs_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_8_sizeof(_buffer: *const libc::c_void,
                                                glyphcmds_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_8_checked(c: *mut xcb_connection_t,
                                                 op: u8,
                                                 src: xcb_render_picture_t,
                                                 dst: xcb_render_picture_t,
                                                 mask_format:
                                                     xcb_render_pictformat_t,
                                                 glyphset:
                                                     xcb_render_glyphset_t,
                                                 src_x: i16, src_y: i16,
                                                 glyphcmds_len: u32,
                                                 glyphcmds: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_8(c: *mut xcb_connection_t, op: u8,
                                         src: xcb_render_picture_t,
                                         dst: xcb_render_picture_t,
                                         mask_format: xcb_render_pictformat_t,
                                         glyphset: xcb_render_glyphset_t,
                                         src_x: i16, src_y: i16,
                                         glyphcmds_len: u32,
                                         glyphcmds: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_8_glyphcmds(R:
                                                       *const xcb_render_composite_glyphs_8_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_8_glyphcmds_length(R:
                                                              *const xcb_render_composite_glyphs_8_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_8_glyphcmds_end(R:
                                                           *const xcb_render_composite_glyphs_8_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_16_sizeof(_buffer: *const libc::c_void,
                                                 glyphcmds_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_16_checked(c: *mut xcb_connection_t,
                                                  op: u8,
                                                  src: xcb_render_picture_t,
                                                  dst: xcb_render_picture_t,
                                                  mask_format:
                                                      xcb_render_pictformat_t,
                                                  glyphset:
                                                      xcb_render_glyphset_t,
                                                  src_x: i16, src_y: i16,
                                                  glyphcmds_len: u32,
                                                  glyphcmds: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_16(c: *mut xcb_connection_t, op: u8,
                                          src: xcb_render_picture_t,
                                          dst: xcb_render_picture_t,
                                          mask_format:
                                              xcb_render_pictformat_t,
                                          glyphset: xcb_render_glyphset_t,
                                          src_x: i16, src_y: i16,
                                          glyphcmds_len: u32,
                                          glyphcmds: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_16_glyphcmds(R:
                                                        *const xcb_render_composite_glyphs_16_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_16_glyphcmds_length(R:
                                                               *const xcb_render_composite_glyphs_16_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_16_glyphcmds_end(R:
                                                            *const xcb_render_composite_glyphs_16_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_32_sizeof(_buffer: *const libc::c_void,
                                                 glyphcmds_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_32_checked(c: *mut xcb_connection_t,
                                                  op: u8,
                                                  src: xcb_render_picture_t,
                                                  dst: xcb_render_picture_t,
                                                  mask_format:
                                                      xcb_render_pictformat_t,
                                                  glyphset:
                                                      xcb_render_glyphset_t,
                                                  src_x: i16, src_y: i16,
                                                  glyphcmds_len: u32,
                                                  glyphcmds: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_32(c: *mut xcb_connection_t, op: u8,
                                          src: xcb_render_picture_t,
                                          dst: xcb_render_picture_t,
                                          mask_format:
                                              xcb_render_pictformat_t,
                                          glyphset: xcb_render_glyphset_t,
                                          src_x: i16, src_y: i16,
                                          glyphcmds_len: u32,
                                          glyphcmds: *const u8)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_32_glyphcmds(R:
                                                        *const xcb_render_composite_glyphs_32_request_t)
     -> *mut u8;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_32_glyphcmds_length(R:
                                                               *const xcb_render_composite_glyphs_32_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_composite_glyphs_32_glyphcmds_end(R:
                                                            *const xcb_render_composite_glyphs_32_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_fill_rectangles_sizeof(_buffer: *const libc::c_void,
                                             rects_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_fill_rectangles_checked(c: *mut xcb_connection_t,
                                              op: u8,
                                              dst: xcb_render_picture_t,
                                              color: xcb_render_color_t,
                                              rects_len: u32,
                                              rects: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_fill_rectangles(c: *mut xcb_connection_t, op: u8,
                                      dst: xcb_render_picture_t,
                                      color: xcb_render_color_t,
                                      rects_len: u32,
                                      rects: *const xcb_rectangle_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_fill_rectangles_rects(R:
                                                *const xcb_render_fill_rectangles_request_t)
     -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_render_fill_rectangles_rects_length(R:
                                                       *const xcb_render_fill_rectangles_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_fill_rectangles_rects_iterator(R:
                                                         *const xcb_render_fill_rectangles_request_t)
     -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_render_create_cursor_checked(c: *mut xcb_connection_t,
                                            cid: xcb_cursor_t,
                                            source: xcb_render_picture_t,
                                            x: u16, y: u16)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_cursor(c: *mut xcb_connection_t,
                                    cid: xcb_cursor_t,
                                    source: xcb_render_picture_t, x: u16,
                                    y: u16) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_transform_next(i: *mut xcb_render_transform_iterator_t);
}
extern "C" {
    pub fn xcb_render_transform_end(i: xcb_render_transform_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_set_picture_transform_checked(c: *mut xcb_connection_t,
                                                    picture:
                                                        xcb_render_picture_t,
                                                    transform:
                                                        xcb_render_transform_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_set_picture_transform(c: *mut xcb_connection_t,
                                            picture: xcb_render_picture_t,
                                            transform: xcb_render_transform_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_query_filters_sizeof(_buffer: *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_query_filters(c: *mut xcb_connection_t,
                                    drawable: xcb_drawable_t)
     -> xcb_render_query_filters_cookie_t;
}
extern "C" {
    pub fn xcb_render_query_filters_unchecked(c: *mut xcb_connection_t,
                                              drawable: xcb_drawable_t)
     -> xcb_render_query_filters_cookie_t;
}
extern "C" {
    pub fn xcb_render_query_filters_aliases(R:
                                                *const xcb_render_query_filters_reply_t)
     -> *mut u16;
}
extern "C" {
    pub fn xcb_render_query_filters_aliases_length(R:
                                                       *const xcb_render_query_filters_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_query_filters_aliases_end(R:
                                                    *const xcb_render_query_filters_reply_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_query_filters_filters_length(R:
                                                       *const xcb_render_query_filters_reply_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_query_filters_filters_iterator(R:
                                                         *const xcb_render_query_filters_reply_t)
     -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_render_query_filters_reply(c: *mut xcb_connection_t,
                                          cookie:
                                              xcb_render_query_filters_cookie_t,
                                          e: *mut *mut xcb_generic_error_t)
     -> *mut xcb_render_query_filters_reply_t;
}
extern "C" {
    pub fn xcb_render_set_picture_filter_sizeof(_buffer: *const libc::c_void,
                                                values_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_set_picture_filter_checked(c: *mut xcb_connection_t,
                                                 picture:
                                                     xcb_render_picture_t,
                                                 filter_len: u16,
                                                 filter: *const libc::c_char,
                                                 values_len: u32,
                                                 values:
                                                     *const xcb_render_fixed_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_set_picture_filter(c: *mut xcb_connection_t,
                                         picture: xcb_render_picture_t,
                                         filter_len: u16,
                                         filter: *const libc::c_char,
                                         values_len: u32,
                                         values: *const xcb_render_fixed_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_set_picture_filter_filter(R:
                                                    *const xcb_render_set_picture_filter_request_t)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn xcb_render_set_picture_filter_filter_length(R:
                                                           *const xcb_render_set_picture_filter_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_set_picture_filter_filter_end(R:
                                                        *const xcb_render_set_picture_filter_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_set_picture_filter_values(R:
                                                    *const xcb_render_set_picture_filter_request_t)
     -> *mut xcb_render_fixed_t;
}
extern "C" {
    pub fn xcb_render_set_picture_filter_values_length(R:
                                                           *const xcb_render_set_picture_filter_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_set_picture_filter_values_end(R:
                                                        *const xcb_render_set_picture_filter_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_animcursorelt_next(i:
                                             *mut xcb_render_animcursorelt_iterator_t);
}
extern "C" {
    pub fn xcb_render_animcursorelt_end(i:
                                            xcb_render_animcursorelt_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_create_anim_cursor_sizeof(_buffer: *const libc::c_void,
                                                cursors_len: u32)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_anim_cursor_checked(c: *mut xcb_connection_t,
                                                 cid: xcb_cursor_t,
                                                 cursors_len: u32,
                                                 cursors:
                                                     *const xcb_render_animcursorelt_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_anim_cursor(c: *mut xcb_connection_t,
                                         cid: xcb_cursor_t, cursors_len: u32,
                                         cursors:
                                             *const xcb_render_animcursorelt_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_anim_cursor_cursors(R:
                                                     *const xcb_render_create_anim_cursor_request_t)
     -> *mut xcb_render_animcursorelt_t;
}
extern "C" {
    pub fn xcb_render_create_anim_cursor_cursors_length(R:
                                                            *const xcb_render_create_anim_cursor_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_anim_cursor_cursors_iterator(R:
                                                              *const xcb_render_create_anim_cursor_request_t)
     -> xcb_render_animcursorelt_iterator_t;
}
extern "C" {
    pub fn xcb_render_spanfix_next(i: *mut xcb_render_spanfix_iterator_t);
}
extern "C" {
    pub fn xcb_render_spanfix_end(i: xcb_render_spanfix_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_trap_next(i: *mut xcb_render_trap_iterator_t);
}
extern "C" {
    pub fn xcb_render_trap_end(i: xcb_render_trap_iterator_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_add_traps_sizeof(_buffer: *const libc::c_void,
                                       traps_len: u32) -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_add_traps_checked(c: *mut xcb_connection_t,
                                        picture: xcb_render_picture_t,
                                        x_off: i16, y_off: i16,
                                        traps_len: u32,
                                        traps: *const xcb_render_trap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_add_traps(c: *mut xcb_connection_t,
                                picture: xcb_render_picture_t, x_off: i16,
                                y_off: i16, traps_len: u32,
                                traps: *const xcb_render_trap_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_add_traps_traps(R:
                                          *const xcb_render_add_traps_request_t)
     -> *mut xcb_render_trap_t;
}
extern "C" {
    pub fn xcb_render_add_traps_traps_length(R:
                                                 *const xcb_render_add_traps_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_add_traps_traps_iterator(R:
                                                   *const xcb_render_add_traps_request_t)
     -> xcb_render_trap_iterator_t;
}
extern "C" {
    pub fn xcb_render_create_solid_fill_checked(c: *mut xcb_connection_t,
                                                picture: xcb_render_picture_t,
                                                color: xcb_render_color_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_solid_fill(c: *mut xcb_connection_t,
                                        picture: xcb_render_picture_t,
                                        color: xcb_render_color_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_linear_gradient_sizeof(_buffer:
                                                        *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_linear_gradient_checked(c: *mut xcb_connection_t,
                                                     picture:
                                                         xcb_render_picture_t,
                                                     p1:
                                                         xcb_render_pointfix_t,
                                                     p2:
                                                         xcb_render_pointfix_t,
                                                     num_stops: u32,
                                                     stops:
                                                         *const xcb_render_fixed_t,
                                                     colors:
                                                         *const xcb_render_color_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_linear_gradient(c: *mut xcb_connection_t,
                                             picture: xcb_render_picture_t,
                                             p1: xcb_render_pointfix_t,
                                             p2: xcb_render_pointfix_t,
                                             num_stops: u32,
                                             stops: *const xcb_render_fixed_t,
                                             colors:
                                                 *const xcb_render_color_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_linear_gradient_stops(R:
                                                       *const xcb_render_create_linear_gradient_request_t)
     -> *mut xcb_render_fixed_t;
}
extern "C" {
    pub fn xcb_render_create_linear_gradient_stops_length(R:
                                                              *const xcb_render_create_linear_gradient_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_linear_gradient_stops_end(R:
                                                           *const xcb_render_create_linear_gradient_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_create_linear_gradient_colors(R:
                                                        *const xcb_render_create_linear_gradient_request_t)
     -> *mut xcb_render_color_t;
}
extern "C" {
    pub fn xcb_render_create_linear_gradient_colors_length(R:
                                                               *const xcb_render_create_linear_gradient_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_linear_gradient_colors_iterator(R:
                                                                 *const xcb_render_create_linear_gradient_request_t)
     -> xcb_render_color_iterator_t;
}
extern "C" {
    pub fn xcb_render_create_radial_gradient_sizeof(_buffer:
                                                        *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_radial_gradient_checked(c: *mut xcb_connection_t,
                                                     picture:
                                                         xcb_render_picture_t,
                                                     inner:
                                                         xcb_render_pointfix_t,
                                                     outer:
                                                         xcb_render_pointfix_t,
                                                     inner_radius:
                                                         xcb_render_fixed_t,
                                                     outer_radius:
                                                         xcb_render_fixed_t,
                                                     num_stops: u32,
                                                     stops:
                                                         *const xcb_render_fixed_t,
                                                     colors:
                                                         *const xcb_render_color_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_radial_gradient(c: *mut xcb_connection_t,
                                             picture: xcb_render_picture_t,
                                             inner: xcb_render_pointfix_t,
                                             outer: xcb_render_pointfix_t,
                                             inner_radius: xcb_render_fixed_t,
                                             outer_radius: xcb_render_fixed_t,
                                             num_stops: u32,
                                             stops: *const xcb_render_fixed_t,
                                             colors:
                                                 *const xcb_render_color_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_radial_gradient_stops(R:
                                                       *const xcb_render_create_radial_gradient_request_t)
     -> *mut xcb_render_fixed_t;
}
extern "C" {
    pub fn xcb_render_create_radial_gradient_stops_length(R:
                                                              *const xcb_render_create_radial_gradient_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_radial_gradient_stops_end(R:
                                                           *const xcb_render_create_radial_gradient_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_create_radial_gradient_colors(R:
                                                        *const xcb_render_create_radial_gradient_request_t)
     -> *mut xcb_render_color_t;
}
extern "C" {
    pub fn xcb_render_create_radial_gradient_colors_length(R:
                                                               *const xcb_render_create_radial_gradient_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_radial_gradient_colors_iterator(R:
                                                                 *const xcb_render_create_radial_gradient_request_t)
     -> xcb_render_color_iterator_t;
}
extern "C" {
    pub fn xcb_render_create_conical_gradient_sizeof(_buffer:
                                                         *const libc::c_void)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_conical_gradient_checked(c:
                                                          *mut xcb_connection_t,
                                                      picture:
                                                          xcb_render_picture_t,
                                                      center:
                                                          xcb_render_pointfix_t,
                                                      angle:
                                                          xcb_render_fixed_t,
                                                      num_stops: u32,
                                                      stops:
                                                          *const xcb_render_fixed_t,
                                                      colors:
                                                          *const xcb_render_color_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_conical_gradient(c: *mut xcb_connection_t,
                                              picture: xcb_render_picture_t,
                                              center: xcb_render_pointfix_t,
                                              angle: xcb_render_fixed_t,
                                              num_stops: u32,
                                              stops:
                                                  *const xcb_render_fixed_t,
                                              colors:
                                                  *const xcb_render_color_t)
     -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_render_create_conical_gradient_stops(R:
                                                        *const xcb_render_create_conical_gradient_request_t)
     -> *mut xcb_render_fixed_t;
}
extern "C" {
    pub fn xcb_render_create_conical_gradient_stops_length(R:
                                                               *const xcb_render_create_conical_gradient_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_conical_gradient_stops_end(R:
                                                            *const xcb_render_create_conical_gradient_request_t)
     -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_render_create_conical_gradient_colors(R:
                                                         *const xcb_render_create_conical_gradient_request_t)
     -> *mut xcb_render_color_t;
}
extern "C" {
    pub fn xcb_render_create_conical_gradient_colors_length(R:
                                                                *const xcb_render_create_conical_gradient_request_t)
     -> libc::c_int;
}
extern "C" {
    pub fn xcb_render_create_conical_gradient_colors_iterator(R:
                                                                  *const xcb_render_create_conical_gradient_request_t)
     -> xcb_render_color_iterator_t;
}
extern "C" {
    pub fn cairo_xcb_surface_create(connection: *mut xcb_connection_t,
                                    drawable: xcb_drawable_t,
                                    visual: *mut xcb_visualtype_t,
                                    width: libc::c_int, height: libc::c_int)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_xcb_surface_create_for_bitmap(connection:
                                                   *mut xcb_connection_t,
                                               screen: *mut xcb_screen_t,
                                               bitmap: xcb_pixmap_t,
                                               width: libc::c_int,
                                               height: libc::c_int)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_xcb_surface_create_with_xrender_format(connection:
                                                            *mut xcb_connection_t,
                                                        screen:
                                                            *mut xcb_screen_t,
                                                        drawable:
                                                            xcb_drawable_t,
                                                        format:
                                                            *mut xcb_render_pictforminfo_t,
                                                        width: libc::c_int,
                                                        height: libc::c_int)
     -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_xcb_surface_set_size(surface: *mut cairo_surface_t,
                                      width: libc::c_int,
                                      height: libc::c_int);
}
extern "C" {
    pub fn cairo_xcb_surface_set_drawable(surface: *mut cairo_surface_t,
                                          drawable: xcb_drawable_t,
                                          width: libc::c_int,
                                          height: libc::c_int);
}
extern "C" {
    pub fn cairo_xcb_device_get_connection(device: *mut cairo_device_t)
     -> *mut xcb_connection_t;
}
extern "C" {
    pub fn cairo_xcb_device_debug_cap_xshm_version(device:
                                                       *mut cairo_device_t,
                                                   major_version: libc::c_int,
                                                   minor_version:
                                                       libc::c_int);
}
extern "C" {
    pub fn cairo_xcb_device_debug_cap_xrender_version(device:
                                                          *mut cairo_device_t,
                                                      major_version:
                                                          libc::c_int,
                                                      minor_version:
                                                          libc::c_int);
}
extern "C" {
    pub fn cairo_xcb_device_debug_set_precision(device: *mut cairo_device_t,
                                                precision: libc::c_int);
}
extern "C" {
    pub fn cairo_xcb_device_debug_get_precision(device: *mut cairo_device_t)
     -> libc::c_int;
}
